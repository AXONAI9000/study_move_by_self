# æ¯æ—¥è€ƒè¯• - ç¼–ç¨‹é¢˜

**è€ƒè¯•æ—¶é—´**: 30 åˆ†é’Ÿ  
**é¢˜ç›®æ•°é‡**: 3 é¢˜  
**æ€»åˆ†**: 60 åˆ†

---

## ç¼–ç¨‹é¢˜ 1: ä»·æ ¼èšåˆå™¨ï¼ˆ20 åˆ†ï¼‰

### é—®é¢˜æè¿°

å®ç°ä¸€ä¸ªä»·æ ¼èšåˆå‡½æ•°ï¼Œè¦æ±‚ï¼š

1. ä»å¤šä¸ªæ•°æ®æºè·å–ä»·æ ¼
2. è¿‡æ»¤æ‰å¼‚å¸¸å€¼ï¼ˆåç¦»ä¸­ä½æ•°è¶…è¿‡ 20% çš„å€¼ï¼‰
3. è¿”å›å‰©ä½™ä»·æ ¼çš„ä¸­ä½æ•°

### å‡½æ•°ç­¾å

```move
module exam::price_aggregator {
    use std::vector;
    
    /// èšåˆä»·æ ¼å¹¶è¿‡æ»¤å¼‚å¸¸å€¼
    /// @param prices - åŸå§‹ä»·æ ¼åˆ—è¡¨
    /// @return è¿‡æ»¤åçš„ä¸­ä½æ•°ä»·æ ¼
    public fun aggregate_with_outlier_filter(
        prices: vector<u64>
    ): u64 {
        // TODO: å®ç°è¿™ä¸ªå‡½æ•°
    }
}
```

### æµ‹è¯•ç”¨ä¾‹

```move
#[test]
fun test_case_1() {
    // æ­£å¸¸æƒ…å†µï¼šæ— å¼‚å¸¸å€¼
    let prices = vector[100, 102, 103, 101, 105];
    let result = aggregate_with_outlier_filter(prices);
    assert!(result == 102 || result == 103, 0);
}

#[test]
fun test_case_2() {
    // æœ‰å¼‚å¸¸å€¼
    let prices = vector[100, 102, 103, 105, 1000];  // 1000 æ˜¯å¼‚å¸¸å€¼
    let result = aggregate_with_outlier_filter(prices);
    // åº”è¯¥è¿‡æ»¤æ‰ 1000ï¼Œè¿”å› [100,102,103,105] çš„ä¸­ä½æ•°
    assert!(result >= 102 && result <= 103, 0);
}

#[test]
fun test_case_3() {
    // å¤šä¸ªå¼‚å¸¸å€¼
    let prices = vector[10, 100, 102, 103, 105, 500];
    // 10 å’Œ 500 åº”è¢«è¿‡æ»¤
    let result = aggregate_with_outlier_filter(prices);
    assert!(result >= 102 && result <= 103, 0);
}
```

### è¯„åˆ†æ ‡å‡†

- **æ­£ç¡®è®¡ç®—ä¸­ä½æ•°**: 5 åˆ†
- **æ­£ç¡®è¿‡æ»¤å¼‚å¸¸å€¼**: 10 åˆ†
- **å¤„ç†è¾¹ç•Œæƒ…å†µ**: 3 åˆ†
- **ä»£ç è´¨é‡**: 2 åˆ†

### å®ç°æç¤º

1. å…ˆè®¡ç®—åˆæ­¥ä¸­ä½æ•°
2. è¿‡æ»¤åç¦»ä¸­ä½æ•°è¶…è¿‡ 20% çš„å€¼
3. å¯¹å‰©ä½™å€¼é‡æ–°è®¡ç®—ä¸­ä½æ•°

### ä½ çš„ç­”æ¡ˆ

```move
module exam::price_aggregator {
    use std::vector;
    
    /// æ’åºå‡½æ•°
    fun sort_prices(prices: &mut vector<u64>) {
        // å®ç°æ’åº
    }
    
    /// è®¡ç®—ä¸­ä½æ•°
    fun calculate_median(prices: &vector<u64>): u64 {
        // å®ç°ä¸­ä½æ•°è®¡ç®—
    }
    
    /// èšåˆä»·æ ¼å¹¶è¿‡æ»¤å¼‚å¸¸å€¼
    public fun aggregate_with_outlier_filter(
        prices: vector<u64>
    ): u64 {
        // åœ¨è¿™é‡Œå®ç°
        
        
        
        
        
        
        
        
        
    }
}
```

---

## ç¼–ç¨‹é¢˜ 2: ä»·æ ¼æ–°é²œåº¦æ£€æŸ¥å™¨ï¼ˆ20 åˆ†ï¼‰

### é—®é¢˜æè¿°

å®ç°ä¸€ä¸ªä»·æ ¼ç¼“å­˜ç³»ç»Ÿï¼Œè¦æ±‚ï¼š

1. å­˜å‚¨ä»·æ ¼å’Œæ—¶é—´æˆ³
2. åªæœ‰å½“ä»·æ ¼è¿‡æœŸæ—¶æ‰æ›´æ–°
3. æä¾›ä»·æ ¼æŸ¥è¯¢æ¥å£ï¼Œè‡ªåŠ¨æ£€æŸ¥æ–°é²œåº¦

### è¦æ±‚å®ç°

```move
module exam::price_cache {
    use std::signer;
    use aptos_framework::timestamp;
    
    /// é”™è¯¯ç 
    const ERROR_STALE_PRICE: u64 = 1;
    const ERROR_NOT_INITIALIZED: u64 = 2;
    
    /// ä»·æ ¼ç¼“å­˜
    struct PriceCache has key {
        price: u64,
        last_update: u64,
        max_age: u64,  // æœ€å¤§å¹´é¾„ï¼ˆç§’ï¼‰
    }
    
    /// åˆå§‹åŒ–ä»·æ ¼ç¼“å­˜
    /// @param max_age - æœ€å¤§ä»·æ ¼å¹´é¾„ï¼ˆç§’ï¼‰
    public entry fun initialize(
        account: &signer,
        initial_price: u64,
        max_age: u64
    ) {
        // TODO: å®ç°
    }
    
    /// æ›´æ–°ä»·æ ¼ï¼ˆä»…å½“éœ€è¦æ—¶ï¼‰
    /// @param new_price - æ–°ä»·æ ¼
    /// @return æ˜¯å¦å®é™…æ›´æ–°äº†
    public fun update_if_stale(
        account_addr: address,
        new_price: u64
    ): bool acquires PriceCache {
        // TODO: å®ç°
    }
    
    /// è·å–ä»·æ ¼ï¼ˆæ£€æŸ¥æ–°é²œåº¦ï¼‰
    /// @return ä»·æ ¼å’Œæ—¶é—´æˆ³
    public fun get_price(
        account_addr: address
    ): (u64, u64) acquires PriceCache {
        // TODO: å®ç°
    }
    
    /// æ£€æŸ¥ä»·æ ¼æ˜¯å¦æ–°é²œ
    #[view]
    public fun is_fresh(
        account_addr: address
    ): bool acquires PriceCache {
        // TODO: å®ç°
    }
}
```

### æµ‹è¯•ç”¨ä¾‹

```move
#[test(account = @0x1)]
fun test_initialize(account: &signer) {
    timestamp::set_time_has_started_for_testing(&framework_signer);
    
    price_cache::initialize(account, 1000, 60);  // 60ç§’æœ‰æ•ˆæœŸ
    
    let (price, _) = price_cache::get_price(@0x1);
    assert!(price == 1000, 0);
}

#[test(account = @0x1)]
fun test_update_if_stale(account: &signer) {
    timestamp::set_time_has_started_for_testing(&framework_signer);
    price_cache::initialize(account, 1000, 60);
    
    // ç«‹å³æ›´æ–° - ä¸åº”è¯¥æ›´æ–°
    let updated = price_cache::update_if_stale(@0x1, 2000);
    assert!(!updated, 0);
    
    // å¿«è¿› 61 ç§’
    timestamp::fast_forward_seconds(61);
    
    // ç°åœ¨åº”è¯¥æ›´æ–°
    let updated = price_cache::update_if_stale(@0x1, 2000);
    assert!(updated, 1);
    
    let (price, _) = price_cache::get_price(@0x1);
    assert!(price == 2000, 2);
}
```

### è¯„åˆ†æ ‡å‡†

- **æ­£ç¡®åˆå§‹åŒ–**: 4 åˆ†
- **æ–°é²œåº¦æ£€æŸ¥æ­£ç¡®**: 8 åˆ†
- **æ¡ä»¶æ›´æ–°é€»è¾‘**: 6 åˆ†
- **ä»£ç è´¨é‡**: 2 åˆ†

### ä½ çš„ç­”æ¡ˆ

```move
module exam::price_cache {
    use std::signer;
    use aptos_framework::timestamp;
    
    const ERROR_STALE_PRICE: u64 = 1;
    const ERROR_NOT_INITIALIZED: u64 = 2;
    
    struct PriceCache has key {
        price: u64,
        last_update: u64,
        max_age: u64,
    }
    
    public entry fun initialize(
        account: &signer,
        initial_price: u64,
        max_age: u64
    ) {
        // åœ¨è¿™é‡Œå®ç°
        
        
        
        
    }
    
    public fun update_if_stale(
        account_addr: address,
        new_price: u64
    ): bool acquires PriceCache {
        // åœ¨è¿™é‡Œå®ç°
        
        
        
        
        
        
        
        
    }
    
    public fun get_price(
        account_addr: address
    ): (u64, u64) acquires PriceCache {
        // åœ¨è¿™é‡Œå®ç°
        
        
        
        
        
    }
    
    #[view]
    public fun is_fresh(
        account_addr: address
    ): bool acquires PriceCache {
        // åœ¨è¿™é‡Œå®ç°
        
        
        
        
    }
}
```

---

## ç¼–ç¨‹é¢˜ 3: ä»·æ ¼åå·®æ£€æŸ¥å™¨ï¼ˆ20 åˆ†ï¼‰

### é—®é¢˜æè¿°

å®ç°ä¸€ä¸ªä»·æ ¼åå·®æ£€æŸ¥å™¨ï¼Œç”¨äºï¼š

1. å¯¹æ¯”å¤šä¸ªä»·æ ¼æº
2. è®¡ç®—æœ€å¤§åå·®
3. å¦‚æœåå·®è¶…è¿‡é˜ˆå€¼åˆ™å¤±è´¥

### è¦æ±‚å®ç°

```move
module exam::deviation_checker {
    use std::vector;
    
    /// é”™è¯¯ç 
    const ERROR_EMPTY_PRICES: u64 = 1;
    const ERROR_DEVIATION_TOO_HIGH: u64 = 2;
    
    /// è®¡ç®—ä¸¤ä¸ªä»·æ ¼çš„åå·®ï¼ˆbasis pointsï¼‰
    /// @return åå·®ï¼ˆ10000 = 100%ï¼‰
    public fun calculate_deviation(
        price1: u64,
        price2: u64
    ): u64 {
        // TODO: å®ç°
    }
    
    /// æ£€æŸ¥æ‰€æœ‰ä»·æ ¼çš„æœ€å¤§åå·®
    /// @param prices - ä»·æ ¼åˆ—è¡¨
    /// @param max_deviation_bp - æœ€å¤§å…è®¸åå·®ï¼ˆbasis pointsï¼‰
    /// @return å®é™…æœ€å¤§åå·®
    public fun check_max_deviation(
        prices: vector<u64>,
        max_deviation_bp: u64
    ): u64 {
        // TODO: å®ç°
        // å¦‚æœåå·®è¶…è¿‡ max_deviation_bpï¼Œåº”è¯¥ abort
    }
    
    /// éªŒè¯ä»·æ ¼ä¸€è‡´æ€§
    /// @return æ˜¯å¦æ‰€æœ‰ä»·æ ¼éƒ½åœ¨å…è®¸åå·®å†…
    public fun verify_price_consistency(
        prices: vector<u64>,
        max_deviation_bp: u64
    ): bool {
        // TODO: å®ç°
    }
}
```

### æµ‹è¯•ç”¨ä¾‹

```move
#[test]
fun test_calculate_deviation() {
    // 100 å’Œ 110 çš„åå·®æ˜¯ 10%
    let deviation = deviation_checker::calculate_deviation(100, 110);
    assert!(deviation == 1000, 0);  // 1000 bp = 10%
    
    // 100 å’Œ 90 çš„åå·®ä¹Ÿæ˜¯ 10%
    let deviation = deviation_checker::calculate_deviation(100, 90);
    assert!(deviation == 1000, 0);
}

#[test]
fun test_check_max_deviation_pass() {
    // æ‰€æœ‰ä»·æ ¼åœ¨ 5% èŒƒå›´å†…
    let prices = vector[100, 102, 103, 104, 105];
    let max_dev = deviation_checker::check_max_deviation(prices, 500);
    assert!(max_dev <= 500, 0);
}

#[test]
#[expected_failure(abort_code = ERROR_DEVIATION_TOO_HIGH)]
fun test_check_max_deviation_fail() {
    // 100 å’Œ 120 åå·® 20%ï¼Œè¶…è¿‡ 10% é™åˆ¶
    let prices = vector[100, 105, 120];
    deviation_checker::check_max_deviation(prices, 1000);  // åº”è¯¥å¤±è´¥
}

#[test]
fun test_verify_consistency() {
    let prices = vector[100, 102, 103];
    let is_consistent = deviation_checker::verify_price_consistency(prices, 500);
    assert!(is_consistent, 0);
    
    let prices = vector[100, 200];  // åå·® 100%
    let is_consistent = deviation_checker::verify_price_consistency(prices, 1000);
    assert!(!is_consistent, 1);
}
```

### è¯„åˆ†æ ‡å‡†

- **åå·®è®¡ç®—æ­£ç¡®**: 6 åˆ†
- **æœ€å¤§åå·®æ£€æŸ¥**: 8 åˆ†
- **ä¸€è‡´æ€§éªŒè¯**: 4 åˆ†
- **ä»£ç è´¨é‡**: 2 åˆ†

### å®ç°æç¤º

1. åå·®è®¡ç®—ï¼š`|price1 - price2| / min(price1, price2) * 10000`
2. éœ€è¦æ£€æŸ¥æ‰€æœ‰ä»·æ ¼å¯¹çš„åå·®
3. ä½¿ç”¨ assert! å¤„ç†è¶…è¿‡é˜ˆå€¼çš„æƒ…å†µ

### ä½ çš„ç­”æ¡ˆ

```move
module exam::deviation_checker {
    use std::vector;
    
    const ERROR_EMPTY_PRICES: u64 = 1;
    const ERROR_DEVIATION_TOO_HIGH: u64 = 2;
    
    public fun calculate_deviation(
        price1: u64,
        price2: u64
    ): u64 {
        // åœ¨è¿™é‡Œå®ç°
        
        
        
        
        
        
    }
    
    public fun check_max_deviation(
        prices: vector<u64>,
        max_deviation_bp: u64
    ): u64 {
        // åœ¨è¿™é‡Œå®ç°
        
        
        
        
        
        
        
        
        
        
        
    }
    
    public fun verify_price_consistency(
        prices: vector<u64>,
        max_deviation_bp: u64
    ): bool {
        // åœ¨è¿™é‡Œå®ç°
        
        
        
        
        
        
    }
}
```

---

## æäº¤è¯´æ˜

1. **ä»£ç è¦æ±‚**
   - æ‰€æœ‰å‡½æ•°å¿…é¡»å®ç°
   - ä»£ç å¿…é¡»èƒ½å¤Ÿç¼–è¯‘
   - é€šè¿‡æ‰€æœ‰æµ‹è¯•ç”¨ä¾‹

2. **è¯„åˆ†è¯´æ˜**
   - æ¯é¢˜ 20 åˆ†
   - é€šè¿‡æµ‹è¯•ç”¨ä¾‹ï¼š60%
   - ä»£ç è´¨é‡ï¼š20%
   - è¾¹ç•Œå¤„ç†ï¼š20%

3. **æ—¶é—´ç®¡ç†**
   - é¢˜ç›® 1: 10 åˆ†é’Ÿ
   - é¢˜ç›® 2: 10 åˆ†é’Ÿ
   - é¢˜ç›® 3: 10 åˆ†é’Ÿ

---

## è¯„åˆ†è¡¨

| é¢˜ç›® | å¾—åˆ† | æ»¡åˆ† |
|------|------|------|
| é¢˜ç›® 1 | ____ | 20 |
| é¢˜ç›® 2 | ____ | 20 |
| é¢˜ç›® 3 | ____ | 20 |
| **æ€»è®¡** | ____ | **60** |

---

**è€ƒè¯•å¼€å§‹æ—¶é—´**: _______  
**è€ƒè¯•ç»“æŸæ—¶é—´**: _______  
**å®é™…ç”¨æ—¶**: _______ åˆ†é’Ÿ

**Good Luck! ğŸ€**

# Day 32 实践任务

## 📋 任务概览

今天的实践任务将帮助你深入理解MEV策略和防护机制。你将实现一个完整的MEV检测与防护系统。

**总预计时间**: 3小时  
**难度**: ⭐⭐⭐⭐☆

---

## 🎯 任务列表

### 任务 1: MEV检测器（60分钟）⭐⭐⭐⭐

实现一个能够检测Front-running和Sandwich攻击的检测系统。

#### 要求

1. **交易记录模块**
   - 记录最近的交易历史
   - 存储交易的关键信息（发送者、金额、gas、时间戳）
   - 维护滑动窗口（最近100笔交易）

2. **Sandwich攻击检测**
   ```move
   检测条件：
   - 前后两笔交易来自同一地址
   - 中间的交易来自不同地址
   - 前后交易金额相似（±10%）
   - 三笔交易时间间隔很短（<10秒）
   - 前后交易使用更高的gas price
   ```

3. **Front-running检测**
   ```move
   检测条件：
   - 两笔连续交易操作同一个池
   - 第一笔交易使用更高的gas price
   - 第一笔交易在第二笔交易可能的mempool时间内提交
   ```

4. **告警系统**
   - 使用Event发出MEV告警
   - 记录可疑地址的行为次数
   - 提供查询可疑地址的接口

#### 实现框架

```move
module mev_tasks::detector {
    use std::signer;
    use std::vector;
    use aptos_framework::event;
    use aptos_framework::timestamp;

    struct TransactionRecord has store, copy, drop {
        sender: address,
        pool: address,
        amount: u64,
        is_buy: bool,
        gas_price: u64,
        timestamp: u64,
    }

    struct MEVDetector has key {
        // TODO: 定义检测器结构
    }

    struct MEVAlert has drop, store {
        // TODO: 定义告警事件
    }

    public fun initialize(admin: &signer) {
        // TODO: 初始化检测器
    }

    public fun record_transaction(
        detector_addr: address,
        sender: address,
        pool: address,
        amount: u64,
        is_buy: bool,
        gas_price: u64,
    ) acquires MEVDetector {
        // TODO: 记录交易并检测可疑模式
    }

    fun detect_sandwich(
        transactions: &vector<TransactionRecord>,
    ): bool {
        // TODO: 实现sandwich检测逻辑
    }

    fun detect_frontrun(
        transactions: &vector<TransactionRecord>,
    ): bool {
        // TODO: 实现front-running检测逻辑
    }

    public fun get_suspicious_count(
        detector_addr: address,
        addr: address,
    ): u64 acquires MEVDetector {
        // TODO: 查询地址的可疑行为次数
    }
}
```

#### 测试用例

```move
#[test]
fun test_sandwich_detection() {
    // 模拟sandwich攻击场景
    // 验证能正确检测
}

#[test]
fun test_normal_transactions() {
    // 模拟正常交易
    // 验证不会误报
}
```

---

### 任务 2: 多层防护系统（60分钟）⭐⭐⭐⭐

实现一个包含多种防护机制的DEX模块。

#### 要求

1. **滑点保护**
   - 用户可设置最大滑点百分比
   - 交易前验证价格影响
   - 根据交易大小推荐合理滑点

2. **TWAP价格预言机**
   - 累积价格历史
   - 计算时间加权平均价格
   - 支持多个时间段查询（5分钟、15分钟、1小时）

3. **速率限制**
   - 限制单个地址的交易频率
   - 防止高频MEV机器人
   - 合理设置冷却时间

4. **批量拍卖模式**
   - 收集一批订单
   - 计算统一清算价格
   - 批量执行，消除顺序优势

#### 实现框架

```move
module mev_tasks::protected_dex {
    use std::signer;
    use aptos_framework::coin::{Self, Coin};
    use aptos_framework::timestamp;

    // ===== 滑点保护 =====
    
    public fun swap_with_slippage_protection<CoinIn, CoinOut>(
        user: &signer,
        amount_in: u64,
        min_amount_out: u64,
        max_slippage_bps: u64,
    ): Coin<CoinOut> {
        // TODO: 实现带滑点保护的swap
    }

    public fun calculate_price_impact(
        amount_in: u64,
        reserve_in: u64,
        reserve_out: u64,
    ): u64 {
        // TODO: 计算价格影响（基点）
    }

    // ===== TWAP预言机 =====

    struct TWAPOracle has key {
        // TODO: 定义TWAP结构
    }

    public fun update_price(oracle_addr: address, new_price: u64) {
        // TODO: 更新价格并累加
    }

    public fun get_twap(
        oracle_addr: address,
        period_seconds: u64,
    ): u64 {
        // TODO: 计算TWAP
    }

    // ===== 速率限制 =====

    struct RateLimiter has key {
        // TODO: 定义速率限制结构
    }

    public fun check_rate_limit(user: address): bool {
        // TODO: 检查用户是否超过速率限制
    }

    // ===== 批量拍卖 =====

    struct AuctionBatch has key {
        // TODO: 定义批量拍卖结构
    }

    public entry fun submit_order_to_batch(
        user: &signer,
        amount: u64,
        limit_price: u64,
    ) {
        // TODO: 提交订单到当前批次
    }

    public fun execute_batch() {
        // TODO: 执行批量拍卖
    }
}
```

#### 测试用例

```move
#[test]
fun test_slippage_protection() {
    // 测试滑点过大时拒绝交易
}

#[test]
fun test_twap_calculation() {
    // 测试TWAP计算准确性
}

#[test]
fun test_rate_limit() {
    // 测试速率限制功能
}
```

---

### 任务 3: 合规套利机器人（60分钟）⭐⭐⭐⭐⭐

实现一个合规的DEX套利机器人，只进行无受害者的套利。

#### 要求

1. **跨DEX价格监控**
   - 监控多个DEX的价格
   - 实时计算价格差异
   - 识别套利机会

2. **套利机会评估**
   - 计算预期利润
   - 估算gas成本
   - 考虑滑点影响
   - 计算净利润

3. **自动执行**
   - 当净利润 > 阈值时自动执行
   - 原子性执行（要么全部成功，要么全部失败）
   - 使用闪电贷放大收益（可选）

4. **风险管理**
   - 设置最大交易金额
   - 设置最小利润率
   - 记录所有套利尝试

#### 实现框架

```move
module mev_tasks::arbitrage_bot {
    use std::signer;
    use std::vector;
    use aptos_framework::coin::{Self, Coin};

    struct ArbitrageOpportunity has copy, drop {
        buy_dex: address,
        sell_dex: address,
        profit_bps: u64,
        optimal_amount: u64,
    }

    struct BotConfig has key {
        min_profit_bps: u64,      // 最小利润率（基点）
        max_trade_amount: u64,     // 最大交易金额
        monitored_dexes: vector<address>,
    }

    // ===== 机会扫描 =====

    public fun scan_arbitrage_opportunities(
        dexes: vector<address>,
    ): vector<ArbitrageOpportunity> {
        // TODO: 扫描所有DEX对，寻找套利机会
    }

    public fun calculate_arbitrage_profit(
        buy_price: u64,
        sell_price: u64,
        amount: u64,
        gas_cost: u64,
    ): (u64, bool) {
        // TODO: 计算套利利润和是否值得执行
        // 返回：(净利润, 是否盈利)
    }

    // ===== 套利执行 =====

    public entry fun execute_arbitrage<CoinA, CoinB>(
        bot: &signer,
        buy_dex: address,
        sell_dex: address,
        amount: u64,
    ) {
        // TODO: 执行套利
        // 1. 在低价DEX买入
        // 2. 在高价DEX卖出
        // 3. 验证盈利
    }

    // ===== 闪电贷增强版 =====

    public entry fun arbitrage_with_flash_loan<CoinA, CoinB>(
        bot: &signer,
        flash_loan_amount: u64,
        buy_dex: address,
        sell_dex: address,
    ) {
        // TODO: 使用闪电贷执行套利
        // 1. 借入闪电贷
        // 2. 执行套利
        // 3. 归还闪电贷
        // 4. 保留利润
    }

    // ===== 统计与监控 =====

    struct ArbitrageStats has key {
        total_attempts: u64,
        successful_trades: u64,
        total_profit: u64,
        total_gas_spent: u64,
    }

    public fun update_stats(
        bot_addr: address,
        profit: u64,
        gas_cost: u64,
        success: bool,
    ) {
        // TODO: 更新统计数据
    }

    public fun get_performance_metrics(
        bot_addr: address,
    ): (u64, u64, u64) {
        // TODO: 返回（成功率，总利润，平均利润）
    }
}
```

#### 测试用例

```move
#[test]
fun test_opportunity_detection() {
    // 测试能否正确识别套利机会
}

#[test]
fun test_profit_calculation() {
    // 测试利润计算准确性
}

#[test]
fun test_arbitrage_execution() {
    // 测试套利执行流程
}
```

---

## ✅ 提交清单

完成任务后，请确保：

- [ ] **任务1：MEV检测器**
  - [ ] 实现了交易记录功能
  - [ ] 能够检测Sandwich攻击
  - [ ] 能够检测Front-running
  - [ ] 实现了告警系统
  - [ ] 所有测试通过

- [ ] **任务2：多层防护系统**
  - [ ] 实现了滑点保护
  - [ ] 实现了TWAP预言机
  - [ ] 实现了速率限制
  - [ ] 实现了批量拍卖
  - [ ] 所有测试通过

- [ ] **任务3：合规套利机器人**
  - [ ] 实现了价格监控
  - [ ] 实现了机会评估
  - [ ] 实现了自动执行
  - [ ] 实现了统计功能
  - [ ] 所有测试通过

- [ ] **代码质量**
  - [ ] 代码有适当的注释
  - [ ] 错误处理完善
  - [ ] 遵循Move最佳实践

- [ ] **文档**
  - [ ] 编写了README说明使用方法
  - [ ] 记录了关键设计决策
  - [ ] 总结了学习收获

---

## 📊 评分标准

| 任务 | 分数 | 评分要点 |
|------|------|---------|
| 任务1 | 30分 | 检测准确性、误报率、代码质量 |
| 任务2 | 35分 | 防护有效性、实现完整性、性能 |
| 任务3 | 35分 | 策略正确性、盈利能力、风险控制 |
| **总分** | **100分** | 60分及格，80分优秀 |

---

## 💡 提示

### 任务1提示

1. **交易记录**
   ```move
   // 使用vector维护滑动窗口
   if (vector::length(&detector.transactions) > 100) {
       vector::remove(&mut detector.transactions, 0);
   }
   ```

2. **Sandwich检测**
   ```move
   // 检查最近3笔交易
   let len = vector::length(&transactions);
   if (len >= 3) {
       let t1 = vector::borrow(&transactions, len - 3);
       let t2 = vector::borrow(&transactions, len - 2);
       let t3 = vector::borrow(&transactions, len - 1);
       // 检查模式...
   }
   ```

### 任务2提示

1. **TWAP计算**
   ```move
   // cumulative_price += price * time_elapsed
   // twap = (cum_price_now - cum_price_old) / time_elapsed
   ```

2. **批量拍卖清算价格**
   ```move
   // 简单方法：取所有订单限价的加权平均
   // 高级方法：找供需曲线交点
   ```

### 任务3提示

1. **机会评估**
   ```move
   let revenue = (sell_price - buy_price) * amount;
   let cost = gas_cost + slippage_loss;
   let net_profit = revenue - cost;
   let should_execute = net_profit > min_profit;
   ```

2. **原子性保证**
   ```move
   // 在同一个函数中完成买入和卖出
   // 如果任何步骤失败，整个交易回滚
   ```

---

## 🎓 扩展挑战（可选）

如果你提前完成了基础任务，可以尝试：

1. **实现JIT流动性策略**
   - 在大额交易前添加流动性
   - 交易后立即移除
   - 最大化手续费收益

2. **构建MEV仪表板**
   - 可视化MEV活动
   - 实时显示检测到的攻击
   - 展示套利机会

3. **多链MEV监控**
   - 同时监控多条链
   - 识别跨链MEV机会
   - 实现跨链套利

4. **机器学习预测**
   - 训练模型预测MEV机会
   - 优化执行时机
   - 提高成功率

---

## 📝 学习总结

完成任务后，请思考：

1. **MEV的本质是什么？**
   - 是区块链的缺陷还是特性？
   - 如何平衡MEV与用户体验？

2. **防护与攻击的平衡**
   - 完全消除MEV是否可行？
   - 哪些MEV是有益的？

3. **在Aptos上的独特之处**
   - Block-STM如何影响MEV？
   - Aptos的MEV生态会如何发展？

4. **作为开发者的责任**
   - 如何设计对MEV友好的协议？
   - 如何保护用户利益？

---

**预祝学习愉快！记住：理解MEV是成为高级区块链开发者的关键一步！** 🚀

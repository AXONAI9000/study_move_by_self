# Day 07 每日考试 - 选择题

**总分：50 分（每题 5 分）**  
**时间：30 分钟**

---

## 第 1 题

以下哪个全局存储操作**不需要** `acquires` 声明？

A. `borrow_global<T>(addr)`  
B. `borrow_global_mut<T>(addr)`  
C. `move_from<T>(addr)`  
D. `move_to(account, value)`

**答案：** D

---

## 第 2 题

下列代码会产生什么错误？

```move
public fun test(account: &signer) {
    let profile1 = UserProfile { name: b"Alice", age: 25 };
    move_to(account, profile1);
    
    let profile2 = UserProfile { name: b"Bob", age: 30 };
    move_to(account, profile2);
}
```

A. 编译错误：缺少 `key` 能力  
B. 运行时错误：RESOURCE_ALREADY_EXISTS  
C. 编译错误：缺少 `acquires` 声明  
D. 没有错误

**答案：** B

---

## 第 3 题

`acquires` 关键字的主要作用是什么？

A. 提高代码执行效率  
B. 在编译期声明资源访问，防止循环依赖  
C. 允许函数修改全局变量  
D. 实现资源的动态类型检查

**答案：** B

---

## 第 4 题

以下哪个操作可以同时进行？

```move
A. let r1 = borrow_global<T>(addr); let r2 = borrow_global<T>(addr);
B. let r1 = borrow_global_mut<T>(addr); let r2 = borrow_global_mut<T>(addr);
C. let r1 = borrow_global<T>(addr); let r2 = borrow_global_mut<T>(addr);
D. 以上都不可以
```

**答案：** A

---

## 第 5 题

Move 为什么不允许同一地址存储两个相同类型的资源？

A. 为了节省存储空间  
B. 为了保证所有权唯一性和类型安全  
C. 技术限制  
D. 为了提高查询速度

**答案：** B

---

## 第 6 题

下列关于 `move_from` 的说法，哪个是**错误**的？

A. 返回的资源必须被处理  
B. 需要 `acquires` 声明  
C. 可以从任意地址移除资源  
D. 资源移除后该地址不再有此类型资源

**答案：** C

---

## 第 7 题

如何避免借用冲突？

```move
public fun process(addr: address) acquires Account {
    let balance = {
        let account = borrow_global<Account>(addr);
        account.balance
    };
    
    let account_mut = borrow_global_mut<Account>(addr);
    account_mut.balance = balance + 10;
}
```

A. 使用多个 `acquires` 声明  
B. 使用作用域分离读写操作  
C. 使用 `copy` 能力  
D. 不可能避免

**答案：** B

---

## 第 8 题

以下代码的问题是什么？

```move
public fun transfer(from: &signer, to: address, amount: u64) acquires Account {
    let from_account = borrow_global_mut<Account>(signer::address_of(from));
    let to_account = borrow_global_mut<Account>(to);
    
    from_account.balance = from_account.balance - amount;
    to_account.balance = to_account.balance + amount;
}
```

A. 缺少 `acquires` 声明  
B. 可能产生借用冲突  
C. 没有检查余额  
D. B 和 C 都对

**答案：** D

---

## 第 9 题

资源注册表模式的主要优势是什么？

A. 节省 Gas 费用  
B. 集中管理多个用户的数据  
C. 提高查询速度  
D. 简化代码逻辑

**答案：** B

---

## 第 10 题

以下哪个函数调用**不需要**在调用者中声明 `acquires`？

```move
// 被调用函数
public fun helper(addr: address): u64 acquires Account {
    borrow_global<Account>(addr).balance
}

// 调用者
public fun caller(addr: address): u64 {
    helper(addr)  // 这里
}
```

A. 正确，不需要 `acquires`  
B. 错误，需要声明 `acquires Account`  
C. 只在某些情况下需要  
D. 取决于编译器设置

**答案：** B

---

## 第 11 题（附加题，10 分）

阅读以下代码，判断哪个说法是**正确**的：

```move
struct Wallet has key {
    balance: u64
}

public fun get_or_create(account: &signer): &mut Wallet acquires Wallet {
    let addr = signer::address_of(account);
    if (!exists<Wallet>(addr)) {
        move_to(account, Wallet { balance: 0 });
    };
    borrow_global_mut<Wallet>(addr)
}
```

A. 这是懒加载模式，第一次调用时创建资源  
B. `exists` 也需要 `acquires` 声明  
C. `move_to` 需要 `acquires` 声明  
D. 代码有错误，无法编译

**答案：** A

---

## 计分说明

- 前 10 题每题 5 分，共 50 分
- 第 11 题附加题 10 分
- **及格分数**：35 分（70%）
- **优秀分数**：45 分（90%）

---

**建议完成时间**：30 分钟

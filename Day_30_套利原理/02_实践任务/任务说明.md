# Day 30 å®è·µä»»åŠ¡ï¼šå¥—åˆ©åŸç†

## ğŸ“‹ ä»»åŠ¡æ¦‚è¿°

ä»Šå¤©çš„å®è·µä»»åŠ¡å°†å¸®åŠ©ä½ æ„å»ºä¸€ä¸ªå®Œæ•´çš„å¥—åˆ©æœºä¼šæ‰«æå’Œè¯„ä¼°ç³»ç»Ÿã€‚é€šè¿‡è¿™äº›ä»»åŠ¡ï¼Œä½ å°†å­¦ä¼šå¦‚ä½•å®æ—¶å‘ç°å¥—åˆ©æœºä¼šã€è®¡ç®—é¢„æœŸæ”¶ç›Šï¼Œå¹¶è¯„ä¼°é£é™©ã€‚

**æ€»æ—¶é—´**: 3å°æ—¶  
**éš¾åº¦**: â­â­â­â­ (ä¸­é«˜çº§)

---

## ğŸ¯ ä»»åŠ¡åˆ—è¡¨

### ä»»åŠ¡ä¸€ï¼šä»·æ ¼æ‰«æå™¨ï¼ˆ60åˆ†é’Ÿï¼‰â­â­â­â­

**ç›®æ ‡**: å®ç°ä¸€ä¸ªå¤š DEX ä»·æ ¼æ‰«æç³»ç»Ÿ

**è¦æ±‚**:
1. æŸ¥è¯¢å¤šä¸ª DEX çš„ä»·æ ¼
2. æ”¯æŒå¤šä¸ªäº¤æ˜“å¯¹
3. å®æ—¶æ›´æ–°ä»·æ ¼æ•°æ®
4. æ£€æµ‹ä»·æ ¼å¼‚å¸¸

**å®ç°æ­¥éª¤**:

#### Step 1: åŸºç¡€ä»·æ ¼æŸ¥è¯¢å™¨ï¼ˆ25åˆ†é’Ÿï¼‰

```typescript
// src/price-scanner.ts

import { AptosClient } from 'aptos';

interface Price {
  dex: string;
  pair: string;
  price: number;
  reserve0: number;
  reserve1: number;
  liquidity: number;
  timestamp: number;
}

interface DEXConfig {
  name: string;
  poolAddress: string;
  getPriceFunction: string;
}

class PriceScanner {
  private client: AptosClient;
  private dexes: DEXConfig[];
  private priceCache: Map<string, Price[]>;
  
  constructor(nodeUrl: string, dexes: DEXConfig[]) {
    this.client = new AptosClient(nodeUrl);
    this.dexes = dexes;
    this.priceCache = new Map();
  }
  
  // TODO: å®ç°ä»å•ä¸ª DEX æŸ¥è¯¢ä»·æ ¼
  async fetchPriceFromDEX(dex: DEXConfig, pair: string): Promise<Price> {
    // 1. è°ƒç”¨ DEX çš„æŸ¥è¯¢å‡½æ•°
    // 2. è§£æè¿”å›çš„å‚¨å¤‡é‡
    // 3. è®¡ç®—ä»·æ ¼ = reserve1 / reserve0
    // 4. è¿”å›ä»·æ ¼å¯¹è±¡
    
    throw new Error('Not implemented');
  }
  
  // TODO: å®ç°æ‰«ææ‰€æœ‰ DEX
  async scanPrices(pair: string): Promise<Price[]> {
    // 1. å¹¶è¡ŒæŸ¥è¯¢æ‰€æœ‰ DEX
    // 2. è¿‡æ»¤æ— æ•ˆæ•°æ®
    // 3. æ›´æ–°ç¼“å­˜
    // 4. è¿”å›ä»·æ ¼åˆ—è¡¨
    
    throw new Error('Not implemented');
  }
  
  // TODO: å®ç°ä»·æ ¼æ¯”è¾ƒ
  findPriceDifference(prices: Price[]): {
    highestPrice: Price;
    lowestPrice: Price;
    difference: number;
    percentDiff: number;
  } | null {
    // 1. æ‰¾åˆ°æœ€é«˜ä»·å’Œæœ€ä½ä»·
    // 2. è®¡ç®—å·®å€¼å’Œç™¾åˆ†æ¯”
    // 3. è¿”å›ç»“æœ
    
    throw new Error('Not implemented');
  }
}

// ä½¿ç”¨ç¤ºä¾‹
const scanner = new PriceScanner(
  'https://fullnode.testnet.aptoslabs.com/v1',
  [
    { name: 'Liquidswap', poolAddress: '0x...', getPriceFunction: 'get_reserves' },
    { name: 'PancakeSwap', poolAddress: '0x...', getPriceFunction: 'get_reserves' },
  ]
);

const prices = await scanner.scanPrices('APT/USDC');
const diff = scanner.findPriceDifference(prices);

if (diff && diff.percentDiff > 0.5) {
  console.log('Found arbitrage opportunity!', diff);
}
```

**ä»»åŠ¡è¦æ±‚**:
- âœ… å®ç° `fetchPriceFromDEX` æ–¹æ³•
- âœ… å®ç° `scanPrices` æ–¹æ³•
- âœ… å®ç° `findPriceDifference` æ–¹æ³•
- âœ… æ”¯æŒè‡³å°‘ 2 ä¸ª DEX
- âœ… æ·»åŠ é”™è¯¯å¤„ç†

#### Step 2: å®æ—¶ä»·æ ¼ç›‘æ§ï¼ˆ20åˆ†é’Ÿï¼‰

```typescript
class RealtimePriceMonitor extends PriceScanner {
  private monitoringPairs: Set<string>;
  private updateInterval: number;
  private callbacks: Map<string, (prices: Price[]) => void>;
  
  constructor(nodeUrl: string, dexes: DEXConfig[], updateInterval: number = 3000) {
    super(nodeUrl, dexes);
    this.monitoringPairs = new Set();
    this.updateInterval = updateInterval;
    this.callbacks = new Map();
  }
  
  // TODO: å¼€å§‹ç›‘æ§äº¤æ˜“å¯¹
  startMonitoring(pair: string, callback: (prices: Price[]) => void): void {
    // 1. æ·»åŠ åˆ°ç›‘æ§åˆ—è¡¨
    // 2. æ³¨å†Œå›è°ƒå‡½æ•°
    // 3. å¯åŠ¨å®šæ—¶æ›´æ–°
    
    throw new Error('Not implemented');
  }
  
  // TODO: åœæ­¢ç›‘æ§
  stopMonitoring(pair: string): void {
    // å®ç°åœæ­¢ç›‘æ§é€»è¾‘
    
    throw new Error('Not implemented');
  }
  
  // TODO: è‡ªåŠ¨æ›´æ–°ä»·æ ¼
  private async updatePrices(): Promise<void> {
    // 1. éå†æ‰€æœ‰ç›‘æ§çš„äº¤æ˜“å¯¹
    // 2. æŸ¥è¯¢æœ€æ–°ä»·æ ¼
    // 3. è°ƒç”¨å›è°ƒå‡½æ•°
    
    throw new Error('Not implemented');
  }
}

// ä½¿ç”¨ç¤ºä¾‹
const monitor = new RealtimePriceMonitor(
  'https://fullnode.testnet.aptoslabs.com/v1',
  dexConfigs,
  3000 // æ¯ 3 ç§’æ›´æ–°ä¸€æ¬¡
);

monitor.startMonitoring('APT/USDC', (prices) => {
  const diff = monitor.findPriceDifference(prices);
  if (diff && diff.percentDiff > 0.5) {
    console.log('New opportunity:', diff);
  }
});
```

**ä»»åŠ¡è¦æ±‚**:
- âœ… å®ç° `startMonitoring` æ–¹æ³•
- âœ… å®ç° `stopMonitoring` æ–¹æ³•
- âœ… å®ç°è‡ªåŠ¨æ›´æ–°æœºåˆ¶
- âœ… æ”¯æŒå¤šä¸ªäº¤æ˜“å¯¹åŒæ—¶ç›‘æ§
- âœ… æ·»åŠ æ€§èƒ½ä¼˜åŒ–ï¼ˆç¼“å­˜ã€æ‰¹é‡æŸ¥è¯¢ç­‰ï¼‰

#### Step 3: ä»·æ ¼å¼‚å¸¸æ£€æµ‹ï¼ˆ15åˆ†é’Ÿï¼‰

```typescript
class PriceAnomalyDetector {
  private historicalPrices: Map<string, number[]>;
  private maxHistorySize: number;
  
  constructor(maxHistorySize: number = 100) {
    this.historicalPrices = new Map();
    this.maxHistorySize = maxHistorySize;
  }
  
  // TODO: æ·»åŠ ä»·æ ¼å†å²
  addPrice(pair: string, price: number): void {
    // å®ç°æ·»åŠ å†å²ä»·æ ¼é€»è¾‘
    throw new Error('Not implemented');
  }
  
  // TODO: æ£€æµ‹å¼‚å¸¸ä»·æ ¼
  isAnomaly(pair: string, currentPrice: number): {
    isAnomaly: boolean;
    reason: string;
    deviationPercent: number;
  } {
    // 1. è®¡ç®—å†å²å¹³å‡ä»·æ ¼
    // 2. è®¡ç®—æ ‡å‡†å·®
    // 3. åˆ¤æ–­å½“å‰ä»·æ ¼æ˜¯å¦åç¦»è¿‡å¤§
    // 4. è¿”å›æ£€æµ‹ç»“æœ
    
    throw new Error('Not implemented');
  }
  
  // TODO: è®¡ç®—ä»·æ ¼ç»Ÿè®¡æ•°æ®
  getPriceStats(pair: string): {
    mean: number;
    stdDev: number;
    min: number;
    max: number;
  } | null {
    // å®ç°ç»Ÿè®¡è®¡ç®—
    throw new Error('Not implemented');
  }
}
```

**ä»»åŠ¡è¦æ±‚**:
- âœ… å®ç°ä»·æ ¼å†å²ç®¡ç†
- âœ… å®ç°å¼‚å¸¸æ£€æµ‹ç®—æ³•
- âœ… è®¡ç®—ç»Ÿè®¡æŒ‡æ ‡ï¼ˆå‡å€¼ã€æ ‡å‡†å·®ç­‰ï¼‰
- âœ… è®¾ç½®åˆç†çš„å¼‚å¸¸é˜ˆå€¼

---

### ä»»åŠ¡äºŒï¼šå¥—åˆ©è®¡ç®—å™¨ï¼ˆ60åˆ†é’Ÿï¼‰â­â­â­â­

**ç›®æ ‡**: å®ç°å¥—åˆ©æœºä¼šçš„ç²¾ç¡®è®¡ç®—å’Œè¯„ä¼°

#### Step 1: ç®€å•å¥—åˆ©è®¡ç®—ï¼ˆ25åˆ†é’Ÿï¼‰

```typescript
// src/arbitrage-calculator.ts

interface ArbitrageOpportunity {
  type: 'simple' | 'triangular';
  buyDex: string;
  sellDex: string;
  pair: string;
  buyPrice: number;
  sellPrice: number;
  amount: number;
  grossProfit: number;
  costs: {
    gas: number;
    slippage: number;
    fees: number;
    total: number;
  };
  netProfit: number;
  roi: number;
  estimatedExecutionTime: number;
}

class SimpleArbitrageCalculator {
  private feeRate: number;
  private gasEstimate: number;
  
  constructor(feeRate: number = 0.003, gasEstimate: number = 0.5) {
    this.feeRate = feeRate; // 0.3% é»˜è®¤æ‰‹ç»­è´¹
    this.gasEstimate = gasEstimate; // USDC
  }
  
  // TODO: è®¡ç®—å¥—åˆ©æ”¶ç›Š
  calculateProfit(
    buyPrice: number,
    sellPrice: number,
    amount: number,
    buyLiquidity: number,
    sellLiquidity: number
  ): ArbitrageOpportunity | null {
    // 1. è®¡ç®—ä¹°å…¥æˆæœ¬ï¼ˆå«æ‰‹ç»­è´¹å’Œæ»‘ç‚¹ï¼‰
    // 2. è®¡ç®—å–å‡ºæ”¶å…¥ï¼ˆæ‰£é™¤æ‰‹ç»­è´¹å’Œæ»‘ç‚¹ï¼‰
    // 3. è®¡ç®— Gas æˆæœ¬
    // 4. è®¡ç®—å‡€åˆ©æ¶¦
    // 5. åˆ¤æ–­æ˜¯å¦æœ‰åˆ©å¯å›¾
    
    throw new Error('Not implemented');
  }
  
  // TODO: è®¡ç®—æ»‘ç‚¹
  private calculateSlippage(
    amount: number,
    reserveIn: number,
    reserveOut: number
  ): number {
    // ä½¿ç”¨æ’å®šä¹˜ç§¯å…¬å¼è®¡ç®—æ»‘ç‚¹
    // Î”y = y - (x * y) / (x + Î”x)
    // æ»‘ç‚¹ = é¢„æœŸè¾“å‡º - å®é™…è¾“å‡º
    
    throw new Error('Not implemented');
  }
  
  // TODO: è®¡ç®—æœ€ä¼˜äº¤æ˜“é‡
  findOptimalAmount(
    priceDiff: number,
    buyLiquidity: number,
    sellLiquidity: number,
    maxAmount: number
  ): number {
    // 1. éå†å¯èƒ½çš„äº¤æ˜“é‡
    // 2. è®¡ç®—æ¯ä¸ªäº¤æ˜“é‡çš„å‡€åˆ©æ¶¦
    // 3. æ‰¾åˆ°åˆ©æ¶¦æœ€å¤§çš„äº¤æ˜“é‡
    
    throw new Error('Not implemented');
  }
}

// ä½¿ç”¨ç¤ºä¾‹
const calculator = new SimpleArbitrageCalculator(0.003, 0.5);

const opportunity = calculator.calculateProfit(
  10.0,   // ä¹°å…¥ä»·
  10.5,   // å–å‡ºä»·
  1000,   // æ•°é‡
  100000, // ä¹°å…¥æ± æµåŠ¨æ€§
  80000   // å–å‡ºæ± æµåŠ¨æ€§
);

if (opportunity && opportunity.netProfit > 5) {
  console.log('Profitable opportunity:', opportunity);
  console.log(`ROI: ${opportunity.roi.toFixed(2)}%`);
}
```

**ä»»åŠ¡è¦æ±‚**:
- âœ… å®ç° `calculateProfit` æ–¹æ³•
- âœ… å®ç°æ»‘ç‚¹è®¡ç®—
- âœ… å®ç°æœ€ä¼˜äº¤æ˜“é‡è®¡ç®—
- âœ… è€ƒè™‘æ‰€æœ‰æˆæœ¬å› ç´ 
- âœ… æ·»åŠ è¾“å…¥éªŒè¯

#### Step 2: ä¸‰è§’å¥—åˆ©è®¡ç®—ï¼ˆ25åˆ†é’Ÿï¼‰

```typescript
interface TriangularPath {
  tokens: [string, string, string]; // [A, B, C]
  rates: [number, number, number];  // [Aâ†’B, Bâ†’C, Câ†’A]
  dexes: [string, string, string];  // ä½¿ç”¨çš„ DEX
  startAmount: number;
  endAmount: number;
  profit: number;
  profitRate: number;
}

class TriangularArbitrageCalculator {
  private feeRate: number;
  
  constructor(feeRate: number = 0.003) {
    this.feeRate = feeRate;
  }
  
  // TODO: æŸ¥æ‰¾ä¸‰è§’å¥—åˆ©è·¯å¾„
  findTriangularPaths(
    tokens: string[],
    prices: Map<string, Map<string, number>>
  ): TriangularPath[] {
    const paths: TriangularPath[] = [];
    
    // 1. éå†æ‰€æœ‰å¯èƒ½çš„ä¸‰ä»£å¸ç»„åˆ
    // 2. æ£€æŸ¥æ˜¯å¦å­˜åœ¨å®Œæ•´è·¯å¾„
    // 3. è®¡ç®—æ±‡ç‡ä¹˜ç§¯
    // 4. å¦‚æœä¹˜ç§¯ > 1ï¼Œåˆ™æœ‰å¥—åˆ©æœºä¼š
    
    throw new Error('Not implemented');
  }
  
  // TODO: è®¡ç®—ä¸‰è§’å¥—åˆ©æ”¶ç›Š
  calculateTriangularProfit(
    startAmount: number,
    rates: [number, number, number]
  ): {
    endAmount: number;
    profit: number;
    profitRate: number;
  } {
    // 1. æ¨¡æ‹Ÿä¸‰æ­¥äº¤æ˜“
    // 2. æ¯æ­¥æ‰£é™¤æ‰‹ç»­è´¹
    // 3. è®¡ç®—æœ€ç»ˆé‡‘é¢
    // 4. è®¡ç®—åˆ©æ¶¦ç‡
    
    throw new Error('Not implemented');
  }
  
  // TODO: éªŒè¯è·¯å¾„å¯è¡Œæ€§
  validatePath(path: TriangularPath): {
    isValid: boolean;
    reason?: string;
  } {
    // æ£€æŸ¥ï¼š
    // 1. åˆ©æ¶¦ç‡æ˜¯å¦è¶³å¤Ÿ
    // 2. æµåŠ¨æ€§æ˜¯å¦å……è¶³
    // 3. è·¯å¾„æ˜¯å¦æœ‰æ•ˆ
    
    throw new Error('Not implemented');
  }
}

// ä½¿ç”¨ç¤ºä¾‹
const triCalculator = new TriangularArbitrageCalculator(0.003);

const prices = new Map([
  ['APT', new Map([['USDC', 10.0], ['BTC', 0.000285]])],
  ['USDC', new Map([['BTC', 0.00003], ['APT', 0.1]])],
  ['BTC', new Map([['APT', 3500], ['USDC', 35000]])],
]);

const paths = triCalculator.findTriangularPaths(
  ['APT', 'USDC', 'BTC'],
  prices
);

paths.forEach(path => {
  console.log(`Path: ${path.tokens.join(' â†’ ')}`);
  console.log(`Profit Rate: ${path.profitRate.toFixed(2)}%`);
});
```

**ä»»åŠ¡è¦æ±‚**:
- âœ… å®ç°è·¯å¾„æœç´¢ç®—æ³•
- âœ… å®ç°æ”¶ç›Šè®¡ç®—
- âœ… å®ç°è·¯å¾„éªŒè¯
- âœ… ä¼˜åŒ–æœç´¢æ€§èƒ½
- âœ… æ”¯æŒåŠ¨æ€æ·»åŠ ä»£å¸

#### Step 3: é£é™©è¯„ä¼°ï¼ˆ10åˆ†é’Ÿï¼‰

```typescript
interface RiskAssessment {
  marketRisk: number;      // 0-100
  liquidityRisk: number;   // 0-100
  executionRisk: number;   // 0-100
  overallRisk: number;     // 0-100
  riskLevel: 'low' | 'medium' | 'high' | 'extreme';
}

class RiskCalculator {
  // TODO: è¯„ä¼°å¸‚åœºé£é™©
  assessMarketRisk(priceVolatility: number): number {
    // åŸºäºä»·æ ¼æ³¢åŠ¨æ€§è¯„ä¼°é£é™©
    throw new Error('Not implemented');
  }
  
  // TODO: è¯„ä¼°æµåŠ¨æ€§é£é™©
  assessLiquidityRisk(tradeAmount: number, liquidity: number): number {
    // åŸºäºäº¤æ˜“é‡å æµåŠ¨æ€§æ¯”ä¾‹è¯„ä¼°é£é™©
    throw new Error('Not implemented');
  }
  
  // TODO: è¯„ä¼°æ‰§è¡Œé£é™©
  assessExecutionRisk(gasPrice: number, networkCongestion: number): number {
    // åŸºäº Gas ä»·æ ¼å’Œç½‘ç»œçŠ¶å†µè¯„ä¼°é£é™©
    throw new Error('Not implemented');
  }
  
  // TODO: ç»¼åˆé£é™©è¯„ä¼°
  assessOverallRisk(
    opportunity: ArbitrageOpportunity,
    marketConditions: any
  ): RiskAssessment {
    // ç»¼åˆè¯„ä¼°æ‰€æœ‰é£é™©å› ç´ 
    throw new Error('Not implemented');
  }
}
```

---

### ä»»åŠ¡ä¸‰ï¼šæœºä¼šç›‘æ§å™¨ï¼ˆ45åˆ†é’Ÿï¼‰â­â­â­â­

**ç›®æ ‡**: æ„å»ºå®æ—¶å¥—åˆ©æœºä¼šç›‘æ§å’Œå‘Šè­¦ç³»ç»Ÿ

#### Step 1: æœºä¼šæ‰«æå™¨ï¼ˆ30åˆ†é’Ÿï¼‰

```typescript
// src/opportunity-monitor.ts

interface MonitorConfig {
  minProfitUSD: number;
  minProfitPercent: number;
  maxRiskScore: number;
  updateInterval: number;
  pairs: string[];
}

class OpportunityMonitor {
  private scanner: RealtimePriceMonitor;
  private calculator: SimpleArbitrageCalculator;
  private triCalculator: TriangularArbitrageCalculator;
  private riskCalculator: RiskCalculator;
  private config: MonitorConfig;
  private opportunities: Map<string, ArbitrageOpportunity>;
  
  constructor(
    scanner: RealtimePriceMonitor,
    config: MonitorConfig
  ) {
    this.scanner = scanner;
    this.calculator = new SimpleArbitrageCalculator();
    this.triCalculator = new TriangularArbitrageCalculator();
    this.riskCalculator = new RiskCalculator();
    this.config = config;
    this.opportunities = new Map();
  }
  
  // TODO: å¼€å§‹ç›‘æ§
  start(): void {
    // 1. å¯åŠ¨ä»·æ ¼æ‰«æ
    // 2. æ³¨å†Œæœºä¼šæ£€æµ‹å›è°ƒ
    // 3. å¯åŠ¨å®šæ—¶æŠ¥å‘Š
    
    throw new Error('Not implemented');
  }
  
  // TODO: æ£€æµ‹ç®€å•å¥—åˆ©æœºä¼š
  private detectSimpleArbitrage(prices: Price[]): ArbitrageOpportunity[] {
    // 1. æ‰¾å‡ºä»·æ ¼å·®å¼‚
    // 2. è®¡ç®—å¥—åˆ©æ”¶ç›Š
    // 3. è¯„ä¼°é£é™©
    // 4. è¿‡æ»¤ä¸ç¬¦åˆæ¡ä»¶çš„æœºä¼š
    
    throw new Error('Not implemented');
  }
  
  // TODO: æ£€æµ‹ä¸‰è§’å¥—åˆ©æœºä¼š
  private detectTriangularArbitrage(
    allPrices: Map<string, Price[]>
  ): TriangularPath[] {
    // 1. æ„å»ºä»·æ ¼å›¾
    // 2. æœç´¢å¥—åˆ©è·¯å¾„
    // 3. è®¡ç®—æ”¶ç›Š
    // 4. è¿‡æ»¤æœºä¼š
    
    throw new Error('Not implemented');
  }
  
  // TODO: å‘é€å‘Šè­¦
  private sendAlert(opportunity: ArbitrageOpportunity): void {
    // 1. æ ¼å¼åŒ–æœºä¼šä¿¡æ¯
    // 2. å‘é€é€šçŸ¥ï¼ˆæ§åˆ¶å°ã€Webhookã€é‚®ä»¶ç­‰ï¼‰
    
    console.log('ğŸš¨ ARBITRAGE OPPORTUNITY DETECTED!');
    console.log(JSON.stringify(opportunity, null, 2));
  }
}

// ä½¿ç”¨ç¤ºä¾‹
const monitor = new OpportunityMonitor(scanner, {
  minProfitUSD: 10,
  minProfitPercent: 0.5,
  maxRiskScore: 70,
  updateInterval: 3000,
  pairs: ['APT/USDC', 'BTC/USDC', 'ETH/USDC']
});

monitor.start();
```

**ä»»åŠ¡è¦æ±‚**:
- âœ… å®ç°ç›‘æ§ä¸»å¾ªç¯
- âœ… å®ç°ç®€å•å¥—åˆ©æ£€æµ‹
- âœ… å®ç°ä¸‰è§’å¥—åˆ©æ£€æµ‹
- âœ… å®ç°å‘Šè­¦æœºåˆ¶
- âœ… æ·»åŠ æ—¥å¿—è®°å½•

#### Step 2: ç»Ÿè®¡å’ŒæŠ¥å‘Šï¼ˆ15åˆ†é’Ÿï¼‰

```typescript
interface OpportunityStats {
  totalOpportunities: number;
  simpleArb: number;
  triangularArb: number;
  avgProfit: number;
  maxProfit: number;
  avgRisk: number;
}

class StatsCollector {
  private opportunities: ArbitrageOpportunity[];
  
  // TODO: æ”¶é›†ç»Ÿè®¡æ•°æ®
  collectStats(): OpportunityStats {
    // è®¡ç®—å„ç§ç»Ÿè®¡æŒ‡æ ‡
    throw new Error('Not implemented');
  }
  
  // TODO: ç”ŸæˆæŠ¥å‘Š
  generateReport(): string {
    // ç”Ÿæˆæ ¼å¼åŒ–çš„æŠ¥å‘Š
    throw new Error('Not implemented');
  }
  
  // TODO: å¯¼å‡ºæ•°æ®
  exportToCSV(filename: string): void {
    // å¯¼å‡ºä¸º CSV æ–‡ä»¶
    throw new Error('Not implemented');
  }
}
```

---

### ä»»åŠ¡å››ï¼šæ”¶ç›Šæ¨¡æ‹Ÿå™¨ï¼ˆ15åˆ†é’Ÿï¼‰â­â­â­

**ç›®æ ‡**: ä½¿ç”¨å†å²æ•°æ®æ¨¡æ‹Ÿå¥—åˆ©ç­–ç•¥æ”¶ç›Š

```typescript
// src/profit-simulator.ts

interface SimulationConfig {
  initialCapital: number;
  strategy: 'simple' | 'triangular' | 'both';
  minProfit: number;
  riskTolerance: number;
}

interface SimulationResult {
  trades: number;
  successfulTrades: number;
  totalProfit: number;
  totalLoss: number;
  netProfit: number;
  roi: number;
  sharpeRatio: number;
  maxDrawdown: number;
}

class ProfitSimulator {
  private config: SimulationConfig;
  private historicalData: any[];
  
  constructor(config: SimulationConfig) {
    this.config = config;
    this.historicalData = [];
  }
  
  // TODO: åŠ è½½å†å²æ•°æ®
  loadHistoricalData(filename: string): void {
    // ä»æ–‡ä»¶åŠ è½½å†å²ä»·æ ¼æ•°æ®
    throw new Error('Not implemented');
  }
  
  // TODO: è¿è¡Œæ¨¡æ‹Ÿ
  runSimulation(): SimulationResult {
    // 1. éå†å†å²æ•°æ®
    // 2. æ£€æµ‹å¥—åˆ©æœºä¼š
    // 3. æ¨¡æ‹Ÿæ‰§è¡Œ
    // 4. è®°å½•æ”¶ç›Š/æŸå¤±
    // 5. è®¡ç®—ç»Ÿè®¡æŒ‡æ ‡
    
    throw new Error('Not implemented');
  }
  
  // TODO: è®¡ç®—å¤æ™®æ¯”ç‡
  private calculateSharpeRatio(returns: number[]): number {
    // è®¡ç®—é£é™©è°ƒæ•´åæ”¶ç›Š
    throw new Error('Not implemented');
  }
  
  // TODO: è®¡ç®—æœ€å¤§å›æ’¤
  private calculateMaxDrawdown(equityCurve: number[]): number {
    // è®¡ç®—æœ€å¤§èµ„é‡‘å›æ’¤
    throw new Error('Not implemented');
  }
}

// ä½¿ç”¨ç¤ºä¾‹
const simulator = new ProfitSimulator({
  initialCapital: 10000,
  strategy: 'both',
  minProfit: 5,
  riskTolerance: 0.7
});

simulator.loadHistoricalData('price_history.csv');
const result = simulator.runSimulation();

console.log('Simulation Results:');
console.log(`Total Trades: ${result.trades}`);
console.log(`Success Rate: ${(result.successfulTrades / result.trades * 100).toFixed(2)}%`);
console.log(`Net Profit: $${result.netProfit.toFixed(2)}`);
console.log(`ROI: ${result.roi.toFixed(2)}%`);
console.log(`Sharpe Ratio: ${result.sharpeRatio.toFixed(2)}`);
console.log(`Max Drawdown: ${result.maxDrawdown.toFixed(2)}%`);
```

**ä»»åŠ¡è¦æ±‚**:
- âœ… å®ç°å†å²æ•°æ®åŠ è½½
- âœ… å®ç°æ¨¡æ‹Ÿæ‰§è¡Œé€»è¾‘
- âœ… è®¡ç®—æ€§èƒ½æŒ‡æ ‡
- âœ… ç”Ÿæˆå¯è§†åŒ–æŠ¥å‘Š

---

## ğŸ“Š éªŒæ”¶æ ‡å‡†

### åŸºç¡€è¦æ±‚ï¼ˆå¿…é¡»å®Œæˆï¼‰
- [ ] ä»·æ ¼æ‰«æå™¨èƒ½æ­£ç¡®æŸ¥è¯¢å¤šä¸ª DEX
- [ ] å¥—åˆ©è®¡ç®—å™¨èƒ½å‡†ç¡®è®¡ç®—æ”¶ç›Š
- [ ] æœºä¼šç›‘æ§å™¨èƒ½å®æ—¶æ£€æµ‹æœºä¼š
- [ ] æ‰€æœ‰ä»£ç éƒ½æœ‰é€‚å½“çš„é”™è¯¯å¤„ç†

### è¿›é˜¶è¦æ±‚ï¼ˆå¯é€‰ï¼‰
- [ ] å®ç°ä¸‰è§’å¥—åˆ©è·¯å¾„æœç´¢
- [ ] æ·»åŠ é£é™©è¯„ä¼°åŠŸèƒ½
- [ ] å®ç°æ”¶ç›Šæ¨¡æ‹Ÿå™¨
- [ ] æ·»åŠ æ•°æ®å¯è§†åŒ–

### ä¼˜ç§€æ ‡å‡†
- [ ] æ€§èƒ½ä¼˜åŒ–ï¼ˆç¼“å­˜ã€æ‰¹é‡æŸ¥è¯¢ç­‰ï¼‰
- [ ] å®Œå–„çš„æ—¥å¿—å’Œç›‘æ§
- [ ] å•å…ƒæµ‹è¯•è¦†ç›–ç‡ > 80%
- [ ] è¯¦ç»†çš„æ–‡æ¡£å’Œæ³¨é‡Š

---

## ğŸ§ª æµ‹è¯•å»ºè®®

### å•å…ƒæµ‹è¯•

```typescript
describe('SimpleArbitrageCalculator', () => {
  test('should calculate profit correctly', () => {
    const calc = new SimpleArbitrageCalculator();
    const result = calc.calculateProfit(10, 10.5, 1000, 100000, 100000);
    
    expect(result).not.toBeNull();
    expect(result!.netProfit).toBeGreaterThan(0);
  });
  
  test('should return null for unprofitable opportunity', () => {
    const calc = new SimpleArbitrageCalculator();
    const result = calc.calculateProfit(10, 10.01, 1000, 100000, 100000);
    
    expect(result).toBeNull();
  });
});
```

### é›†æˆæµ‹è¯•

```typescript
describe('OpportunityMonitor Integration', () => {
  test('should detect real arbitrage opportunities', async () => {
    const monitor = new OpportunityMonitor(scanner, config);
    
    const opportunities = await monitor.scan();
    
    expect(opportunities.length).toBeGreaterThanOrEqual(0);
    opportunities.forEach(opp => {
      expect(opp.netProfit).toBeGreaterThan(config.minProfitUSD);
    });
  });
});
```

---

## ğŸ’¡ æç¤ºå’ŒæŠ€å·§

### æ€§èƒ½ä¼˜åŒ–
```typescript
// ä½¿ç”¨ç¼“å­˜å‡å°‘é‡å¤æŸ¥è¯¢
const cache = new Map<string, {data: any, timestamp: number}>();

function getCachedData(key: string, ttl: number): any | null {
  const cached = cache.get(key);
  if (cached && Date.now() - cached.timestamp < ttl) {
    return cached.data;
  }
  return null;
}
```

### é”™è¯¯å¤„ç†
```typescript
async function safeQuery<T>(
  fn: () => Promise<T>,
  fallback: T,
  retries: number = 3
): Promise<T> {
  for (let i = 0; i < retries; i++) {
    try {
      return await fn();
    } catch (error) {
      if (i === retries - 1) {
        console.error('Max retries reached:', error);
        return fallback;
      }
      await sleep(1000 * (i + 1)); // æŒ‡æ•°é€€é¿
    }
  }
  return fallback;
}
```

### å¹¶å‘æ§åˆ¶
```typescript
// ä½¿ç”¨ Promise.allSettled å¤„ç†æ‰¹é‡æŸ¥è¯¢
const results = await Promise.allSettled(
  dexes.map(dex => fetchPriceFromDEX(dex, pair))
);

const successfulResults = results
  .filter(r => r.status === 'fulfilled')
  .map(r => (r as PromiseFulfilledResult<Price>).value);
```

---

## ğŸ“ æäº¤è¦æ±‚

å®Œæˆä»»åŠ¡åï¼Œè¯·æäº¤ï¼š

1. **æºä»£ç **
   - æ‰€æœ‰ TypeScript æ–‡ä»¶
   - é…ç½®æ–‡ä»¶
   - README.md

2. **æµ‹è¯•ç»“æœ**
   - å•å…ƒæµ‹è¯•æŠ¥å‘Š
   - å®é™…è¿è¡Œæˆªå›¾
   - å‘ç°çš„å¥—åˆ©æœºä¼šç¤ºä¾‹

3. **æ€§èƒ½åˆ†æ**
   - æŸ¥è¯¢å»¶è¿Ÿç»Ÿè®¡
   - å†…å­˜ä½¿ç”¨æƒ…å†µ
   - ä¼˜åŒ–å»ºè®®

4. **å­¦ä¹ æ€»ç»“**
   - é‡åˆ°çš„é—®é¢˜å’Œè§£å†³æ–¹æ¡ˆ
   - å¯¹å¥—åˆ©åŸç†çš„ç†è§£
   - ä¸‹ä¸€æ­¥æ”¹è¿›è®¡åˆ’

---

## ğŸ“ å­¦ä¹ èµ„æº

- [Aptos TypeScript SDK](https://aptos.dev/sdks/ts-sdk)
- [DEX ä»·æ ¼æŸ¥è¯¢æ•™ç¨‹](https://docs.liquidswap.com/)
- [å¥—åˆ©ç®—æ³•å®ç°](https://github.com/)

---

**ç¥ä½ å®Œæˆä»»åŠ¡ï¼è®°ä½ï¼šå…ˆç†è§£åŸç†ï¼Œå†ä¼˜åŒ–æ€§èƒ½ã€‚ğŸš€**

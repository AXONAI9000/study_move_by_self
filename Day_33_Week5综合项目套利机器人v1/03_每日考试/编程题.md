# Day 33 每日考试 - 编程题

**考试时间**: 60 分钟  
**题目数量**: 3 题  
**总分**: 100 分

---

## 编程题 1：实现价格差异检测器（30分）

### 题目描述

实现一个价格差异检测器，能够识别两个 DEX 之间的套利机会。

### 要求

在 TypeScript 中实现 `ArbitrageDetector` 类：

```typescript
interface PriceData {
  dex: string;
  pair: string;
  price: number;
  liquidity: number;
}

interface Opportunity {
  buy_dex: string;
  sell_dex: string;
  pair: string;
  price_diff_percent: number;
  estimated_profit: number;
}

class ArbitrageDetector {
  private minProfitPercent: number;

  constructor(minProfitPercent: number = 0.5) {
    this.minProfitPercent = minProfitPercent;
  }

  /**
   * 检测套利机会
   * @param prices - 各 DEX 的价格数据
   * @returns 套利机会列表，按利润降序排列
   */
  detectOpportunities(prices: PriceData[]): Opportunity[] {
    // TODO: 实现你的代码
  }

  /**
   * 计算最优交易量
   * @param buyPrice - 买入价格
   * @param sellPrice - 卖出价格
   * @param liquidity - 可用流动性
   * @returns 最优交易量
   */
  private calculateOptimalAmount(
    buyPrice: number,
    sellPrice: number,
    liquidity: number
  ): number {
    // TODO: 实现你的代码
  }
}
```

### 测试用例

```typescript
const detector = new ArbitrageDetector(0.5);

const prices: PriceData[] = [
  { dex: 'PancakeSwap', pair: 'APT/USDC', price: 10.0, liquidity: 100000 },
  { dex: 'LiquidSwap', pair: 'APT/USDC', price: 10.5, liquidity: 80000 },
  { dex: 'Aries', pair: 'APT/USDC', price: 10.2, liquidity: 120000 },
];

const opportunities = detector.detectOpportunities(prices);

console.log(opportunities);
// 期望输出：
// [
//   {
//     buy_dex: 'PancakeSwap',
//     sell_dex: 'LiquidSwap',
//     pair: 'APT/USDC',
//     price_diff_percent: 5.0,
//     estimated_profit: 2400  // 假设最优交易量为 5000
//   },
//   // ...
// ]
```

### 评分标准

- 正确识别所有套利机会（10分）
- 准确计算价差百分比（5分）
- 合理估算最优交易量（10分）
- 准确计算预估利润（5分）

---

## 编程题 2：实现闪电贷套利合约（40分）

### 题目描述

在 Move 中实现一个完整的闪电贷套利模块。

### 要求

```move
module your_address::flashloan_arbitrage {
    use std::signer;
    use aptos_framework::coin::{Self, Coin};
    
    /// TODO 1: 定义必要的结构体
    /// 要求：
    /// - 定义 FlashloanCallback 存储回调数据
    /// - 定义事件结构体记录执行结果
    
    /// TODO 2: 实现闪电贷套利函数
    /// 要求：
    /// - 借出指定金额的代币
    /// - 在 DEX A 买入，DEX B 卖出
    /// - 归还本金 + 费用
    /// - 提取利润
    /// - 发出事件
    public entry fun execute_flashloan_arbitrage<TokenIn, TokenOut>(
        executor: &signer,
        borrow_amount: u64,
        min_profit: u64
    ) {
        // TODO: 实现你的代码
    }
    
    /// TODO 3: 实现闪电贷回调函数
    /// 要求：
    /// - 接收借来的代币
    /// - 执行套利逻辑
    /// - 返回本金 + 费用
    fun flashloan_callback<TokenIn, TokenOut>(
        executor: &signer,
        borrowed: Coin<TokenIn>,
        callback_data: FlashloanCallback
    ): Coin<TokenIn> {
        // TODO: 实现你的代码
    }
    
    /// TODO 4: 实现费用计算
    /// 要求：
    /// - 费率为 0.09% (9/10000)
    /// - 正确处理整数除法
    fun calculate_fee(amount: u64): u64 {
        // TODO: 实现你的代码
    }
    
    /// TODO 5: 实现安全检查
    /// 要求：
    /// - 检查利润 >= min_profit
    /// - 检查归还金额足够
    /// - 使用 assert! 处理错误
}
```

### 测试要求

编写至少 3 个测试用例：
1. 测试成功的闪电贷套利
2. 测试利润不足的情况
3. 测试归还金额不足的情况

### 评分标准

- 正确实现闪电贷借出和归还（15分）
- 正确执行套利逻辑（10分）
- 准确计算费用和利润（5分）
- 完善的错误处理（5分）
- 完整的测试覆盖（5分）

---

## 编程题 3：实现智能执行引擎（30分）

### 题目描述

实现一个智能执行引擎，能够根据市场情况自动调整执行策略。

### 要求

在 TypeScript 中实现：

```typescript
interface Strategy {
  opportunity: Opportunity;
  priority: number;        // 优先级 0-100
  risk_level: 'low' | 'medium' | 'high';
  recommended_amount: number;
}

class SmartExecutor {
  private maxConcurrent: number = 3;
  private running: Set<string> = new Set();
  
  constructor(
    private client: AptosClient,
    private account: AptosAccount
  ) {}

  /**
   * TODO 1: 实现策略评估
   * 要求：
   * - 根据利润、风险、Gas 成本评分
   * - 计算执行优先级
   * - 确定推荐交易量
   */
  evaluateStrategy(opportunity: Opportunity): Strategy {
    // TODO: 实现你的代码
  }

  /**
   * TODO 2: 实现智能执行
   * 要求：
   * - 选择最优策略
   * - 控制并发数量
   * - 处理执行失败
   * - 自动重试（带指数退避）
   */
  async executeWithPriority(
    strategies: Strategy[]
  ): Promise<ExecutionResult[]> {
    // TODO: 实现你的代码
  }

  /**
   * TODO 3: 实现重试机制
   * 要求：
   * - 最多重试 3 次
   * - 指数退避: 1s, 2s, 4s
   * - 记录重试原因
   */
  private async executeWithRetry(
    strategy: Strategy,
    maxRetries: number = 3
  ): Promise<ExecutionResult> {
    // TODO: 实现你的代码
  }

  /**
   * TODO 4: 实现并发控制
   * 要求：
   * - 限制最大并发数
   * - 队列管理
   * - 资源释放
   */
  private canExecute(strategyId: string): boolean {
    // TODO: 实现你的代码
  }
}
```

### 测试场景

1. **场景一**: 多个机会同时出现，验证优先级排序
2. **场景二**: 并发执行，验证不超过最大并发数
3. **场景三**: 执行失败，验证重试机制

### 评分标准

- 正确实现策略评估（8分）
- 有效的优先级调度（8分）
- 完善的并发控制（7分）
- 健壮的重试机制（7分）

---

## 提交要求

### 代码质量
- ✅ 代码格式规范
- ✅ 有完整的注释
- ✅ 变量命名清晰
- ✅ 逻辑结构合理

### 测试要求
- ✅ 所有测试用例通过
- ✅ 覆盖边界情况
- ✅ 有错误处理测试

### 文档要求
- ✅ 说明实现思路
- ✅ 解释关键算法
- ✅ 标注时间复杂度

---

## 答案提交格式

```markdown
## 编程题 1

### 代码实现
\`\`\`typescript
// 你的代码
\`\`\`

### 测试结果
\`\`\`
// 测试输出
\`\`\`

### 实现说明
// 你的解释

---

## 编程题 2

### 代码实现
\`\`\`move
// 你的代码
\`\`\`

### 测试结果
\`\`\`
// 测试输出
\`\`\`

### 实现说明
// 你的解释

---

## 编程题 3

### 代码实现
\`\`\`typescript
// 你的代码
\`\`\`

### 测试结果
\`\`\`
// 测试输出
\`\`\`

### 实现说明
// 你的解释
```

---

**提示**: 
- 仔细阅读要求，确保满足所有条件
- 注重代码质量和可读性
- 充分测试，确保正确性
- 如有疑问，查阅前面的理论学习材料

完成后请参考《答案解析.md》查看详细答案和解析。

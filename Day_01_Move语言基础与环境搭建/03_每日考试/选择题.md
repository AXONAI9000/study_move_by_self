# Day 01 每日考试 - 选择题

**总分：50 分（每题 5 分）**  
**时间：30 分钟**

---

## 第 1 题

Move 语言最初是为哪个区块链项目开发的？

A. Ethereum  
B. Solana  
C. Libra (现在的 Diem)  
D. Aptos

**答案：** 见答案解析

---

## 第 2 题

以下哪个**不是** Move 语言的基本数据类型？

A. `u64`  
B. `string`  
C. `bool`  
D. `address`

**答案：** 见答案解析

---

## 第 3 题

在 Move 中，以下哪个整数类型的取值范围最大？

A. `u8`  
B. `u64`  
C. `u128`  
D. `u256`

**答案：** 见答案解析

---

## 第 4 题

下列代码会产生什么结果？

```move
let x: u8 = 256;
```

A. 编译通过，x 的值为 256  
B. 编译错误：值超出 u8 范围  
C. 运行时错误  
D. x 的值被截断为 0

**答案：** 见答案解析

---

## 第 5 题

在 Move 中，如何声明一个地址常量？

A. `let addr = 0x1;`  
B. `const ADDR: address = 0x1;`  
C. `let addr: address = @0x1;`  
D. `const ADDR: address = @0x1;`

**答案：** 见答案解析

---

## 第 6 题

以下关于结构体的说法，哪个是**错误**的？

A. 结构体可以有多个字段  
B. 结构体字段可以是任何类型  
C. 结构体必须至少有一个能力（ability）  
D. 结构体可以嵌套其他结构体

**答案：** 见答案解析

---

## 第 7 题

`move_to` 函数的作用是什么？

A. 将资源从一个地址移动到另一个地址  
B. 将资源存储到全局存储中  
C. 将变量的所有权转移给另一个变量  
D. 移动文件到另一个目录

**答案：** 见答案解析

---

## 第 8 题

在访问全局存储中的资源时，如果资源不存在会发生什么？

```move
public fun get_value(addr: address): u64 acquires Counter {
    borrow_global<Counter>(addr).value
}
```

A. 返回 0  
B. 返回 null  
C. 程序会 abort（中止）  
D. 返回默认值

**答案：** 见答案解析

---

## 第 9 题

以下哪个是正确的函数声明？

A. `fun add(x: u64, y: u64) -> u64 { x + y }`  
B. `public fun add(x: u64, y: u64): u64 { x + y }`  
C. `function add(x: u64, y: u64): u64 { return x + y }`  
D. `pub fn add(x: u64, y: u64) -> u64 { x + y }`

**答案：** 见答案解析

---

## 第 10 题

`acquires` 关键字的作用是什么？

A. 获取资源的所有权  
B. 声明函数会访问全局存储中的资源  
C. 请求用户授权  
D. 锁定资源防止并发访问

**答案：** 见答案解析

---

## 第 11 题

以下代码会输出什么？

```move
let mut x = 10;
let y = &mut x;
*y = 20;
```

A. x = 10, y = 20  
B. x = 20, y = 20  
C. 编译错误：Move 不支持可变变量  
D. x = 20（y 是引用）

**答案：** 见答案解析

---

## 第 12 题

在 Move 中，向量（vector）的索引从几开始？

A. 0  
B. 1  
C. 由程序员指定  
D. -1

**答案：** 见答案解析

---

## 第 13 题

以下哪个操作会导致编译错误？

```move
struct Counter has key {
    value: u64
}

public fun test(account: &signer) {
    let counter = Counter { value: 0 };
    // 选项在这里
}
```

A. `move_to(account, counter);`  
B. `let x = counter.value;`  
C. `// 函数结束，counter 自动销毁`  
D. 以上都不会报错

**答案：** 见答案解析

---

## 第 14 题

`borrow_global` 和 `borrow_global_mut` 的区别是什么？

A. 一个用于读取，一个用于写入  
B. 一个是公开的，一个是私有的  
C. 一个需要 `acquires`，一个不需要  
D. 没有区别，可以互换使用

**答案：** 见答案解析

---

## 第 15 题

以下关于 `assert!` 的说法，哪个是**正确**的？

A. `assert!` 用于打印调试信息  
B. `assert!` 条件为 false 时会中止程序执行  
C. `assert!` 只能在测试代码中使用  
D. `assert!` 的第二个参数是错误消息字符串

**答案：** 见答案解析

---

## 第 16 题（附加题，10 分）

阅读以下代码，判断哪个说法是**正确**的：

```move
module my_addr::bank {
    struct Account has key {
        balance: u64
    }
    
    public fun withdraw(account: &signer, amount: u64) acquires Account {
        let addr = signer::address_of(account);
        let acc = borrow_global_mut<Account>(addr);
        acc.balance = acc.balance - amount;
    }
}
```

A. 这段代码完全安全，没有问题  
B. 缺少余额充足性检查，可能导致下溢  
C. 缺少账户存在性检查  
D. B 和 C 都正确

**答案：** 见答案解析

---

## 计分说明

- 前 15 题每题 5 分，共 75 分
- 第 16 题附加题 10 分
- **满分**：75 分（不含附加题）
- **及格分数**：53 分（70%）
- **优秀分数**：68 分（90%）

---

## 答题说明

1. 请在独立的纸上或文档中记录你的答案
2. 完成后对照 `答案解析.md` 检查
3. 仔细阅读解析，理解每道题的考点
4. 错题要重点复习相关知识点

**建议完成时间**：30 分钟  
**实际用时**：________

---

## 知识点分布

- **语言基础**：第 1-6 题
- **全局存储**：第 7-8, 10, 14 题
- **函数与语法**：第 9, 11-12 题
- **错误处理**：第 13, 15 题
- **综合应用**：第 16 题

祝你考试顺利！🎓

# é”™è¯¯å¤„ç†ä¸æ–­è¨€æœ€ä½³å®è·µæ ¸å¿ƒæ¦‚å¿µ

## ç¬¬ä¸€éƒ¨åˆ†ï¼šMove é”™è¯¯å¤„ç†æ¦‚è¿°

### 1.1 Move çš„é”™è¯¯å¤„ç†å“²å­¦

Move é‡‡ç”¨**æ˜ç¡®å¤±è´¥**è€Œä¸æ˜¯å¼‚å¸¸å¤„ç†çš„è®¾è®¡ï¼š
- æ²¡æœ‰ try-catch æœºåˆ¶
- ä½¿ç”¨ `abort` ç»ˆæ­¢æ‰§è¡Œ
- ä½¿ç”¨ `assert!` è¿›è¡Œæ¡ä»¶æ£€æŸ¥
- é¼“åŠ±ä½¿ç”¨ `Option` å’Œè‡ªå®šä¹‰è¿”å›ç±»å‹

**ç±»æ¯”ï¼šé£æœºå®‰å…¨ç³»ç»Ÿ**
- å‘ç°é—®é¢˜ â†’ ç«‹å³ä¸­æ­¢ï¼ˆabortï¼‰
- é¢„é˜²æ€§æ£€æŸ¥ â†’ æ–­è¨€ï¼ˆassertï¼‰
- å¯æ¢å¤é”™è¯¯ â†’ è¿”å› Option

### 1.2 é”™è¯¯å¤„ç† vs å¼‚å¸¸å¤„ç†

| ç‰¹æ€§ | Move (Abort) | Java/C# (Exception) |
|------|--------------|---------------------|
| æœºåˆ¶ | ä¸­æ­¢æ‰§è¡Œ | æŠ›å‡ºå¼‚å¸¸ |
| æ¢å¤ | ä¸å¯æ¢å¤ | å¯æ•è·æ¢å¤ |
| æ€§èƒ½ | é«˜æ•ˆ | æœ‰å¼€é”€ |
| å¯é¢„æµ‹æ€§ | å¼º | å¼± |
| é€‚ç”¨åœºæ™¯ | åŒºå—é“¾ | ä¼ ç»Ÿåº”ç”¨ |

---

## ç¬¬äºŒéƒ¨åˆ†ï¼šabort å’Œ assert

### 2.1 abort è¯­å¥

**è¯­æ³•**ï¼š
```move
abort error_code
```

**åŠŸèƒ½**ï¼šç«‹å³ç»ˆæ­¢å½“å‰äº¤æ˜“çš„æ‰§è¡Œï¼Œæ‰€æœ‰çŠ¶æ€å˜æ›´éƒ½ä¼šå›æ»šã€‚

**ç¤ºä¾‹**ï¼š
```move
public fun withdraw(account: &signer, amount: u64) {
    let balance = get_balance(signer::address_of(account));
    
    if (balance < amount) {
        abort 1  // ä½™é¢ä¸è¶³ï¼Œä¸­æ­¢æ‰§è¡Œ
    };
    
    // ç»§ç»­æ‰§è¡Œ...
}
```

### 2.2 assert! å®

**è¯­æ³•**ï¼š
```move
assert!(condition, error_code);
```

**åŠŸèƒ½**ï¼šå¦‚æœæ¡ä»¶ä¸º falseï¼Œåˆ™ abortã€‚

**ç¤ºä¾‹**ï¼š
```move
public fun withdraw(account: &signer, amount: u64) {
    let balance = get_balance(signer::address_of(account));
    assert!(balance >= amount, 1);  // ç­‰ä»·äºä¸Šé¢çš„ if + abort
    
    // ç»§ç»­æ‰§è¡Œ...
}
```

### 2.3 assert ä¸ abort çš„åŒºåˆ«

```move
// ä½¿ç”¨ if + abort
if (balance < amount) {
    abort ERROR_INSUFFICIENT_BALANCE
};

// ä½¿ç”¨ assertï¼ˆæ¨èï¼‰
assert!(balance >= amount, ERROR_INSUFFICIENT_BALANCE);

// ä¸¤è€…æ•ˆæœç›¸åŒï¼Œä½† assert æ›´ç®€æ´
```

**æœ€ä½³å®è·µ**ï¼šä¼˜å…ˆä½¿ç”¨ `assert!`ï¼Œæ›´æ¸…æ™°ç®€æ´ã€‚

---

## ç¬¬ä¸‰éƒ¨åˆ†ï¼šé”™è¯¯ç è®¾è®¡

### 3.1 é”™è¯¯ç è§„èŒƒ

**åŸºæœ¬åŸåˆ™**ï¼š
1. ä½¿ç”¨å¸¸é‡ï¼Œä¸ç”¨é­”æ³•æ•°å­—
2. æ˜ç¡®çš„å‘½å
3. åˆ†ç»„ç®¡ç†
4. æ–‡æ¡£åŒ–

**ç¤ºä¾‹**ï¼š
```move
module my_addr::bank {
    // ========== é”™è¯¯ç å®šä¹‰ ==========
    
    /// è´¦æˆ·ä¸å­˜åœ¨
    const ERROR_ACCOUNT_NOT_FOUND: u64 = 1;
    
    /// ä½™é¢ä¸è¶³
    const ERROR_INSUFFICIENT_BALANCE: u64 = 2;
    
    /// è´¦æˆ·å·²å­˜åœ¨
    const ERROR_ACCOUNT_ALREADY_EXISTS: u64 = 3;
    
    /// æ— æ•ˆçš„é‡‘é¢
    const ERROR_INVALID_AMOUNT: u64 = 4;
    
    /// æƒé™ä¸è¶³
    const ERROR_PERMISSION_DENIED: u64 = 5;
    
    // ========== ä¸šåŠ¡é€»è¾‘ ==========
    
    public fun withdraw(account: &signer, amount: u64) acquires Account {
        assert!(amount > 0, ERROR_INVALID_AMOUNT);
        
        let addr = signer::address_of(account);
        assert!(exists<Account>(addr), ERROR_ACCOUNT_NOT_FOUND);
        
        let account_ref = borrow_global_mut<Account>(addr);
        assert!(account_ref.balance >= amount, ERROR_INSUFFICIENT_BALANCE);
        
        account_ref.balance = account_ref.balance - amount;
    }
}
```

### 3.2 é”™è¯¯ç åˆ†ç±»ç³»ç»Ÿ

**æ¨èåˆ†ç±»**ï¼š
```move
// 1xx: è´¦æˆ·ç›¸å…³é”™è¯¯
const ERROR_ACCOUNT_NOT_FOUND: u64 = 101;
const ERROR_ACCOUNT_ALREADY_EXISTS: u64 = 102;
const ERROR_ACCOUNT_FROZEN: u64 = 103;

// 2xx: ä½™é¢/é‡‘é¢ç›¸å…³é”™è¯¯
const ERROR_INSUFFICIENT_BALANCE: u64 = 201;
const ERROR_INVALID_AMOUNT: u64 = 202;
const ERROR_AMOUNT_TOO_LARGE: u64 = 203;

// 3xx: æƒé™ç›¸å…³é”™è¯¯
const ERROR_NOT_OWNER: u64 = 301;
const ERROR_NOT_ADMIN: u64 = 302;
const ERROR_PERMISSION_DENIED: u64 = 303;

// 4xx: çŠ¶æ€ç›¸å…³é”™è¯¯
const ERROR_PAUSED: u64 = 401;
const ERROR_NOT_INITIALIZED: u64 = 402;
const ERROR_ALREADY_INITIALIZED: u64 = 403;

// 5xx: ä¸šåŠ¡é€»è¾‘é”™è¯¯
const ERROR_INVALID_OPERATION: u64 = 501;
const ERROR_DEADLINE_PASSED: u64 = 502;
const ERROR_SLIPPAGE_TOO_HIGH: u64 = 503;
```

### 3.3 é”™è¯¯ç æ–‡æ¡£åŒ–

```move
/// # é”™è¯¯ç è¯´æ˜
///
/// ## è´¦æˆ·é”™è¯¯ (1xx)
/// - `ERROR_ACCOUNT_NOT_FOUND` (101): è´¦æˆ·ä¸å­˜åœ¨
/// - `ERROR_ACCOUNT_ALREADY_EXISTS` (102): è´¦æˆ·å·²å­˜åœ¨
/// - `ERROR_ACCOUNT_FROZEN` (103): è´¦æˆ·å·²è¢«å†»ç»“
///
/// ## ä½™é¢é”™è¯¯ (2xx)
/// - `ERROR_INSUFFICIENT_BALANCE` (201): ä½™é¢ä¸è¶³
/// - `ERROR_INVALID_AMOUNT` (202): é‡‘é¢æ— æ•ˆï¼ˆå¦‚è´Ÿæ•°æˆ–é›¶ï¼‰
///
/// ## æƒé™é”™è¯¯ (3xx)
/// - `ERROR_NOT_OWNER` (301): éèµ„æºæ‰€æœ‰è€…
/// - `ERROR_NOT_ADMIN` (302): éç®¡ç†å‘˜
module my_addr::documented_module {
    // é”™è¯¯ç å®šä¹‰...
}
```

---

## ç¬¬å››éƒ¨åˆ†ï¼šé”™è¯¯å¤„ç†æ¨¡å¼

### 4.1 æ¨¡å¼ 1ï¼šå‰ç½®æ¡ä»¶æ£€æŸ¥

åœ¨å‡½æ•°å¼€å§‹æ—¶æ£€æŸ¥æ‰€æœ‰å‰ç½®æ¡ä»¶ï¼š

```move
public fun transfer(
    from: &signer,
    to: address,
    amount: u64
) acquires Account {
    // å‰ç½®æ¡ä»¶æ£€æŸ¥
    assert!(amount > 0, ERROR_INVALID_AMOUNT);
    assert!(from_addr != to, ERROR_SELF_TRANSFER);
    assert!(exists<Account>(from_addr), ERROR_ACCOUNT_NOT_FOUND);
    assert!(exists<Account>(to), ERROR_ACCOUNT_NOT_FOUND);
    
    let from_addr = signer::address_of(from);
    let from_account = borrow_global_mut<Account>(from_addr);
    assert!(from_account.balance >= amount, ERROR_INSUFFICIENT_BALANCE);
    assert!(!from_account.frozen, ERROR_ACCOUNT_FROZEN);
    
    // æ‰§è¡Œä¸šåŠ¡é€»è¾‘...
}
```

### 4.2 æ¨¡å¼ 2ï¼šæƒé™éªŒè¯

```move
/// éªŒè¯è°ƒç”¨è€…æ˜¯å¦ä¸ºæ‰€æœ‰è€…
fun assert_is_owner(account: &signer, expected_owner: address) {
    assert!(
        signer::address_of(account) == expected_owner,
        ERROR_NOT_OWNER
    );
}

/// éªŒè¯è°ƒç”¨è€…æ˜¯å¦ä¸ºç®¡ç†å‘˜
fun assert_is_admin(account: &signer) acquires AdminList {
    let admin_list = borrow_global<AdminList>(@module_addr);
    assert!(
        vector::contains(&admin_list.admins, &signer::address_of(account)),
        ERROR_NOT_ADMIN
    );
}

public fun admin_operation(admin: &signer) acquires AdminList {
    assert_is_admin(admin);
    // æ‰§è¡Œç®¡ç†å‘˜æ“ä½œ...
}
```

### 4.3 æ¨¡å¼ 3ï¼šçŠ¶æ€éªŒè¯

```move
struct State has key {
    initialized: bool,
    paused: bool
}

fun assert_initialized(addr: address) acquires State {
    assert!(exists<State>(addr), ERROR_NOT_INITIALIZED);
    let state = borrow_global<State>(addr);
    assert!(state.initialized, ERROR_NOT_INITIALIZED);
}

fun assert_not_paused(addr: address) acquires State {
    let state = borrow_global<State>(addr);
    assert!(!state.paused, ERROR_PAUSED);
}

public fun operation(user: &signer) acquires State {
    assert_initialized(@module_addr);
    assert_not_paused(@module_addr);
    // æ‰§è¡Œæ“ä½œ...
}
```

### 4.4 æ¨¡å¼ 4ï¼šèŒƒå›´éªŒè¯

```move
public fun set_fee_rate(admin: &signer, new_rate: u64) acquires Config {
    assert_is_admin(admin);
    
    // éªŒè¯è´¹ç‡èŒƒå›´ï¼š0.01% - 10%
    const MIN_FEE_RATE: u64 = 10;      // 0.01%
    const MAX_FEE_RATE: u64 = 100000;  // 10%
    
    assert!(
        new_rate >= MIN_FEE_RATE && new_rate <= MAX_FEE_RATE,
        ERROR_INVALID_FEE_RATE
    );
    
    let config = borrow_global_mut<Config>(@module_addr);
    config.fee_rate = new_rate;
}
```

### 4.5 æ¨¡å¼ 5ï¼šç»„åˆéªŒè¯

```move
public fun swap(
    user: &signer,
    amount_in: u64,
    min_amount_out: u64,
    deadline: u64
) acquires Pool, UserAccount {
    // 1. åŸºæœ¬éªŒè¯
    assert!(amount_in > 0, ERROR_INVALID_AMOUNT);
    assert!(min_amount_out > 0, ERROR_INVALID_AMOUNT);
    
    // 2. æ—¶é—´éªŒè¯
    assert!(
        timestamp::now_seconds() <= deadline,
        ERROR_DEADLINE_PASSED
    );
    
    // 3. è´¦æˆ·éªŒè¯
    let user_addr = signer::address_of(user);
    assert!(exists<UserAccount>(user_addr), ERROR_ACCOUNT_NOT_FOUND);
    
    // 4. ä½™é¢éªŒè¯
    let account = borrow_global<UserAccount>(user_addr);
    assert!(account.balance >= amount_in, ERROR_INSUFFICIENT_BALANCE);
    
    // 5. æ‰§è¡Œäº¤æ¢å¹¶éªŒè¯æ»‘ç‚¹
    let amount_out = calculate_output(amount_in);
    assert!(
        amount_out >= min_amount_out,
        ERROR_SLIPPAGE_TOO_HIGH
    );
    
    // æ‰§è¡Œäº¤æ¢...
}
```

---

## ç¬¬äº”éƒ¨åˆ†ï¼šOption ä¸ Result æ¨¡å¼

### 5.1 ä½¿ç”¨ Option å¤„ç†å¯é€‰å€¼

```move
use std::option::{Self, Option};

/// å®‰å…¨çš„æŸ¥è¯¢å‡½æ•°ï¼Œä¸ä¼š abort
public fun try_get_balance(addr: address): Option<u64> acquires Account {
    if (!exists<Account>(addr)) {
        return option::none()
    };
    
    let account = borrow_global<Account>(addr);
    option::some(account.balance)
}

/// ä½¿ç”¨ç¤ºä¾‹
public fun safe_operation(addr: address) acquires Account {
    let balance_opt = try_get_balance(addr);
    
    if (option::is_some(&balance_opt)) {
        let balance = option::extract(&mut balance_opt);
        // ä½¿ç”¨ balance...
    } else {
        // è´¦æˆ·ä¸å­˜åœ¨ï¼Œè¿”å›é»˜è®¤å€¼æˆ–è·³è¿‡
    };
}
```

### 5.2 è‡ªå®šä¹‰ Result ç±»å‹

```move
/// è‡ªå®šä¹‰ Result ç±»å‹
struct Result<T> has drop {
    is_ok: bool,
    value: T,
    error_code: u64
}

public fun ok<T>(value: T): Result<T> {
    Result {
        is_ok: true,
        value,
        error_code: 0
    }
}

public fun err<T>(default_value: T, error_code: u64): Result<T> {
    Result {
        is_ok: false,
        value: default_value,
        error_code
    }
}

public fun try_withdraw(
    account: &signer,
    amount: u64
): Result<u64> acquires Account {
    let addr = signer::address_of(account);
    
    if (!exists<Account>(addr)) {
        return err(0, ERROR_ACCOUNT_NOT_FOUND)
    };
    
    let account_ref = borrow_global_mut<Account>(addr);
    
    if (account_ref.balance < amount) {
        return err(0, ERROR_INSUFFICIENT_BALANCE)
    };
    
    account_ref.balance = account_ref.balance - amount;
    ok(amount)
}
```

### 5.3 ä½•æ—¶ä½¿ç”¨ abort vs Option

**ä½¿ç”¨ abort**ï¼š
- âœ… å‰ç½®æ¡ä»¶è¿åï¼ˆå¦‚å‚æ•°æ— æ•ˆï¼‰
- âœ… ä¸å˜é‡è¿åï¼ˆå¦‚æ•°æ®æŸåï¼‰
- âœ… æƒé™æ£€æŸ¥å¤±è´¥
- âœ… ä¸å¯æ¢å¤çš„é”™è¯¯

**ä½¿ç”¨ Option/Result**ï¼š
- âœ… æŸ¥è¯¢å¯èƒ½ä¸å­˜åœ¨çš„æ•°æ®
- âœ… å¯é€‰çš„æ“ä½œ
- âœ… éœ€è¦é“¾ä¸‹å¤„ç†çš„é”™è¯¯
- âœ… æ‰¹é‡æ“ä½œä¸­çš„éƒ¨åˆ†å¤±è´¥

**ç¤ºä¾‹å¯¹æ¯”**ï¼š
```move
// âŒ ä¸å¥½ï¼šæŸ¥è¯¢ä½¿ç”¨ abort
public fun get_user_name(addr: address): vector<u8> acquires UserProfile {
    assert!(exists<UserProfile>(addr), ERROR_NOT_FOUND);
    borrow_global<UserProfile>(addr).name
}

// âœ… å¥½ï¼šæŸ¥è¯¢ä½¿ç”¨ Option
public fun try_get_user_name(addr: address): Option<vector<u8>> acquires UserProfile {
    if (!exists<UserProfile>(addr)) {
        return option::none()
    };
    option::some(borrow_global<UserProfile>(addr).name)
}

// âœ… å¥½ï¼šå¿…é¡»æ“ä½œä½¿ç”¨ abort
public fun update_profile(account: &signer, name: vector<u8>) acquires UserProfile {
    let addr = signer::address_of(account);
    assert!(exists<UserProfile>(addr), ERROR_NOT_FOUND);  // å¿…é¡»å­˜åœ¨
    let profile = borrow_global_mut<UserProfile>(addr);
    profile.name = name;
}
```

---

## ç¬¬å…­éƒ¨åˆ†ï¼šæµ‹è¯•é”™è¯¯å¤„ç†

### 6.1 æµ‹è¯•é¢„æœŸå¤±è´¥

```move
#[test]
#[expected_failure(abort_code = ERROR_INSUFFICIENT_BALANCE)]
public fun test_withdraw_insufficient_balance() acquires Account {
    let account = create_test_account();
    deposit(&account, 100);
    withdraw(&account, 200);  // åº”è¯¥å¤±è´¥
}

#[test]
#[expected_failure(abort_code = ERROR_NOT_OWNER)]
public fun test_unauthorized_access() acquires Resource {
    let owner = create_account(@0x1);
    let attacker = create_account(@0x2);
    
    create_resource(&owner);
    modify_resource(&attacker);  // åº”è¯¥å¤±è´¥
}
```

### 6.2 æµ‹è¯•è¾¹ç•Œæƒ…å†µ

```move
#[test]
public fun test_zero_amount() acquires Account {
    let account = create_test_account();
    // æµ‹è¯•é›¶é‡‘é¢æ˜¯å¦è¢«æ­£ç¡®æ‹’ç»
    assert!(
        !try_withdraw(&account, 0).is_ok,
        0
    );
}

#[test]
public fun test_exact_balance() acquires Account {
    let account = create_test_account();
    deposit(&account, 100);
    // æµ‹è¯•ç²¾ç¡®ä½™é¢ææ¬¾
    withdraw(&account, 100);  // åº”è¯¥æˆåŠŸ
    assert!(get_balance(signer::address_of(&account)) == 0, 0);
}
```

---

## ç¬¬ä¸ƒéƒ¨åˆ†ï¼šå®æˆ˜ç¤ºä¾‹

### 7.1 å®Œæ•´çš„è½¬è´¦å‡½æ•°

```move
module my_addr::safe_bank {
    use std::signer;
    use aptos_framework::timestamp;
    
    // é”™è¯¯ç å®šä¹‰
    const ERROR_ACCOUNT_NOT_FOUND: u64 = 101;
    const ERROR_INSUFFICIENT_BALANCE: u64 = 201;
    const ERROR_INVALID_AMOUNT: u64 = 202;
    const ERROR_SELF_TRANSFER: u64 = 203;
    const ERROR_ACCOUNT_FROZEN: u64 = 301;
    const ERROR_DAILY_LIMIT_EXCEEDED: u64 = 401;
    
    struct Account has key {
        balance: u64,
        frozen: bool,
        daily_transferred: u64,
        last_transfer_day: u64
    }
    
    /// å®‰å…¨çš„è½¬è´¦å‡½æ•°ï¼ŒåŒ…å«å®Œæ•´çš„é”™è¯¯æ£€æŸ¥
    public fun transfer(
        from: &signer,
        to: address,
        amount: u64
    ) acquires Account {
        // 1. åŸºæœ¬å‚æ•°éªŒè¯
        assert!(amount > 0, ERROR_INVALID_AMOUNT);
        
        let from_addr = signer::address_of(from);
        assert!(from_addr != to, ERROR_SELF_TRANSFER);
        
        // 2. è´¦æˆ·å­˜åœ¨æ€§æ£€æŸ¥
        assert!(exists<Account>(from_addr), ERROR_ACCOUNT_NOT_FOUND);
        assert!(exists<Account>(to), ERROR_ACCOUNT_NOT_FOUND);
        
        // 3. å‘é€æ–¹æ£€æŸ¥
        {
            let from_account = borrow_global<Account>(from_addr);
            assert!(!from_account.frozen, ERROR_ACCOUNT_FROZEN);
            assert!(from_account.balance >= amount, ERROR_INSUFFICIENT_BALANCE);
            
            // 4. æ¯æ—¥é™é¢æ£€æŸ¥
            let today = timestamp::now_seconds() / 86400;
            let daily_limit = 10000;  // ç¤ºä¾‹é™é¢
            
            if (from_account.last_transfer_day == today) {
                assert!(
                    from_account.daily_transferred + amount <= daily_limit,
                    ERROR_DAILY_LIMIT_EXCEEDED
                );
            };
        };
        
        // 5. æ¥æ”¶æ–¹æ£€æŸ¥
        {
            let to_account = borrow_global<Account>(to);
            assert!(!to_account.frozen, ERROR_ACCOUNT_FROZEN);
        };
        
        // 6. æ‰§è¡Œè½¬è´¦
        {
            let from_account = borrow_global_mut<Account>(from_addr);
            from_account.balance = from_account.balance - amount;
            
            let today = timestamp::now_seconds() / 86400;
            if (from_account.last_transfer_day != today) {
                from_account.daily_transferred = amount;
                from_account.last_transfer_day = today;
            } else {
                from_account.daily_transferred = from_account.daily_transferred + amount;
            };
        };
        
        {
            let to_account = borrow_global_mut<Account>(to);
            to_account.balance = to_account.balance + amount;
        };
    }
}
```

---

## ğŸ’¡ å…³é”®è¦ç‚¹

1. **ä½¿ç”¨å¸¸é‡å®šä¹‰é”™è¯¯ç **ï¼šé¿å…é­”æ³•æ•°å­—
2. **é”™è¯¯ç è¦æ–‡æ¡£åŒ–**ï¼šæ¸…æ™°è¯´æ˜æ¯ä¸ªé”™è¯¯çš„å«ä¹‰
3. **ä¼˜å…ˆä½¿ç”¨ assert!**ï¼šæ¯” if + abort æ›´ç®€æ´
4. **å‰ç½®æ¡ä»¶å…ˆæ£€æŸ¥**ï¼šåœ¨å‡½æ•°å¼€å§‹å¤„éªŒè¯æ‰€æœ‰æ¡ä»¶
5. **åˆç†ä½¿ç”¨ Option**ï¼šå¯é€‰æ“ä½œä¸åº”è¯¥ abort
6. **æµ‹è¯•é”™è¯¯æƒ…å†µ**ï¼šä½¿ç”¨ expected_failure æµ‹è¯•

---

## ğŸ¯ æ€è€ƒé¢˜

1. ä»€ä¹ˆæ—¶å€™åº”è¯¥ä½¿ç”¨ abortï¼Œä»€ä¹ˆæ—¶å€™ä½¿ç”¨ Optionï¼Ÿ
2. ä¸ºä»€ä¹ˆé”™è¯¯ç è¦ä½¿ç”¨å¸¸é‡è€Œä¸æ˜¯å­—é¢é‡ï¼Ÿ
3. å¦‚ä½•è®¾è®¡ä¸€ä¸ªæ˜“äºç»´æŠ¤çš„é”™è¯¯ç ç³»ç»Ÿï¼Ÿ
4. åœ¨æ‰¹é‡æ“ä½œä¸­å¦‚ä½•å¤„ç†éƒ¨åˆ†å¤±è´¥ï¼Ÿ

ç­”æ¡ˆåœ¨ä»Šæ—¥è€ƒè¯•ä¸­ï¼

---

**ä¸‹ä¸€æ­¥**ï¼šå®Œæˆå®è·µä»»åŠ¡ï¼Œæ„å»ºå¥å£®çš„é”™è¯¯å¤„ç†ç³»ç»Ÿã€‚

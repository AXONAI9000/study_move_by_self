# Day 20 每日考试 - 编程题

## 📝 考试说明

- **题目数量**: 5 题
- **每题分值**: 3 分
- **总分**: 15 分
- **及格线**: 10.5 分
- **考试时间**: 60 分钟

**答题方式**: 在代码编辑器中完成代码,运行测试验证正确性。

---

## 编程题

### 第 1 题: 利率计算 (3 分)

#### 题目描述

实现一个分段利率模型 (Kinked Interest Rate Model),根据利用率计算借款利率。

**利率模型参数**:
- 基础利率 (Base Rate): 2%
- 斜率1 (Slope1): 10%
- 斜率2 (Slope2): 60%
- 最优利用率 (Optimal Utilization): 80%

**计算规则**:
```
if 利用率 <= 最优利用率:
    借款利率 = 基础利率 + (利用率 / 最优利用率) × 斜率1
else:
    借款利率 = 基础利率 + 斜率1 + 
               ((利用率 - 最优利用率) / (100% - 最优利用率)) × 斜率2
```

#### 函数签名

```move
/// 计算借款利率
/// 
/// 参数:
///   - utilization: 利用率 (精度 1e6, 即 800000 表示 80%)
///   - base_rate: 基础利率 (精度 1e6, 即 20000 表示 2%)
///   - slope1: 斜率1 (精度 1e6)
///   - slope2: 斜率2 (精度 1e6)
///   - optimal_utilization: 最优利用率 (精度 1e6)
/// 
/// 返回: 借款利率 (精度 1e6)
public fun calculate_borrow_rate(
    utilization: u64,
    base_rate: u64,
    slope1: u64,
    slope2: u64,
    optimal_utilization: u64
): u64 {
    // TODO: 实现利率计算逻辑
    0
}
```

#### 测试用例

```move
#[test]
fun test_calculate_borrow_rate() {
    // 测试用例 1: 利用率 40% (低于最优)
    let rate1 = calculate_borrow_rate(
        400000,   // 40%
        20000,    // 2%
        100000,   // 10%
        600000,   // 60%
        800000    // 80%
    );
    assert!(rate1 == 70000, 0); // 应该是 7%
    
    // 测试用例 2: 利用率 80% (等于最优)
    let rate2 = calculate_borrow_rate(
        800000,   // 80%
        20000,    // 2%
        100000,   // 10%
        600000,   // 60%
        800000    // 80%
    );
    assert!(rate2 == 120000, 0); // 应该是 12%
    
    // 测试用例 3: 利用率 90% (高于最优)
    let rate3 = calculate_borrow_rate(
        900000,   // 90%
        20000,    // 2%
        100000,   // 10%
        600000,   // 60%
        800000    // 80%
    );
    assert!(rate3 == 420000, 0); // 应该是 42%
}
```

#### 评分标准

- ✅ **3 分**: 所有测试用例通过,代码简洁清晰
- ✅ **2 分**: 大部分逻辑正确,有小错误
- ✅ **1 分**: 基本思路对,实现有问题
- ❌ **0 分**: 逻辑错误或无法运行

---

### 第 2 题: 健康因子计算 (3 分)

#### 题目描述

实现健康因子 (Health Factor) 的计算函数。健康因子用于衡量借款人的偿债能力。

**计算公式**:
```
健康因子 = (总抵押品价值 × 加权平均抵押率) / 总借款价值
```

**特殊情况**:
- 如果没有借款,返回最大健康因子 (表示无风险)
- 如果健康因子 < 1.0,表示可以被清算

#### 函数签名

```move
/// 计算健康因子
/// 
/// 参数:
///   - total_collateral_value: 总抵押品价值 (USD, 精度 1e8)
///   - weighted_collateral_factor: 加权平均抵押率 (精度 1e6)
///   - total_debt_value: 总借款价值 (USD, 精度 1e8)
/// 
/// 返回: 健康因子 (精度 1e18)
public fun calculate_health_factor(
    total_collateral_value: u128,
    weighted_collateral_factor: u64,
    total_debt_value: u128
): u128 {
    // TODO: 实现健康因子计算
    0
}
```

#### 测试用例

```move
const PRECISION: u128 = 1000000000000000000; // 1e18
const MAX_HEALTH_FACTOR: u128 = 115792089237316195423570985008687907853269984665640564039457;

#[test]
fun test_calculate_health_factor() {
    // 测试用例 1: 正常情况
    // 抵押品: $1000, 抵押率: 75%, 借款: $600
    let hf1 = calculate_health_factor(
        100000000000,  // $1000 (精度 1e8)
        750000,        // 75% (精度 1e6)
        60000000000    // $600 (精度 1e8)
    );
    // 健康因子 = 1000 * 0.75 / 600 = 1.25
    assert!(hf1 == 1250000000000000000, 0); // 1.25 * 1e18
    
    // 测试用例 2: 无借款
    let hf2 = calculate_health_factor(
        100000000000,  // $1000
        750000,        // 75%
        0              // $0 借款
    );
    assert!(hf2 == MAX_HEALTH_FACTOR, 0); // 返回最大值
    
    // 测试用例 3: 临界清算
    // 抵押品: $1000, 抵押率: 75%, 借款: $750
    let hf3 = calculate_health_factor(
        100000000000,  // $1000
        750000,        // 75%
        75000000000    // $750
    );
    // 健康因子 = 1000 * 0.75 / 750 = 1.0
    assert!(hf3 == PRECISION, 0); // 1.0 * 1e18
}
```

#### 评分标准

- ✅ **3 分**: 所有测试用例通过,考虑边界情况
- ✅ **2 分**: 主要逻辑正确,边界情况处理有误
- ✅ **1 分**: 基本公式对,精度处理有问题
- ❌ **0 分**: 公式错误或无法运行

---

### 第 3 题: 利息累积计算 (3 分)

#### 题目描述

实现基于利息指数 (Interest Index) 的余额计算。在借贷协议中,用户的实际余额 = 本金 × (当前指数 / 存入时指数)。

#### 函数签名

```move
/// 计算含利息的余额
/// 
/// 参数:
///   - principal: 本金数量
///   - deposit_index: 存入时的利息指数 (精度 1e18)
///   - current_index: 当前利息指数 (精度 1e18)
/// 
/// 返回: 当前余额(含利息)
public fun calculate_balance_with_interest(
    principal: u64,
    deposit_index: u128,
    current_index: u128
): u64 {
    // TODO: 实现余额计算
    0
}

/// 更新利息指数
/// 
/// 参数:
///   - old_index: 旧指数 (精度 1e18)
///   - interest_rate: 年化利率 (精度 1e6)
///   - time_elapsed: 经过的时间 (秒)
/// 
/// 返回: 新指数 (精度 1e18)
public fun update_interest_index(
    old_index: u128,
    interest_rate: u64,
    time_elapsed: u64
): u128 {
    // TODO: 实现指数更新
    // 简化公式: new_index = old_index * (1 + rate * time / SECONDS_PER_YEAR)
    0
}
```

#### 测试用例

```move
const PRECISION: u128 = 1000000000000000000; // 1e18
const SECONDS_PER_YEAR: u64 = 31536000; // 365 天

#[test]
fun test_interest_calculation() {
    // 测试用例 1: 计算含利息余额
    // 用户存入 100 代币,指数从 1.0 增长到 1.1
    let balance1 = calculate_balance_with_interest(
        100,
        PRECISION,           // 1.0 * 1e18
        1100000000000000000  // 1.1 * 1e18
    );
    assert!(balance1 == 110, 0); // 100 * 1.1 = 110
    
    // 测试用例 2: 更新利息指数
    // 初始指数 1.0, 年化利率 10%, 经过 1 年
    let new_index = update_interest_index(
        PRECISION,      // 1.0
        100000,         // 10% (精度 1e6)
        SECONDS_PER_YEAR  // 1 年
    );
    assert!(new_index == 1100000000000000000, 0); // 1.1 * 1e18
    
    // 测试用例 3: 半年利息
    // 初始指数 1.0, 年化利率 10%, 经过 0.5 年
    let half_year_index = update_interest_index(
        PRECISION,
        100000,              // 10%
        SECONDS_PER_YEAR / 2 // 0.5 年
    );
    assert!(half_year_index == 1050000000000000000, 0); // 1.05 * 1e18
}
```

#### 评分标准

- ✅ **3 分**: 两个函数都正确实现,精度处理准确
- ✅ **2 分**: 一个函数正确,另一个有小问题
- ✅ **1 分**: 基本逻辑对,精度计算有误
- ❌ **0 分**: 逻辑错误或无法运行

---

### 第 4 题: 清算金额计算 (3 分)

#### 题目描述

实现清算金额和清算人获得抵押品数量的计算。

**清算规则**:
1. 最大清算比例: 50% 的债务
2. 清算人支付债务,获得等值抵押品 + 清算奖励
3. 清算奖励: 通常为 5-10%

#### 函数签名

```move
/// 计算清算金额
/// 
/// 参数:
///   - debt_amount: 借款人总债务
///   - max_close_factor: 最大清算比例 (精度 1e6, 如 500000 表示 50%)
/// 
/// 返回: 可清算的债务金额
public fun calculate_liquidation_amount(
    debt_amount: u64,
    max_close_factor: u64
): u64 {
    // TODO: 实现清算金额计算
    0
}

/// 计算清算人获得的抵押品数量
/// 
/// 参数:
///   - debt_to_cover: 清算人支付的债务金额
///   - debt_price: 债务资产价格 (USD, 精度 1e8)
///   - collateral_price: 抵押品资产价格 (USD, 精度 1e8)
///   - liquidation_bonus: 清算奖励 (精度 1e6, 如 80000 表示 8%)
/// 
/// 返回: 清算人获得的抵押品数量
public fun calculate_collateral_amount(
    debt_to_cover: u64,
    debt_price: u128,
    collateral_price: u128,
    liquidation_bonus: u64
): u64 {
    // TODO: 实现抵押品数量计算
    // 公式: (debt_to_cover * debt_price * (1 + bonus)) / collateral_price
    0
}
```

#### 测试用例

```move
#[test]
fun test_liquidation_calculation() {
    // 测试用例 1: 计算清算金额
    // 总债务 1000, 最大清算 50%
    let liquidation_amt = calculate_liquidation_amount(
        1000,
        500000  // 50%
    );
    assert!(liquidation_amt == 500, 0);
    
    // 测试用例 2: 计算抵押品数量
    // 清算 750 USDC (价格 $1), 获得 ETH (价格 $1800), 奖励 8%
    let collateral_amt = calculate_collateral_amount(
        750,              // 750 USDC
        100000000,        // $1 (精度 1e8)
        180000000000,     // $1800 (精度 1e8)
        80000             // 8%
    );
    // 计算: 750 * 1 * 1.08 / 1800 = 0.45 ETH
    // 由于 ETH 精度问题,这里假设 1 ETH = 1e8 单位
    // 实际: (750 * 1e8 * 1.08) / 1800 = 45000000 (0.45 * 1e8)
    assert!(collateral_amt == 45000000, 0);
}
```

#### 评分标准

- ✅ **3 分**: 两个函数都正确,精度和溢出处理得当
- ✅ **2 分**: 主要逻辑正确,细节有误
- ✅ **1 分**: 基本公式对,实现有问题
- ❌ **0 分**: 逻辑错误或无法运行

---

### 第 5 题: 存款利率计算 (3 分)

#### 题目描述

实现存款利率的计算。存款利率由借款利率、利用率和储备金因子共同决定。

**计算公式**:
```
存款利率 = 借款利率 × 利用率 × (1 - 储备金因子)
```

**逻辑**:
- 只有借出的资金产生利息
- 部分利息作为协议储备金
- 存款人分享剩余利息

#### 函数签名

```move
/// 计算存款利率
/// 
/// 参数:
///   - borrow_rate: 借款利率 (精度 1e6)
///   - utilization_rate: 利用率 (精度 1e6)
///   - reserve_factor: 储备金因子 (精度 1e6, 如 100000 表示 10%)
/// 
/// 返回: 存款利率 (精度 1e6)
public fun calculate_deposit_rate(
    borrow_rate: u64,
    utilization_rate: u64,
    reserve_factor: u64
): u64 {
    // TODO: 实现存款利率计算
    0
}
```

#### 测试用例

```move
const RATE_PRECISION: u64 = 1000000; // 1e6

#[test]
fun test_calculate_deposit_rate() {
    // 测试用例 1: 正常情况
    // 借款利率 10%, 利用率 80%, 储备金因子 10%
    let deposit_rate1 = calculate_deposit_rate(
        100000,  // 10%
        800000,  // 80%
        100000   // 10%
    );
    // 计算: 10% * 80% * (1 - 10%) = 10% * 80% * 90% = 7.2%
    assert!(deposit_rate1 == 72000, 0);
    
    // 测试用例 2: 低利用率
    // 借款利率 5%, 利用率 20%, 储备金因子 10%
    let deposit_rate2 = calculate_deposit_rate(
        50000,   // 5%
        200000,  // 20%
        100000   // 10%
    );
    // 计算: 5% * 20% * 90% = 0.9%
    assert!(deposit_rate2 == 9000, 0);
    
    // 测试用例 3: 零利用率
    let deposit_rate3 = calculate_deposit_rate(
        100000,  // 10%
        0,       // 0%
        100000   // 10%
    );
    assert!(deposit_rate3 == 0, 0); // 无借款,无利息
}
```

#### 评分标准

- ✅ **3 分**: 所有测试通过,精度处理正确
- ✅ **2 分**: 逻辑正确,精度有小误差
- ✅ **1 分**: 基本公式对,实现细节有问题
- ❌ **0 分**: 公式错误或无法运行

---

## 📊 答题卡

请在此记录你的得分:

```
第 1 题: ___ / 3 分
第 2 题: ___ / 3 分
第 3 题: ___ / 3 分
第 4 题: ___ / 3 分
第 5 题: ___ / 3 分
─────────────────
总分: ___ / 15 分
```

---

## ✅ 自我评估

- ✅ **优秀** (≥ 13 分): 编程能力强,理解深入!
- ✅ **良好** (10.5-12.5 分): 基本掌握,继续练习。
- ⚠️ **及格** (9-10 分): 理解不够深入,需加强。
- ❌ **不及格** (< 9 分): 建议重新学习并多练习。

---

## 💡 提示

### 精度处理技巧

```move
// 1. 乘法可能溢出,使用 u128
let result = (a as u128) * (b as u128) / (c as u128);

// 2. 先乘后除,保持精度
let correct = a * b / c;  // ✅
let wrong = a / c * b;    // ❌ 精度损失

// 3. 注意精度单位
// 利率通常用 1e6
// 价格通常用 1e8
// 指数通常用 1e18
```

### 边界情况检查

```move
// 1. 除零保护
if (denominator == 0) {
    return special_value;
};

// 2. 溢出保护
use aptos_std::math64;
let safe_result = math64::mul_div(a, b, c);

// 3. 最小/最大值限制
if (value > MAX_VALUE) {
    value = MAX_VALUE;
};
```

---

**完成后,请查看 `答案解析.md` 对照答案并计算得分。**

*Good luck! 💪*

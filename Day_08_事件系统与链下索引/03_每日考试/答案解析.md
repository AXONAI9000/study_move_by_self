# Day 08 ç­”æ¡ˆè§£æ

## é€‰æ‹©é¢˜ç­”æ¡ˆï¼ˆ40 åˆ†ï¼‰

### ç¬¬ä¸€éƒ¨åˆ†ï¼šäº‹ä»¶åŸºç¡€æ¦‚å¿µï¼ˆ1-5 é¢˜ï¼‰

**1. B - äº‹ä»¶åªèƒ½è¢«é“¾ä¸‹ç›‘å¬**

**è§£æ**ï¼š
- A âŒ äº‹ä»¶ä¸èƒ½åœ¨é“¾ä¸Šè¯»å–
- B âœ… äº‹ä»¶åªèƒ½è¢«é“¾ä¸‹ç›‘å¬ï¼Œè¿™æ˜¯äº‹ä»¶ç³»ç»Ÿçš„æ ¸å¿ƒç‰¹æ€§
- C âŒ äº‹ä»¶ä¸å¿…å­˜å‚¨åœ¨å…¨å±€çŠ¶æ€ä¸­ï¼Œå®ƒä»¬é€šè¿‡ EventHandle ç®¡ç†
- D âŒ äº‹ä»¶ä¸èƒ½ä¿®æ”¹çŠ¶æ€ï¼Œåªèƒ½è®°å½•ä¿¡æ¯

**å…³é”®ç‚¹**ï¼šäº‹ä»¶æ˜¯å•å‘çš„"åªå†™"æœºåˆ¶ï¼Œç”¨äºé“¾ä¸Šåˆ°é“¾ä¸‹çš„é€šä¿¡ã€‚

---

**2. B - ä½œä¸ºäº‹ä»¶çš„å®¹å™¨å’Œå‘å°„å™¨**

**è§£æ**ï¼š
- A âŒ EventHandle ä¸å­˜å‚¨äº‹ä»¶æ•°æ®æœ¬èº«ï¼Œåªç®¡ç†å‘å°„
- B âœ… EventHandle æ˜¯äº‹ä»¶çš„å®¹å™¨ï¼Œè´Ÿè´£å‘å°„å’Œç¼–å·
- C âŒ äº‹ä»¶éªŒè¯ç”±ç±»å‹ç³»ç»Ÿä¿è¯
- D âŒ äº‹ä»¶å†…å®¹ä¸éœ€è¦åŠ å¯†

**å…³é”®ç‚¹**ï¼šEventHandle ç®¡ç†ç‰¹å®šç±»å‹äº‹ä»¶çš„å‘å°„å’Œåºå·ã€‚

---

**3. B - `drop` å’Œ `store`**

**è§£æ**ï¼š
```move
struct MyEvent has drop, store {
    // drop: äº‹ä»¶å‘å°„åå¯ä»¥è¢«ä¸¢å¼ƒ
    // store: å¯ä»¥å­˜å‚¨åœ¨ EventHandle ä¸­
}
```

- `key` ä¸éœ€è¦ï¼Œäº‹ä»¶ä¸æ˜¯èµ„æº
- `copy` ä¸éœ€è¦ï¼Œäº‹ä»¶å‘å°„åå°±ä¸å†éœ€è¦

---

**4. B - é€šçŸ¥å‰ç«¯è½¬è´¦å®Œæˆ**

**è§£æ**ï¼š
- A âŒ ä½™é¢åº”è¯¥å­˜å‚¨åœ¨èµ„æºä¸­
- B âœ… äº‹ä»¶ç”¨äºé€šçŸ¥ï¼Œè¿™æ˜¯å…¸å‹ç”¨ä¾‹
- C âŒ èº«ä»½éªŒè¯åœ¨é“¾ä¸Šå®Œæˆ
- D âŒ æ‰‹ç»­è´¹è®¡ç®—æ˜¯é“¾ä¸Šé€»è¾‘

**å…³é”®ç‚¹**ï¼šäº‹ä»¶ç”¨äºé€šçŸ¥å’Œè®°å½•ï¼Œä¸ç”¨äºå­˜å‚¨æˆ–è®¡ç®—ã€‚

---

**5. C - èµ„æºï¼ˆstruct with keyï¼‰ä¸­**

**è§£æ**ï¼š
```move
struct MyResource has key {
    data: u64,
    events: event::EventHandle<MyEvent>  // å¿…é¡»åœ¨èµ„æºä¸­
}
```

EventHandle éœ€è¦æŒä¹…åŒ–å­˜å‚¨ï¼Œåªèƒ½æ”¾åœ¨å¸¦ `key` èƒ½åŠ›çš„èµ„æºä¸­ã€‚

---

### ç¬¬äºŒéƒ¨åˆ†ï¼šäº‹ä»¶æ“ä½œï¼ˆ6-10 é¢˜ï¼‰

**6. B - `event::emit_event()`**

**è§£æ**ï¼š
```move
event::emit_event(&mut handle, MyEvent { ... });
```

è¿™æ˜¯æ ‡å‡† APIï¼Œæ¥è‡ª `aptos_framework::event` æ¨¡å—ã€‚

---

**7. B - è‡ªåŠ¨é€’å¢**

**è§£æ**ï¼š
- EventHandle å†…éƒ¨ç»´æŠ¤ counter
- æ¯æ¬¡å‘å°„äº‹ä»¶ï¼Œcounter è‡ªåŠ¨ +1
- ä» 0 å¼€å§‹ï¼ˆç¬¬ä¸€ä¸ªäº‹ä»¶åºå·æ˜¯ 0ï¼‰
- å¼€å‘è€…æ— éœ€æ‰‹åŠ¨ç®¡ç†

---

**8. B - ä¸èƒ½å€Ÿç”¨ä¸å¯å˜å¼•ç”¨åä¿®æ”¹**

**è§£æ**ï¼š
```move
// âŒ é”™è¯¯
let store = borrow_global<CoinStore>(...);
event::emit_event(&mut store.events, ...);

// âœ… æ­£ç¡®
let store = borrow_global_mut<CoinStore>(...);
event::emit_event(&mut store.events, ...);
```

`emit_event` éœ€è¦å¯å˜å¼•ç”¨ `&mut`ï¼Œå¿…é¡»ä½¿ç”¨ `borrow_global_mut`ã€‚

---

**9. C - æ²¡æœ‰é™åˆ¶**

**è§£æ**ï¼š
```move
struct MyResource has key {
    events1: event::EventHandle<Event1>,
    events2: event::EventHandle<Event2>,
    events3: event::EventHandle<Event3>,
    // å¯ä»¥æœ‰ä»»æ„å¤šä¸ª
}
```

æ ¹æ®ä¸šåŠ¡éœ€è¦ï¼Œå¯ä»¥å®šä¹‰ä»»æ„æ•°é‡çš„ EventHandleã€‚

---

**10. B - `event::new_event_handle<T>(account)`**

**è§£æ**ï¼š
```move
public entry fun init(account: &signer) {
    move_to(account, MyResource {
        events: event::new_event_handle<MyEvent>(account)
    });
}
```

éœ€è¦ä¼ å…¥ signer å¼•ç”¨ä»¥ç”Ÿæˆå”¯ä¸€çš„ GUIDã€‚

---

### ç¬¬ä¸‰éƒ¨åˆ†ï¼šäº‹ä»¶è®¾è®¡ï¼ˆ11-15 é¢˜ï¼‰

**11. A - from, to, amount, timestamp**

**è§£æ**ï¼š
```move
struct TransferEvent has drop, store {
    from: address,      // è°å‘é€çš„
    to: address,        // å‘ç»™è°
    amount: u64,        // å¤šå°‘é’±
    timestamp: u64      // ä»€ä¹ˆæ—¶å€™
}
```

è¿™äº›å­—æ®µå®Œæ•´æè¿°äº†ä¸€æ¬¡è½¬è´¦æ“ä½œã€‚

---

**12. B - ç²¾ç®€ä½†å®Œæ•´ï¼ŒåªåŒ…å«å…³é”®ä¿¡æ¯**

**è§£æ**ï¼š
- âœ… åŒ…å«å¿…è¦çš„æŸ¥è¯¢å­—æ®µ
- âœ… åŒ…å«çŠ¶æ€å˜åŒ–ä¿¡æ¯
- âŒ ä¸åŒ…å«å†—ä½™æ•°æ®
- âŒ ä¸åŒ…å«å¯æ¨å¯¼çš„ä¿¡æ¯

**åŸåˆ™**ï¼šç²¾ç®€ä½†è¶³ä»¥é‡å»ºæ“ä½œå†å²ã€‚

---

**13. C - åªå­˜å‚¨ IPFS å“ˆå¸Œ**

**è§£æ**ï¼š
```move
struct NFTMintedEvent has drop, store {
    token_id: u64,
    owner: address,
    metadata_uri: vector<u8>,  // "ipfs://Qm..."
    timestamp: u64
}
```

å¤§æ–‡ä»¶å­˜å‚¨åœ¨ IPFSï¼Œé“¾ä¸Šåªè®°å½•å“ˆå¸Œã€‚

---

**14. B - æ¯ä¸ªæ“ä½œå‘å°„ç‹¬ç«‹çš„äº‹ä»¶**

**è§£æ**ï¼š
```move
// âœ… å¥½çš„è®¾è®¡
event::emit_event(&mut handle.deposit_events, DepositEvent { ... });
event::emit_event(&mut handle.withdraw_events, WithdrawEvent { ... });

// âŒ ä¸å¥½çš„è®¾è®¡
event::emit_event(&mut handle.events, GenericEvent { type: 1, ... });
```

ä¸åŒç±»å‹æ“ä½œä½¿ç”¨ä¸åŒäº‹ä»¶ç±»å‹ï¼Œä¾¿äºè¿½è¸ªå’ŒæŸ¥è¯¢ã€‚

---

**15. C - `timestamp::now_seconds()`**

**è§£æ**ï¼š
```move
use aptos_framework::timestamp;

let now = timestamp::now_seconds();
event::emit_event(&mut handle, MyEvent {
    timestamp: now,
    ...
});
```

ä½¿ç”¨åŒºå—é“¾æ—¶é—´ï¼Œè€Œä¸æ˜¯ç³»ç»Ÿæ—¶é—´æˆ–ç”¨æˆ·è¾“å…¥ã€‚

---

### ç¬¬å››éƒ¨åˆ†ï¼šé“¾ä¸‹ç´¢å¼•ï¼ˆ16-18 é¢˜ï¼‰

**16. B - ç›‘å¬äº‹ä»¶å¹¶æ„å»ºæ•°æ®åº“**

**è§£æ**ï¼š
```
åŒºå—é“¾ -> äº‹ä»¶ -> ç´¢å¼•å™¨ -> PostgreSQL -> GraphQL API
```

ç´¢å¼•å™¨ç›‘å¬é“¾ä¸Šäº‹ä»¶ï¼Œå°†æ•°æ®å­˜å…¥æ•°æ®åº“ä¾›æŸ¥è¯¢ã€‚

---

**17. D - ä»¥ä¸Šéƒ½æ˜¯**

**è§£æ**ï¼š
- é“¾ä¸ŠæŸ¥è¯¢æ…¢ä¸”è´µï¼ˆæ¯æ¬¡éƒ½éœ€è¦è®¿é—®èŠ‚ç‚¹ï¼‰
- éœ€è¦å¤æ‚æŸ¥è¯¢ï¼ˆå¦‚èšåˆã€JOINã€åˆ†é¡µï¼‰
- éœ€è¦å†å²æ•°æ®åˆ†æï¼ˆå¦‚è¶‹åŠ¿å›¾ã€ç»Ÿè®¡ï¼‰

ç´¢å¼•å™¨è§£å†³äº†è¿™äº›é—®é¢˜ã€‚

---

**18. B - PostgreSQL æ•°æ®åº“**

**è§£æ**ï¼š
Aptos ç´¢å¼•å™¨ä½¿ç”¨ PostgreSQL å­˜å‚¨è§£æåçš„äº‹ä»¶æ•°æ®ï¼Œé€šè¿‡ GraphQL API æä¾›æŸ¥è¯¢æ¥å£ã€‚

---

### ç¬¬äº”éƒ¨åˆ†ï¼šæœ€ä½³å®è·µï¼ˆ19-20 é¢˜ï¼‰

**19. C - äº‹ä»¶åº”è¯¥åŒ…å«æ‰€æœ‰å¯èƒ½çš„æ•°æ®**

**è§£æ**ï¼š
- âœ… A: æ¸…æ™°å‘½åï¼ˆå¦‚ `TransferEvent`ï¼Œä¸æ˜¯ `Event1`ï¼‰
- âœ… B: ç‹¬ç«‹ EventHandleï¼ˆä¾¿äºç®¡ç†å’ŒæŸ¥è¯¢ï¼‰
- âŒ C: ä¸åº”è¯¥åŒ…å«"æ‰€æœ‰"æ•°æ®ï¼Œåº”è¯¥ç²¾ç®€
- âœ… D: é‡è¦æ“ä½œåº”è¯¥å‘å°„äº‹ä»¶

**å…³é”®ç‚¹**ï¼šäº‹ä»¶åº”è¯¥ç²¾ç®€ï¼Œä¸æ˜¯è¶Šå¤šè¶Šå¥½ã€‚

---

**20. D - ä»¥ä¸Šéƒ½å¯èƒ½**

**è§£æ**ï¼š
- EventHandle ä¸å­˜åœ¨ï¼šè¿è¡Œæ—¶é”™è¯¯
- æƒé™ä¸è¶³ï¼šæŸäº›æ“ä½œéœ€è¦ç‰¹å®šæƒé™
- äº¤æ˜“å›æ»šï¼šäº‹ä»¶æ˜¯äº¤æ˜“çš„ä¸€éƒ¨åˆ†ï¼Œå›æ»šæ—¶ä¸ä¼šè®°å½•

**å…³é”®ç‚¹**ï¼šäº‹ä»¶å‘å°„çš„æˆåŠŸå–å†³äºæ•´ä¸ªäº¤æ˜“çš„æˆåŠŸã€‚

---

## é€‰æ‹©é¢˜è¯„åˆ†

| é¢˜å· | ç­”æ¡ˆ | é¢˜å· | ç­”æ¡ˆ | é¢˜å· | ç­”æ¡ˆ | é¢˜å· | ç­”æ¡ˆ |
|------|------|------|------|------|------|------|------|
| 1 | B | 6 | B | 11 | A | 16 | B |
| 2 | B | 7 | B | 12 | B | 17 | D |
| 3 | B | 8 | B | 13 | C | 18 | B |
| 4 | B | 9 | C | 14 | B | 19 | C |
| 5 | C | 10 | B | 15 | C | 20 | D |

---

## ç¼–ç¨‹é¢˜å‚è€ƒç­”æ¡ˆï¼ˆ60 åˆ†ï¼‰

### ç¬¬ä¸€é¢˜ï¼šæ´»åŠ¨ç­¾åˆ°ç³»ç»Ÿï¼ˆ15 åˆ†ï¼‰

```move
module day08_exam::activity {
    use std::signer;
    use std::vector;
    use aptos_framework::event;
    use aptos_framework::timestamp;

    const E_ACTIVITY_NOT_STARTED: u64 = 1;
    const E_ACTIVITY_ENDED: u64 = 2;
    const E_ALREADY_CHECKED_IN: u64 = 3;

    struct CheckInEvent has drop, store {
        activity_id: u64,
        user: address,
        check_in_time: u64,
        total_participants: u64
    }

    struct Activity has key {
        id: u64,
        name: vector<u8>,
        start_time: u64,
        end_time: u64,
        participants: vector<address>,
        check_in_events: event::EventHandle<CheckInEvent>
    }

    public entry fun initialize_activity(
        organizer: &signer,
        id: u64,
        name: vector<u8>,
        start_time: u64,
        end_time: u64
    ) {
        move_to(organizer, Activity {
            id,
            name,
            start_time,
            end_time,
            participants: vector::empty(),
            check_in_events: event::new_event_handle<CheckInEvent>(organizer)
        });
    }

    public entry fun check_in(user: &signer, activity_addr: address) acquires Activity {
        let activity = borrow_global_mut<Activity>(activity_addr);
        let now = timestamp::now_seconds();
        let user_addr = signer::address_of(user);

        // æ£€æŸ¥æ´»åŠ¨æ—¶é—´
        assert!(now >= activity.start_time, E_ACTIVITY_NOT_STARTED);
        assert!(now <= activity.end_time, E_ACTIVITY_ENDED);

        // æ£€æŸ¥æ˜¯å¦å·²ç­¾åˆ°
        assert!(!vector::contains(&activity.participants, &user_addr), E_ALREADY_CHECKED_IN);

        // è®°å½•ç­¾åˆ°
        vector::push_back(&mut activity.participants, user_addr);

        // å‘å°„äº‹ä»¶
        event::emit_event(
            &mut activity.check_in_events,
            CheckInEvent {
                activity_id: activity.id,
                user: user_addr,
                check_in_time: now,
                total_participants: vector::length(&activity.participants)
            }
        );
    }

    #[view]
    public fun get_participant_count(activity_addr: address): u64 acquires Activity {
        let activity = borrow_global<Activity>(activity_addr);
        vector::length(&activity.participants)
    }

    #[view]
    public fun has_checked_in(activity_addr: address, user: address): bool acquires Activity {
        let activity = borrow_global<Activity>(activity_addr);
        vector::contains(&activity.participants, &user)
    }
}
```

**è¯„åˆ†ç‚¹**ï¼š
- âœ… åˆå§‹åŒ–æ­£ç¡®ï¼ˆ3åˆ†ï¼‰
- âœ… æ—¶é—´æ£€æŸ¥ï¼ˆ2åˆ†ï¼‰
- âœ… é‡å¤ç­¾åˆ°æ£€æŸ¥ï¼ˆ2åˆ†ï¼‰
- âœ… äº‹ä»¶å‘å°„ï¼ˆ3åˆ†ï¼‰
- âœ… æŸ¥è¯¢åŠŸèƒ½ï¼ˆ3åˆ†ï¼‰
- âœ… é”™è¯¯å¤„ç†ï¼ˆ2åˆ†ï¼‰

---

### ç¬¬äºŒé¢˜ï¼šæŠ•ç¥¨ç³»ç»Ÿï¼ˆ20 åˆ†ï¼‰

```move
module day08_exam::voting {
    use std::signer;
    use std::vector;
    use aptos_framework::event;
    use aptos_framework::timestamp;

    const E_POLL_ENDED: u64 = 1;
    const E_ALREADY_VOTED: u64 = 2;
    const E_INVALID_CHOICE: u64 = 3;
    const E_POLL_NOT_ENDED: u64 = 4;

    struct PollCreatedEvent has drop, store {
        poll_id: u64,
        creator: address,
        title: vector<u8>,
        options_count: u64,
        end_time: u64,
        timestamp: u64
    }

    struct VoteCastEvent has drop, store {
        poll_id: u64,
        voter: address,
        choice: u64,
        total_votes: u64,
        timestamp: u64
    }

    struct PollEndedEvent has drop, store {
        poll_id: u64,
        total_votes: u64,
        winning_option: u64,
        winning_votes: u64,
        timestamp: u64
    }

    struct Poll has key {
        id: u64,
        creator: address,
        title: vector<u8>,
        options: vector<vector<u8>>,
        votes: vector<u64>,
        voters: vector<address>,
        end_time: u64,
        is_ended: bool,
        creation_events: event::EventHandle<PollCreatedEvent>,
        vote_events: event::EventHandle<VoteCastEvent>,
        end_events: event::EventHandle<PollEndedEvent>
    }

    public entry fun create_poll(
        creator: &signer,
        id: u64,
        title: vector<u8>,
        options: vector<vector<u8>>,
        end_time: u64
    ) {
        let options_count = vector::length(&options);
        let votes = vector::empty<u64>();
        let i = 0;
        while (i < options_count) {
            vector::push_back(&mut votes, 0);
            i = i + 1;
        };

        let creator_addr = signer::address_of(creator);
        let poll = Poll {
            id,
            creator: creator_addr,
            title,
            options,
            votes,
            voters: vector::empty(),
            end_time,
            is_ended: false,
            creation_events: event::new_event_handle<PollCreatedEvent>(creator),
            vote_events: event::new_event_handle<VoteCastEvent>(creator),
            end_events: event::new_event_handle<PollEndedEvent>(creator)
        };

        event::emit_event(
            &mut poll.creation_events,
            PollCreatedEvent {
                poll_id: id,
                creator: creator_addr,
                title,
                options_count,
                end_time,
                timestamp: timestamp::now_seconds()
            }
        );

        move_to(creator, poll);
    }

    public entry fun cast_vote(
        voter: &signer,
        poll_addr: address,
        choice: u64
    ) acquires Poll {
        let poll = borrow_global_mut<Poll>(poll_addr);
        let now = timestamp::now_seconds();
        let voter_addr = signer::address_of(voter);

        // æ£€æŸ¥æŠ•ç¥¨æ˜¯å¦ç»“æŸ
        assert!(!poll.is_ended && now <= poll.end_time, E_POLL_ENDED);

        // æ£€æŸ¥æ˜¯å¦å·²æŠ•ç¥¨
        assert!(!vector::contains(&poll.voters, &voter_addr), E_ALREADY_VOTED);

        // æ£€æŸ¥é€‰é¡¹æœ‰æ•ˆæ€§
        assert!(choice < vector::length(&poll.options), E_INVALID_CHOICE);

        // è®°å½•æŠ•ç¥¨
        *vector::borrow_mut(&mut poll.votes, choice) = 
            *vector::borrow(&poll.votes, choice) + 1;
        vector::push_back(&mut poll.voters, voter_addr);

        // å‘å°„äº‹ä»¶
        event::emit_event(
            &mut poll.vote_events,
            VoteCastEvent {
                poll_id: poll.id,
                voter: voter_addr,
                choice,
                total_votes: vector::length(&poll.voters),
                timestamp: now
            }
        );
    }

    public entry fun end_poll(poll_addr: address) acquires Poll {
        let poll = borrow_global_mut<Poll>(poll_addr);
        let now = timestamp::now_seconds();

        assert!(now > poll.end_time, E_POLL_NOT_ENDED);
        assert!(!poll.is_ended, E_POLL_ENDED);

        poll.is_ended = true;

        // æ‰¾å‡ºè·èƒœé€‰é¡¹
        let winning_option = 0u64;
        let winning_votes = 0u64;
        let i = 0;
        let len = vector::length(&poll.votes);
        while (i < len) {
            let votes = *vector::borrow(&poll.votes, i);
            if (votes > winning_votes) {
                winning_votes = votes;
                winning_option = i;
            };
            i = i + 1;
        };

        // å‘å°„äº‹ä»¶
        event::emit_event(
            &mut poll.end_events,
            PollEndedEvent {
                poll_id: poll.id,
                total_votes: vector::length(&poll.voters),
                winning_option,
                winning_votes,
                timestamp: now
            }
        );
    }

    #[view]
    public fun get_results(poll_addr: address): vector<u64> acquires Poll {
        let poll = borrow_global<Poll>(poll_addr);
        poll.votes
    }

    #[view]
    public fun is_poll_ended(poll_addr: address): bool acquires Poll {
        let poll = borrow_global<Poll>(poll_addr);
        poll.is_ended
    }
}
```

**è¯„åˆ†ç‚¹**ï¼š
- âœ… åˆ›å»ºæŠ•ç¥¨æ­£ç¡®ï¼ˆ5åˆ†ï¼‰
- âœ… æŠ•ç¥¨éªŒè¯å®Œæ•´ï¼ˆ5åˆ†ï¼‰
- âœ… ç»“æŸæŠ•ç¥¨å’Œç»Ÿè®¡ï¼ˆ4åˆ†ï¼‰
- âœ… äº‹ä»¶å‘å°„ï¼ˆ4åˆ†ï¼‰
- âœ… æŸ¥è¯¢åŠŸèƒ½ï¼ˆ2åˆ†ï¼‰

---

### ç¬¬ä¸‰é¢˜ï¼šä»£å¸è´¨æŠ¼ç³»ç»Ÿï¼ˆ25 åˆ†ï¼‰

```move
module day08_exam::staking {
    use std::signer;
    use aptos_framework::event;
    use aptos_framework::timestamp;

    const E_INSUFFICIENT_STAKE: u64 = 1;
    const E_MIN_DURATION_NOT_MET: u64 = 2;
    const E_NO_STAKE: u64 = 3;
    const E_NO_REWARD: u64 = 4;

    struct StakeEvent has drop, store {
        user: address,
        amount: u64,
        total_staked: u64,
        pool_total: u64,
        timestamp: u64
    }

    struct UnstakeEvent has drop, store {
        user: address,
        principal: u64,
        reward: u64,
        total_staked: u64,
        pool_total: u64,
        timestamp: u64
    }

    struct ClaimRewardEvent has drop, store {
        user: address,
        reward: u64,
        total_claimed: u64,
        timestamp: u64
    }

    struct StakingPool has key {
        total_staked: u64,
        reward_rate: u64,
        min_stake_duration: u64,
        stake_events: event::EventHandle<StakeEvent>,
        unstake_events: event::EventHandle<UnstakeEvent>,
        claim_events: event::EventHandle<ClaimRewardEvent>
    }

    struct UserStake has key {
        amount: u64,
        staked_at: u64,
        last_claim_at: u64,
        total_claimed: u64
    }

    public entry fun initialize_pool(
        admin: &signer,
        reward_rate: u64,
        min_stake_duration: u64
    ) {
        move_to(admin, StakingPool {
            total_staked: 0,
            reward_rate,
            min_stake_duration,
            stake_events: event::new_event_handle<StakeEvent>(admin),
            unstake_events: event::new_event_handle<UnstakeEvent>(admin),
            claim_events: event::new_event_handle<ClaimRewardEvent>(admin)
        });
    }

    public entry fun stake(user: &signer, amount: u64) acquires StakingPool, UserStake {
        let user_addr = signer::address_of(user);
        let pool = borrow_global_mut<StakingPool>(@day08_exam);
        let now = timestamp::now_seconds();

        if (!exists<UserStake>(user_addr)) {
            move_to(user, UserStake {
                amount: 0,
                staked_at: now,
                last_claim_at: now,
                total_claimed: 0
            });
        };

        let user_stake = borrow_global_mut<UserStake>(user_addr);
        user_stake.amount = user_stake.amount + amount;
        if (user_stake.staked_at == 0) {
            user_stake.staked_at = now;
            user_stake.last_claim_at = now;
        };

        pool.total_staked = pool.total_staked + amount;

        event::emit_event(
            &mut pool.stake_events,
            StakeEvent {
                user: user_addr,
                amount,
                total_staked: user_stake.amount,
                pool_total: pool.total_staked,
                timestamp: now
            }
        );
    }

    public entry fun unstake(user: &signer, amount: u64) acquires StakingPool, UserStake {
        let user_addr = signer::address_of(user);
        let pool = borrow_global_mut<StakingPool>(@day08_exam);
        let user_stake = borrow_global_mut<UserStake>(user_addr);
        let now = timestamp::now_seconds();

        assert!(user_stake.amount >= amount, E_INSUFFICIENT_STAKE);
        assert!(now - user_stake.staked_at >= pool.min_stake_duration, E_MIN_DURATION_NOT_MET);

        // è®¡ç®—å¥–åŠ±
        let reward = calculate_pending_reward(
            user_stake.amount,
            user_stake.staked_at,
            user_stake.last_claim_at,
            pool.reward_rate
        );

        user_stake.amount = user_stake.amount - amount;
        user_stake.last_claim_at = now;
        user_stake.total_claimed = user_stake.total_claimed + reward;
        pool.total_staked = pool.total_staked - amount;

        event::emit_event(
            &mut pool.unstake_events,
            UnstakeEvent {
                user: user_addr,
                principal: amount,
                reward,
                total_staked: user_stake.amount,
                pool_total: pool.total_staked,
                timestamp: now
            }
        );
    }

    public entry fun claim_reward(user: &signer) acquires StakingPool, UserStake {
        let user_addr = signer::address_of(user);
        let pool = borrow_global_mut<StakingPool>(@day08_exam);
        let user_stake = borrow_global_mut<UserStake>(user_addr);
        let now = timestamp::now_seconds();

        let reward = calculate_pending_reward(
            user_stake.amount,
            user_stake.staked_at,
            user_stake.last_claim_at,
            pool.reward_rate
        );

        assert!(reward > 0, E_NO_REWARD);

        user_stake.last_claim_at = now;
        user_stake.total_claimed = user_stake.total_claimed + reward;

        event::emit_event(
            &mut pool.claim_events,
            ClaimRewardEvent {
                user: user_addr,
                reward,
                total_claimed: user_stake.total_claimed,
                timestamp: now
            }
        );
    }

    fun calculate_pending_reward(
        amount: u64,
        _staked_at: u64,
        last_claim_at: u64,
        reward_rate: u64
    ): u64 {
        let now = timestamp::now_seconds();
        let duration = now - last_claim_at;
        (amount * duration * reward_rate) / 1000000
    }

    #[view]
    public fun get_user_stake(user: address): (u64, u64, u64) acquires UserStake {
        if (!exists<UserStake>(user)) {
            return (0, 0, 0)
        };
        let stake = borrow_global<UserStake>(user);
        (stake.amount, stake.staked_at, stake.total_claimed)
    }

    #[view]
    public fun get_pending_reward(user: address): u64 acquires StakingPool, UserStake {
        if (!exists<UserStake>(user)) {
            return 0
        };
        let pool = borrow_global<StakingPool>(@day08_exam);
        let stake = borrow_global<UserStake>(user);
        calculate_pending_reward(
            stake.amount,
            stake.staked_at,
            stake.last_claim_at,
            pool.reward_rate
        )
    }

    #[view]
    public fun get_pool_total(): u64 acquires StakingPool {
        let pool = borrow_global<StakingPool>(@day08_exam);
        pool.total_staked
    }
}
```

**è¯„åˆ†ç‚¹**ï¼š
- âœ… è´¨æŠ¼åŠŸèƒ½ï¼ˆ6åˆ†ï¼‰
- âœ… è§£æŠ¼åŠŸèƒ½å’Œæ—¶é—´æ£€æŸ¥ï¼ˆ6åˆ†ï¼‰
- âœ… å¥–åŠ±è®¡ç®—ï¼ˆ5åˆ†ï¼‰
- âœ… äº‹ä»¶å‘å°„ï¼ˆ5åˆ†ï¼‰
- âœ… æŸ¥è¯¢åŠŸèƒ½ï¼ˆ3åˆ†ï¼‰

---

## æ€»åˆ†ç»Ÿè®¡

### é€‰æ‹©é¢˜ï¼ˆ40 åˆ†ï¼‰
å¯¹ç…§ç­”æ¡ˆè®¡ç®—ä½ çš„å¾—åˆ†ã€‚

### ç¼–ç¨‹é¢˜ï¼ˆ60 åˆ†ï¼‰
æ ¹æ®è¯„åˆ†æ ‡å‡†è‡ªè¡Œè¯„ä¼°ã€‚

### æ€»åˆ†ï¼ˆ100 åˆ†ï¼‰

**è¯„çº§æ ‡å‡†**ï¼š
- **90-100 åˆ†**ï¼šä¼˜ç§€ï¼å®Œå…¨æŒæ¡äº‹ä»¶ç³»ç»Ÿ
- **80-89 åˆ†**ï¼šè‰¯å¥½ï¼ç†è§£é€å½»
- **70-79 åˆ†**ï¼šåŠæ ¼ï¼ç»§ç»­åŠ æ²¹
- **< 70 åˆ†**ï¼šéœ€è¦é‡æ–°å­¦ä¹ å¹¶å®Œæˆå®è·µä»»åŠ¡

---

**æ­å–œå®Œæˆ Day 08 çš„è€ƒè¯•ï¼ç»§ç»­åŠ æ²¹ï¼** ğŸ‰

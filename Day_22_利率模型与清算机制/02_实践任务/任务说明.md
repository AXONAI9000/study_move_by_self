# 实践任务说明

## 📋 任务概览

今天的实践任务将带你实现一个**完整的利率模型和清算机制**。你将分步骤完成：

1. **实现线性利率模型**
2. **实现跳跃利率模型**
3. **实现利息累积机制**
4. **实现清算检查功能**
5. **实现清算执行逻辑**

## 🎯 学习目标

完成本任务后，你将能够：

- ✅ 实现和测试不同类型的利率模型
- ✅ 理解利息指数的累积机制
- ✅ 实现健康因子计算
- ✅ 实现完整的清算流程
- ✅ 处理各种边界情况和错误

## ⏰ 预计时间

- **总时间**: 4 小时
- **任务 1**: 45 分钟
- **任务 2**: 60 分钟
- **任务 3**: 45 分钟
- **任务 4**: 45 分钟
- **任务 5**: 45 分钟

---

## 📝 任务详情

### 任务 1: 实现线性利率模型（45分钟）

#### 目标
实现一个简单的线性利率模型，利率随使用率线性增长。

#### 要求

1. **实现利率计算函数**
   ```move
   public fun calculate_linear_borrow_rate(
       base_rate: u128,
       slope: u128,
       utilization: u128
   ): u128
   ```

2. **实现存款利率计算**
   ```move
   public fun calculate_linear_supply_rate(
       borrow_rate: u128,
       utilization: u128,
       reserve_factor: u128
   ): u128
   ```

3. **测试不同使用率下的利率**
   - 测试使用率 0%、25%、50%、75%、100%
   - 验证利率的线性增长
   - 验证存款利率 < 借款利率

#### 验收标准

- [ ] 使用率 0% 时，利率等于基础利率
- [ ] 使用率 100% 时，利率等于基础利率 + 斜率
- [ ] 存款利率正确计算（考虑储备金率）
- [ ] 所有测试用例通过

#### 示例参数

```
基础利率: 2% (0.02 × 10^18)
斜率: 10% (0.10 × 10^18)
储备金率: 10% (0.10 × 10^18)

预期结果:
使用率 0%:   借款利率 = 2%,   存款利率 = 0%
使用率 50%:  借款利率 = 7%,   存款利率 = 3.15%
使用率 100%: 借款利率 = 12%,  存款利率 = 10.8%
```

---

### 任务 2: 实现跳跃利率模型（60分钟）

#### 目标
实现跳跃利率模型，在最优使用率处发生利率跳跃。

#### 要求

1. **实现分段利率计算**
   ```move
   public fun calculate_kinked_borrow_rate(
       base_rate: u128,
       optimal_utilization: u128,
       slope_1: u128,
       slope_2: u128,
       utilization: u128
   ): u128
   ```

2. **处理两个阶段**
   - 阶段 1: U ≤ U_optimal（正常范围）
   - 阶段 2: U > U_optimal（高使用率）

3. **测试跳跃点的行为**
   - 测试最优使用率前后的利率
   - 验证跳跃的正确性
   - 测试极端使用率

#### 验收标准

- [ ] 最优使用率之前利率缓慢增长
- [ ] 超过最优使用率后利率快速增长
- [ ] 跳跃点连续（无断点）
- [ ] 使用率 100% 时利率正确

#### 示例参数

```
基础利率: 0%
最优使用率: 80%
斜率 1: 4%
斜率 2: 60%
储备金率: 10%

预期结果:
使用率 0%:   借款利率 = 0%,   存款利率 = 0%
使用率 40%:  借款利率 = 2%,   存款利率 = 0.72%
使用率 80%:  借款利率 = 4%,   存款利率 = 2.88%
使用率 90%:  借款利率 = 34%,  存款利率 = 27.54%
使用率 100%: 借款利率 = 64%,  存款利率 = 57.6%
```

---

### 任务 3: 实现利息累积机制（45分钟）

#### 目标
实现利息指数的累积和用户余额计算。

#### 要求

1. **实现利息指数更新**
   ```move
   public fun update_borrow_index(
       old_index: u128,
       borrow_rate: u128,
       time_delta: u64
   ): u128
   ```

2. **实现用户借款余额计算**
   ```move
   public fun calculate_borrow_balance(
       principal: u128,
       user_index: u128,
       current_index: u128
   ): u128
   ```

3. **测试利息累积**
   - 测试不同时间间隔的累积
   - 验证复利效应
   - 测试精度处理

#### 验收标准

- [ ] 指数随时间正确增长
- [ ] 用户余额正确反映利息
- [ ] 精度误差在可接受范围内
- [ ] 边界情况（0利率、0时间）正确处理

#### 测试场景

```
场景 1: 短期借款
初始本金: 1000 USDC
借款利率: 10% APR
时间: 10 天
预期利息: ≈ 2.74 USDC

场景 2: 长期借款
初始本金: 10000 USDC
借款利率: 15% APR
时间: 365 天
预期利息: ≈ 1500 USDC
```

---

### 任务 4: 实现清算检查功能（45分钟）

#### 目标
实现健康因子计算和清算资格检查。

#### 要求

1. **实现健康因子计算**
   ```move
   public fun calculate_health_factor(
       collateral_value: u128,
       collateral_factor: u128,
       debt_value: u128
   ): u128
   ```

2. **实现清算资格检查**
   ```move
   public fun can_liquidate(
       health_factor: u128,
       min_health_factor: u128
   ): bool
   ```

3. **实现清算金额计算**
   ```move
   public fun calculate_max_liquidation(
       total_debt: u128,
       close_factor: u128
   ): u128
   ```

#### 验收标准

- [ ] 健康因子 < 1.0 可被清算
- [ ] 健康因子 ≥ 1.0 不可清算
- [ ] 无债务时健康因子为无穷大
- [ ] 清算金额不超过 close_factor 限制

#### 测试场景

```
场景 1: 健康头寸
抵押品: 1 ETH = $2000, 抵押率 75%
债务: 1000 USDC
HF = ($2000 × 75%) / $1000 = 1.5
结果: 不可清算

场景 2: 不健康头寸
抵押品: 1 ETH = $1600, 抵押率 75%
债务: 1300 USDC
HF = ($1600 × 75%) / $1300 = 0.923
结果: 可清算，最大清算 50% = 650 USDC
```

---

### 任务 5: 实现清算执行逻辑（45分钟）

#### 目标
实现完整的清算流程，包括债务偿还和抵押品转移。

#### 要求

1. **实现清算奖励计算**
   ```move
   public fun calculate_collateral_to_seize(
       repay_amount: u128,
       repay_price: u128,
       collateral_price: u128,
       liquidation_incentive: u128
   ): u128
   ```

2. **实现清算执行**
   ```move
   public fun execute_liquidation(
       borrower: &mut UserAccount,
       liquidator: &mut UserAccount,
       repay_amount: u128,
       collateral_to_seize: u128
   )
   ```

3. **验证清算后状态**
   - 借款人债务减少
   - 借款人抵押品减少
   - 清算人获得抵押品
   - 健康因子改善

#### 验收标准

- [ ] 清算奖励正确计算
- [ ] 抵押品转移正确
- [ ] 债务减少正确
- [ ] 清算后健康因子 > 清算前

#### 测试场景

```
场景: 典型清算
借款人:
  抵押品: 2 ETH ($3200), 抵押率 75%
  债务: 2600 USDC
  HF = ($3200 × 75%) / $2600 = 0.923

清算执行:
  偿还: 1300 USDC (50%)
  清算奖励: 10%
  获得抵押品: (1300 × 1.10) / 1600 = 0.89375 ETH

清算后:
  债务: 1300 USDC
  抵押品: 1.10625 ETH ($1770)
  HF = ($1770 × 75%) / $1300 = 1.021 ✅
```

---

## 🗂️ 文件结构

在 `你的答案/` 文件夹中创建以下文件：

```
你的答案/
├── interest_rate_model.move      # 任务 1-3: 利率模型实现
└── liquidation_engine.move       # 任务 4-5: 清算机制实现
```

---

## 🔧 实现建议

### 精度处理

```move
// 使用 18 位精度
const PRECISION: u128 = 1_000_000_000_000_000_000; // 1e18

// 乘法后除以精度
let result = (a * b) / PRECISION;

// 注意溢出：先除后乘（如果可能）
let result = (a / PRECISION) * b; // 但可能损失精度
```

### 时间处理

```move
// 将年化利率转换为每秒利率
const SECONDS_PER_YEAR: u128 = 31_536_000;
let per_second_rate = annual_rate / SECONDS_PER_YEAR;

// 计算时间间隔
let time_delta = current_time - last_update_time;
```

### 边界情况

```move
// 除零保护
if (denominator == 0) {
    return 0 // 或返回特殊值
};

// 无穷大健康因子
if (debt == 0) {
    return MAX_U128 // 表示无穷大
};

// 溢出检查
assert!(a <= MAX_U128 / b, ERROR_OVERFLOW);
```

---

## ✅ 验收清单

### 代码质量

- [ ] 代码编译通过，无错误
- [ ] 所有函数都有注释说明
- [ ] 变量命名清晰易懂
- [ ] 精度处理正确
- [ ] 边界情况处理完善

### 功能完整性

- [ ] 任务 1: 线性利率模型 ✅
- [ ] 任务 2: 跳跃利率模型 ✅
- [ ] 任务 3: 利息累积机制 ✅
- [ ] 任务 4: 清算检查功能 ✅
- [ ] 任务 5: 清算执行逻辑 ✅

### 测试覆盖

- [ ] 正常情况测试通过
- [ ] 边界情况测试通过
- [ ] 极端情况测试通过
- [ ] 精度误差在可接受范围

---

## 🎓 学习资源

### 参考实现
- 查看 `01_理论学习/代码示例.move`
- 参考 Compound、Aave 的开源代码

### 调试技巧
1. 使用 `assert!` 验证中间结果
2. 打印关键变量的值（测试环境）
3. 单步调试每个计算步骤
4. 手动计算验证结果

### 常见问题

**Q: 精度丢失怎么办？**  
A: 先乘后除，使用足够大的精度（1e18）

**Q: 利率计算结果不对？**  
A: 检查是否正确使用年化利率和每秒利率

**Q: 清算金额超过债务？**  
A: 确保应用了 close_factor 限制

**Q: 健康因子计算错误？**  
A: 验证价格精度和抵押率精度是否一致

---

## 💡 提示

1. **从简单到复杂**: 先实现线性模型，再实现跳跃模型
2. **测试驱动**: 每完成一个函数就立即测试
3. **参考示例**: 遇到问题参考代码示例
4. **精度第一**: 精度处理是最容易出错的地方
5. **边界保护**: 不要忘记处理除零、溢出等情况

---

## 🚀 开始实现

准备好了吗？打开你的编辑器，开始编写代码吧！

**记住**：
- 慢就是快，确保每一步都正确
- 测试是你的朋友
- 遇到问题回顾理论部分

**祝你实现顺利！** 💪

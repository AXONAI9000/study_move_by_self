# Day 04: ç»“æ„ä½“ä¸èµ„æºæ¦‚å¿µ - ç­”æ¡ˆè§£æ

## ğŸ“š é€‰æ‹©é¢˜ç­”æ¡ˆè¯¦è§£

### åŸºç¡€æ¦‚å¿µï¼ˆ1-10é¢˜ï¼‰

**1. B - ç»„ç»‡ç›¸å…³æ•°æ®å½¢æˆè‡ªå®šä¹‰ç±»å‹**
- ç»“æ„ä½“æ˜¯ Move ä¸­åˆ›å»ºè‡ªå®šä¹‰å¤åˆç±»å‹çš„æ–¹å¼
- å¯ä»¥åŒ…å«ä»»ä½•ç±»å‹çš„å­—æ®µï¼Œä¸é™äºæ•°å­—
- è¿™æ˜¯é¢å‘å¯¹è±¡ç¼–ç¨‹ä¸­ç±»çš„ç®€åŒ–ç‰ˆæœ¬

**2. C - copy**
- `copy` èƒ½åŠ›å…è®¸å€¼åœ¨èµ‹å€¼æ—¶è¢«å¤åˆ¶
- æ²¡æœ‰ `copy` èƒ½åŠ›çš„ç±»å‹åªèƒ½ç§»åŠ¨
- è¿™æ˜¯ Move èµ„æºå®‰å…¨æ€§çš„åŸºç¡€

**3. B - ä½œä¸ºå…¨å±€å­˜å‚¨çš„é¡¶å±‚èµ„æº**
- `key` èƒ½åŠ›ä½¿ç»“æ„ä½“å¯ä»¥ç”¨ä½œå…¨å±€å­˜å‚¨çš„é”®
- é€šå¸¸ä¸ `move_to` é…åˆä½¿ç”¨
- æ²¡æœ‰ `key` çš„ç±»å‹ä¸èƒ½ç›´æ¥å­˜å‚¨åœ¨è´¦æˆ·ä¸‹

**4. B - struct Point { x: u64, y: u64 }**
- ç»“æ„ä½“å®šä¹‰éœ€è¦ä½¿ç”¨å¤§æ‹¬å· `{}`
- æ¯ä¸ªå­—æ®µå¿…é¡»æœ‰ç±»å‹æ³¨è§£
- å­—æ®µä¹‹é—´ç”¨é€—å·åˆ†éš”

**5. C - å¯ä»¥éšæ„åˆ›å»º**
- èµ„æºçš„åˆ›å»ºå¿…é¡»ç”±æ¨¡å—æ§åˆ¶
- è¿™ä¿è¯äº†èµ„æºçš„ç¨€ç¼ºæ€§å’Œä»·å€¼
- é˜²æ­¢èµ„äº§è¢«ä»»æ„å¢å‘

**6. B - key, store**
- `key` å…è®¸ä½œä¸ºé¡¶å±‚èµ„æºå­˜å‚¨
- `store` å…è®¸è¢«å…¶ä»–ç»“æ„ä½“åŒ…å«
- ä¸èƒ½æœ‰ `copy` å’Œ `drop`ï¼Œä¿è¯èµ„äº§å”¯ä¸€æ€§

**7. C - æ²¡æœ‰ä»»ä½•èƒ½åŠ›**
- çƒ­åœŸè±†æ²¡æœ‰ `drop` èƒ½åŠ›ï¼Œä¸èƒ½è¢«å¿½ç•¥
- å¿…é¡»æ˜¾å¼å¤„ç†ï¼Œå¼ºåˆ¶å®ŒæˆæŸä¸ªæµç¨‹
- å¸¸ç”¨äºç¡®ä¿æ“ä½œå®Œæ•´æ€§

**8. B - let Point { x, y } = point**
- å¿…é¡»ä½¿ç”¨ç»“æ„ä½“åç§°
- ä½¿ç”¨å¤§æ‹¬å·è§£æ„
- å¯ä»¥æå–éƒ¨åˆ†æˆ–å…¨éƒ¨å­—æ®µ

**9. B - åˆ›å»ºå‰¯æœ¬**
- åªæœ‰å…·æœ‰ `copy` èƒ½åŠ›çš„ç±»å‹æ‰èƒ½å¤åˆ¶
- èµ‹å€¼æ—¶ä¼šåˆ›å»ºæ–°çš„å‰¯æœ¬
- ç§»åŠ¨å’Œå€Ÿç”¨ä¸éœ€è¦ `copy`

**10. B - å¤–éƒ¨ç»“æ„ä½“çš„èƒ½åŠ›ä¸èƒ½è¶…è¿‡å†…éƒ¨å­—æ®µçš„èƒ½åŠ›**
- èƒ½åŠ›æ˜¯çº¦æŸæ€§çš„ï¼Œä¼šå‘ä¸Šä¼ æ’­
- å¦‚æœå­—æ®µä¸å¯å¤åˆ¶ï¼ŒåŒ…å«å®ƒçš„ç»“æ„ä½“ä¹Ÿä¸èƒ½å¤åˆ¶
- è¿™ä¿è¯äº†ç±»å‹ç³»ç»Ÿçš„ä¸€è‡´æ€§

---

### èµ„æºç®¡ç†ï¼ˆ11-20é¢˜ï¼‰

**11. B - å°†èµ„æºç§»åŠ¨åˆ°å…¨å±€å­˜å‚¨**
- `move_to` æ˜¯å‘å¸ƒèµ„æºçš„å”¯ä¸€æ–¹å¼
- èµ„æºä¼šå…³è”åˆ°æŒ‡å®šçš„åœ°å€
- æ¯ä¸ªåœ°å€åªèƒ½å­˜å‚¨ä¸€ä¸ªç›¸åŒç±»å‹çš„èµ„æº

**12. B - borrow_global_mut**
- `borrow_global` è¿”å›ä¸å¯å˜å¼•ç”¨
- `borrow_global_mut` è¿”å›å¯å˜å¼•ç”¨
- éœ€è¦åœ¨å‡½æ•°ç­¾åä¸­æ ‡æ³¨ `acquires`

**13. A - å£°æ˜å‡½æ•°ä¼šè®¿é—®å…¨å±€èµ„æº**
- å€Ÿç”¨æ£€æŸ¥å™¨éœ€è¦çŸ¥é“å“ªäº›èµ„æºä¼šè¢«è®¿é—®
- é˜²æ­¢èµ„æºè®¿é—®å†²çª
- æ˜¯ç¼–è¯‘æ—¶çš„å£°æ˜ï¼Œä¸æ˜¯è¿è¡Œæ—¶æ“ä½œ

**14. B - exists**
- `exists<T>(addr)` æ£€æŸ¥èµ„æºæ˜¯å¦å­˜åœ¨
- è¿”å›å¸ƒå°”å€¼
- å¸¸ç”¨äºè®¿é—®èµ„æºå‰çš„éªŒè¯

**15. C - ä»å…¨å±€å­˜å‚¨ä¸­ç§»å‡ºèµ„æº**
- `move_from` ç§»å‡ºå¹¶è·å¾—æ‰€æœ‰æƒ
- èµ„æºä»å…¨å±€å­˜å‚¨ä¸­åˆ é™¤
- å¿…é¡»æ˜¾å¼é”€æ¯æˆ–é‡æ–°å­˜å‚¨

**16. C - è§£æ„èµ„æº**
- ä½¿ç”¨æ¨¡å¼åŒ¹é…è§£æ„
- ä¾‹å¦‚ï¼š`let Coin { value } = coin;`
- è¿™æ˜¯é”€æ¯æ²¡æœ‰ `drop` èƒ½åŠ›ç±»å‹çš„å”¯ä¸€æ–¹å¼

**17. B - æœ€å¤šä¸€ä¸ª**
- æ¯ä¸ªåœ°å€åªèƒ½å­˜å‚¨ä¸€ä¸ªç‰¹å®šç±»å‹çš„èµ„æº
- è¿™æ˜¯ Move çš„è®¾è®¡çº¦æŸ
- ç¡®ä¿äº†èµ„æºçš„å”¯ä¸€æ€§

**18. B - èµ„æºçš„ä¸å¯å˜å¼•ç”¨**
- è¿”å› `&T` ç±»å‹
- å¯ä»¥è¯»å–ä½†ä¸èƒ½ä¿®æ”¹
- å¤šä¸ªä¸å¯å˜å¼•ç”¨å¯ä»¥å…±å­˜

**19. C - è¿è¡Œæ—¶é”™è¯¯**
- ä¼šè§¦å‘ `RESOURCE_ALREADY_EXISTS` é”™è¯¯
- ä½¿ç”¨ `exists` æ£€æŸ¥å¯ä»¥é¿å…
- æ˜¯å¸¸è§çš„ç¼–ç¨‹é”™è¯¯

**20. B - ç¼–è¯‘é”™è¯¯**
- ç¼–è¯‘å™¨ä¼šå¼ºåˆ¶è¦æ±‚æ ‡æ³¨
- è¿™æ˜¯ Move çš„å®‰å…¨ä¿è¯
- å¸®åŠ©å¼€å‘è€…é¿å…èµ„æºè®¿é—®å†²çª

---

### èƒ½åŠ›ç³»ç»Ÿï¼ˆ21-30é¢˜ï¼‰

**21. B - åœ¨ä½œç”¨åŸŸç»“æŸæ—¶è‡ªåŠ¨é”€æ¯**
- å…·æœ‰ `drop` çš„å€¼å¯ä»¥è¢«ä¸¢å¼ƒ
- ä¸éœ€è¦æ˜¾å¼å¤„ç†
- ç±»ä¼¼äºå…¶ä»–è¯­è¨€çš„è‡ªåŠ¨åƒåœ¾å›æ”¶

**22. A - æ˜¾å¼é”€æ¯æˆ–è½¬ç§»**
- å¿…é¡»ä½¿ç”¨è§£æ„æˆ–ç§»åŠ¨
- ç¼–è¯‘å™¨ä¼šæ£€æŸ¥ç¡®ä¿å¤„ç†
- è¿™ä¿è¯äº†é‡è¦èµ„æºä¸ä¼šè¢«æ„å¤–ä¸¢å¼ƒ

**23. B - å­˜å‚¨åœ¨å…¶ä»–ç»“æ„ä½“ä¸­**
- `store` å…è®¸ä½œä¸ºå­—æ®µ
- ä¸ `key` ä¸åŒï¼Œä¸èƒ½ä½œä¸ºé¡¶å±‚èµ„æº
- æ˜¯ç»„åˆç»“æ„ä½“çš„å¿…è¦æ¡ä»¶

**24. C - key**
- `key` æ˜¯ä½œä¸ºé¡¶å±‚èµ„æºçš„å¿…è¦æ¡ä»¶
- é€šå¸¸è¿˜ä¼šæœ‰ `store`
- ä½† `copy` å’Œ `drop` é€šå¸¸ä¸éœ€è¦

**25. D - æ²¡æœ‰çŸ›ç›¾çš„ç»„åˆ**
- èƒ½åŠ›å¯ä»¥è‡ªç”±ç»„åˆ
- æ¯ç§ç»„åˆéƒ½æœ‰å…¶ç”¨é€”
- æ ¹æ®éœ€æ±‚é€‰æ‹©åˆé€‚çš„èƒ½åŠ›

**26. B - copy, drop, store**
- åŸå§‹ç±»å‹é»˜è®¤å¯å¤åˆ¶ã€å¯ä¸¢å¼ƒã€å¯å­˜å‚¨
- ä½†ä¸èƒ½ä½œä¸ºé¡¶å±‚èµ„æºï¼ˆæ²¡æœ‰ `key`ï¼‰
- è¿™ä½¿å®ƒä»¬æ˜“äºä½¿ç”¨

**27. B - ä¸èƒ½æœ‰ store èƒ½åŠ›**
- èƒ½åŠ›çº¦æŸä¼šä¼ æ’­
- åŒ…å«ä¸å¯å­˜å‚¨å­—æ®µçš„ç»“æ„ä½“ä¹Ÿä¸å¯å­˜å‚¨
- è¿™æ˜¯ç±»å‹ç³»ç»Ÿçš„ä¸€è‡´æ€§è¦æ±‚

**28. C - drop**
- Witness é€šå¸¸æ˜¯ç©ºç»“æ„ä½“
- ç”¨äºè¯æ˜æŸä¸ªæ“ä½œçš„æƒé™
- `drop` ä½¿å…¶æ˜“äºåˆ›å»ºå’Œä½¿ç”¨

**29. A - <T: copy>**
- ä½¿ç”¨å†’å· `:` æŒ‡å®šçº¦æŸ
- å¯ä»¥æŒ‡å®šå¤šä¸ªçº¦æŸï¼Œç”¨ `+` è¿æ¥
- ä¾‹å¦‚ï¼š`<T: copy + drop>`

**30. B - çƒ­åœŸè±†æ¨¡å¼**
- å¼ºåˆ¶å¿…é¡»å¤„ç†
- ç”¨äºç¡®ä¿æµç¨‹å®Œæ•´æ€§
- é˜²æ­¢æ“ä½œè¢«ä¸­é€”æ”¾å¼ƒ

---

### é«˜çº§æ¦‚å¿µï¼ˆ31-40é¢˜ï¼‰

**31. B - æ¨¡å—ç§æœ‰çš„**
- å­—æ®µé»˜è®¤åªåœ¨æ¨¡å—å†…å¯è§
- éœ€è¦æä¾› getter/setter å‡½æ•°è®¿é—®
- è¿™æ˜¯å°è£…çš„ä½“ç°

**32. C - company.address.city**
- ä½¿ç”¨ç‚¹å· `.` è®¿é—®åµŒå¥—å­—æ®µ
- å¯ä»¥é“¾å¼è®¿é—®å¤šå±‚
- è¯­æ³•ç›´è§‚æ˜“æ‡‚

**33. B - é”€æ¯æ²¡æœ‰ drop èƒ½åŠ›çš„ç»“æ„ä½“**
- è§£æ„æ˜¯å”¯ä¸€çš„é”€æ¯æ–¹å¼
- å¯ä»¥æå–æ‰€æœ‰å­—æ®µå€¼
- å¿…é¡»å¤„ç†æ‰€æœ‰å­—æ®µ

**34. A - _**
- ä¸‹åˆ’çº¿è¡¨ç¤ºå¿½ç•¥
- ä¾‹å¦‚ï¼š`let Point { x, y: _ } = point;`
- è¢«å¿½ç•¥çš„å€¼ä¼šè¢«ä¸¢å¼ƒï¼ˆå¦‚æœæœ‰ `drop`ï¼‰

**35. B - ç”±ç±»å‹å‚æ•°å’Œå­—æ®µå…±åŒå†³å®š**
- ç±»å‹å‚æ•°çš„èƒ½åŠ›çº¦æŸä¼šå½±å“ç»“æ„ä½“
- å­—æ®µçš„èƒ½åŠ›ä¹Ÿä¼šçº¦æŸç»“æ„ä½“
- æœ€ç»ˆèƒ½åŠ›æ˜¯æ‰€æœ‰çº¦æŸçš„äº¤é›†

**36. B - æ ‡è®°ç±»å‹å‚æ•°ä¸åœ¨å­—æ®µä¸­ä½¿ç”¨**
- `phantom` è¡¨ç¤ºç±»å‹å‚æ•°åªç”¨äºç±»å‹æ ‡è®°
- ä¸å½±å“ç»“æ„ä½“çš„èƒ½åŠ›
- å¸¸ç”¨äºç±»å‹çº§ç¼–ç¨‹

**37. C - éƒ½éœ€è¦æ ‡æ³¨ acquires**
- æ¯ä¸ªè®¿é—®èµ„æºçš„å‡½æ•°éƒ½éœ€è¦å£°æ˜
- è¿™æ˜¯ç¼–è¯‘å™¨çš„è¦æ±‚
- å¸®åŠ©è¿½è¸ªèµ„æºä½¿ç”¨

**38. B - ä¸ä¼šæœ‰æ•°æ®ç«äº‰**
- å€Ÿç”¨æ£€æŸ¥ç¡®ä¿å¼•ç”¨å®‰å…¨
- ä¸å¯å˜å¼•ç”¨å¯ä»¥å¤šä¸ª
- å¯å˜å¼•ç”¨åªèƒ½ä¸€ä¸ª

**39. B - ç±»å‹æ ‡è®°å’Œæ³›å‹å‚æ•°**
- ç©ºç»“æ„ä½“ä½œä¸ºç±»å‹åŒºåˆ†
- åœ¨æ³›å‹ç¼–ç¨‹ä¸­å¾ˆæœ‰ç”¨
- é›¶è¿è¡Œæ—¶å¼€é”€

**40. B - èµ„æºå¯ä»¥è¢«éšå¼å¤åˆ¶**
- èµ„æºç»ä¸èƒ½è¢«éšå¼å¤åˆ¶
- å¿…é¡»æ˜¾å¼ç§»åŠ¨æˆ–è½¬ç§»
- è¿™æ˜¯èµ„æºå®‰å…¨æ€§çš„æ ¸å¿ƒ

---

## ğŸ’» ç¼–ç¨‹é¢˜ç­”æ¡ˆ

### é¢˜ç›® 1ï¼šé“¶è¡Œè´¦æˆ·ç³»ç»Ÿ

```move
module day04_answers::bank_account {
    use std::signer;
    
    struct BankAccount has key {
        account_number: u64,
        owner: address,
        balance: u64,
        is_active: bool,
    }
    
    // é”™è¯¯ç 
    const E_ACCOUNT_EXISTS: u64 = 1;
    const E_ACCOUNT_NOT_EXISTS: u64 = 2;
    const E_INSUFFICIENT_BALANCE: u64 = 3;
    const E_ACCOUNT_FROZEN: u64 = 4;
    const E_UNAUTHORIZED: u64 = 5;
    
    // å¼€æˆ·
    public fun open_account(
        account: &signer,
        account_number: u64,
        initial_balance: u64
    ) {
        let addr = signer::address_of(account);
        assert!(!exists<BankAccount>(addr), E_ACCOUNT_EXISTS);
        
        let bank_account = BankAccount {
            account_number,
            owner: addr,
            balance: initial_balance,
            is_active: true,
        };
        
        move_to(account, bank_account);
    }
    
    // å­˜æ¬¾
    public fun deposit(addr: address, amount: u64) acquires BankAccount {
        assert!(exists<BankAccount>(addr), E_ACCOUNT_NOT_EXISTS);
        
        let account = borrow_global_mut<BankAccount>(addr);
        assert!(account.is_active, E_ACCOUNT_FROZEN);
        
        account.balance = account.balance + amount;
    }
    
    // å–æ¬¾
    public fun withdraw(account: &signer, amount: u64) acquires BankAccount {
        let addr = signer::address_of(account);
        assert!(exists<BankAccount>(addr), E_ACCOUNT_NOT_EXISTS);
        
        let bank_account = borrow_global_mut<BankAccount>(addr);
        assert!(bank_account.is_active, E_ACCOUNT_FROZEN);
        assert!(bank_account.balance >= amount, E_INSUFFICIENT_BALANCE);
        assert!(bank_account.owner == addr, E_UNAUTHORIZED);
        
        bank_account.balance = bank_account.balance - amount;
    }
    
    // æŸ¥è¯¢ä½™é¢
    public fun get_balance(addr: address): u64 acquires BankAccount {
        assert!(exists<BankAccount>(addr), E_ACCOUNT_NOT_EXISTS);
        borrow_global<BankAccount>(addr).balance
    }
    
    // å†»ç»“è´¦æˆ·
    public fun freeze_account(account: &signer) acquires BankAccount {
        let addr = signer::address_of(account);
        assert!(exists<BankAccount>(addr), E_ACCOUNT_NOT_EXISTS);
        
        let bank_account = borrow_global_mut<BankAccount>(addr);
        bank_account.is_active = false;
    }
    
    // è§£å†»è´¦æˆ·
    public fun unfreeze_account(account: &signer) acquires BankAccount {
        let addr = signer::address_of(account);
        assert!(exists<BankAccount>(addr), E_ACCOUNT_NOT_EXISTS);
        
        let bank_account = borrow_global_mut<BankAccount>(addr);
        bank_account.is_active = true;
    }
    
    #[test(user = @0x123)]
    public fun test_bank_account(user: &signer) acquires BankAccount {
        open_account(user, 1001, 1000);
        
        let addr = signer::address_of(user);
        assert!(get_balance(addr) == 1000, 0);
        
        deposit(addr, 500);
        assert!(get_balance(addr) == 1500, 1);
        
        withdraw(user, 300);
        assert!(get_balance(addr) == 1200, 2);
    }
    
    #[test(user = @0x123)]
    #[expected_failure(abort_code = E_ACCOUNT_FROZEN)]
    public fun test_frozen_account(user: &signer) acquires BankAccount {
        open_account(user, 1001, 1000);
        freeze_account(user);
        
        let addr = signer::address_of(user);
        deposit(addr, 100); // åº”è¯¥å¤±è´¥
    }
}
```

**å…³é”®ç‚¹è§£æ**ï¼š
1. **èµ„æºå®šä¹‰**ï¼šä½¿ç”¨ `key` èƒ½åŠ›ä½œä¸ºè´¦æˆ·èµ„æº
2. **é”™è¯¯å¤„ç†**ï¼šå®šä¹‰æ¸…æ™°çš„é”™è¯¯ç 
3. **æƒé™æ§åˆ¶**ï¼šéªŒè¯æ“ä½œè€…èº«ä»½
4. **çŠ¶æ€ç®¡ç†**ï¼šé€šè¿‡ `is_active` æ§åˆ¶è´¦æˆ·çŠ¶æ€

---

### é¢˜ç›® 2ï¼šä»£å¸äº¤æ¢æ± 

```move
module day04_answers::liquidity_pool {
    use std::signer;
    
    struct CoinA has drop {}
    struct CoinB has drop {}
    
    struct LiquidityPool has key {
        reserve_a: u64,
        reserve_b: u64,
        total_liquidity: u64,
    }
    
    struct LiquidityProvider has key {
        liquidity_shares: u64,
    }
    
    const E_POOL_EXISTS: u64 = 1;
    const E_POOL_NOT_EXISTS: u64 = 2;
    const E_ZERO_AMOUNT: u64 = 3;
    const E_INSUFFICIENT_LIQUIDITY: u64 = 4;
    const E_INSUFFICIENT_OUTPUT: u64 = 5;
    
    // åˆå§‹åŒ–æµåŠ¨æ€§æ± 
    public fun initialize_pool(
        admin: &signer,
        initial_a: u64,
        initial_b: u64
    ) {
        let addr = signer::address_of(admin);
        assert!(!exists<LiquidityPool>(addr), E_POOL_EXISTS);
        assert!(initial_a > 0 && initial_b > 0, E_ZERO_AMOUNT);
        
        let pool = LiquidityPool {
            reserve_a: initial_a,
            reserve_b: initial_b,
            total_liquidity: initial_a + initial_b,
        };
        
        move_to(admin, pool);
    }
    
    // æ·»åŠ æµåŠ¨æ€§
    public fun add_liquidity(
        account: &signer,
        pool_addr: address,
        amount_a: u64,
        amount_b: u64
    ): u64 acquires LiquidityPool, LiquidityProvider {
        assert!(exists<LiquidityPool>(pool_addr), E_POOL_NOT_EXISTS);
        assert!(amount_a > 0 && amount_b > 0, E_ZERO_AMOUNT);
        
        let pool = borrow_global_mut<LiquidityPool>(pool_addr);
        
        // è®¡ç®—æµåŠ¨æ€§ä»½é¢ï¼ˆç®€åŒ–ç‰ˆï¼‰
        let liquidity = amount_a + amount_b;
        pool.reserve_a = pool.reserve_a + amount_a;
        pool.reserve_b = pool.reserve_b + amount_b;
        pool.total_liquidity = pool.total_liquidity + liquidity;
        
        // è®°å½•æä¾›è€…çš„ä»½é¢
        let addr = signer::address_of(account);
        if (!exists<LiquidityProvider>(addr)) {
            let provider = LiquidityProvider {
                liquidity_shares: liquidity,
            };
            move_to(account, provider);
        } else {
            let provider = borrow_global_mut<LiquidityProvider>(addr);
            provider.liquidity_shares = provider.liquidity_shares + liquidity;
        };
        
        liquidity
    }
    
    // ç§»é™¤æµåŠ¨æ€§
    public fun remove_liquidity(
        account: &signer,
        pool_addr: address,
        liquidity: u64
    ): (u64, u64) acquires LiquidityPool, LiquidityProvider {
        let addr = signer::address_of(account);
        assert!(exists<LiquidityProvider>(addr), E_INSUFFICIENT_LIQUIDITY);
        
        let provider = borrow_global_mut<LiquidityProvider>(addr);
        assert!(provider.liquidity_shares >= liquidity, E_INSUFFICIENT_LIQUIDITY);
        
        let pool = borrow_global_mut<LiquidityPool>(pool_addr);
        
        // è®¡ç®—å¯æå–çš„ä»£å¸æ•°é‡ï¼ˆæŒ‰æ¯”ä¾‹ï¼‰
        let amount_a = (pool.reserve_a * liquidity) / pool.total_liquidity;
        let amount_b = (pool.reserve_b * liquidity) / pool.total_liquidity;
        
        pool.reserve_a = pool.reserve_a - amount_a;
        pool.reserve_b = pool.reserve_b - amount_b;
        pool.total_liquidity = pool.total_liquidity - liquidity;
        
        provider.liquidity_shares = provider.liquidity_shares - liquidity;
        
        (amount_a, amount_b)
    }
    
    // äº¤æ¢ A åˆ° B
    public fun swap_a_to_b(
        pool_addr: address,
        amount_in: u64
    ): u64 acquires LiquidityPool {
        assert!(exists<LiquidityPool>(pool_addr), E_POOL_NOT_EXISTS);
        assert!(amount_in > 0, E_ZERO_AMOUNT);
        
        let pool = borrow_global_mut<LiquidityPool>(pool_addr);
        
        // ä½¿ç”¨å¸¸æ•°ä¹˜ç§¯å…¬å¼è®¡ç®—è¾“å‡º
        // amount_out = (reserve_b * amount_in) / (reserve_a + amount_in)
        let amount_out = (pool.reserve_b * amount_in) / (pool.reserve_a + amount_in);
        assert!(amount_out > 0, E_INSUFFICIENT_OUTPUT);
        
        pool.reserve_a = pool.reserve_a + amount_in;
        pool.reserve_b = pool.reserve_b - amount_out;
        
        amount_out
    }
    
    // äº¤æ¢ B åˆ° A
    public fun swap_b_to_a(
        pool_addr: address,
        amount_in: u64
    ): u64 acquires LiquidityPool {
        assert!(exists<LiquidityPool>(pool_addr), E_POOL_NOT_EXISTS);
        assert!(amount_in > 0, E_ZERO_AMOUNT);
        
        let pool = borrow_global_mut<LiquidityPool>(pool_addr);
        
        let amount_out = (pool.reserve_a * amount_in) / (pool.reserve_b + amount_in);
        assert!(amount_out > 0, E_INSUFFICIENT_OUTPUT);
        
        pool.reserve_b = pool.reserve_b + amount_in;
        pool.reserve_a = pool.reserve_a - amount_out;
        
        amount_out
    }
    
    // è·å–å‚¨å¤‡é‡
    public fun get_reserves(pool_addr: address): (u64, u64) acquires LiquidityPool {
        assert!(exists<LiquidityPool>(pool_addr), E_POOL_NOT_EXISTS);
        let pool = borrow_global<LiquidityPool>(pool_addr);
        (pool.reserve_a, pool.reserve_b)
    }
    
    #[test(admin = @0x1)]
    public fun test_liquidity_pool(admin: &signer) acquires LiquidityPool {
        initialize_pool(admin, 1000, 2000);
        
        let addr = signer::address_of(admin);
        let (reserve_a, reserve_b) = get_reserves(addr);
        assert!(reserve_a == 1000 && reserve_b == 2000, 0);
        
        // æµ‹è¯•äº¤æ¢
        let amount_out = swap_a_to_b(addr, 100);
        assert!(amount_out > 0 && amount_out < 200, 1);
    }
}
```

**å…³é”®ç‚¹è§£æ**ï¼š
1. **AMM ç®—æ³•**ï¼šå®ç°å¸¸æ•°ä¹˜ç§¯å…¬å¼
2. **æµåŠ¨æ€§ç®¡ç†**ï¼šè·Ÿè¸ªæ¯ä¸ªæä¾›è€…çš„ä»½é¢
3. **æ•°å­¦è®¡ç®—**ï¼šæ³¨æ„é¿å…æº¢å‡ºå’Œé™¤é›¶
4. **çŠ¶æ€æ›´æ–°**ï¼šç¡®ä¿å‚¨å¤‡é‡ä¸€è‡´æ€§

---

### é¢˜ç›® 3 & 4 çš„å®Œæ•´ç­”æ¡ˆç”±äºç¯‡å¹…è¾ƒé•¿ï¼Œå»ºè®®ï¼š

1. **é¢˜ç›®3ï¼ˆæŠ•ç¥¨æ²»ç†ï¼‰å…³é”®å®ç°**ï¼š
   - ä½¿ç”¨ vector å­˜å‚¨ææ¡ˆå’ŒæŠ•ç¥¨
   - å®ç°æŠ•ç¥¨æƒé‡éªŒè¯
   - æ£€æŸ¥é‡å¤æŠ•ç¥¨
   - è®¡ç®—é€šè¿‡æ¡ä»¶

2. **é¢˜ç›®4ï¼ˆå¤šç­¾é’±åŒ…ï¼‰å…³é”®å®ç°**ï¼š
   - æ‰€æœ‰è€…éªŒè¯æœºåˆ¶
   - ç¡®è®¤è®¡æ•°å’Œå»é‡
   - äº¤æ˜“æ‰§è¡Œæ¡ä»¶æ£€æŸ¥
   - ä½™é¢ç®¡ç†

---

## ğŸ¯ å­¦ä¹ æ€»ç»“

### å…³é”®æ¦‚å¿µå›é¡¾

1. **ç»“æ„ä½“**ï¼š
   - è‡ªå®šä¹‰æ•°æ®ç±»å‹
   - å­—æ®µç±»å‹å®‰å…¨
   - æ”¯æŒåµŒå¥—ç»„åˆ

2. **èƒ½åŠ›ç³»ç»Ÿ**ï¼š
   - `copy`: å¯å¤åˆ¶
   - `drop`: å¯ä¸¢å¼ƒ
   - `store`: å¯å­˜å‚¨
   - `key`: å¯ä½œä¸ºèµ„æº

3. **èµ„æºç®¡ç†**ï¼š
   - åˆ›å»ºï¼šæ„é€ å‡½æ•°
   - å­˜å‚¨ï¼š`move_to`
   - å€Ÿç”¨ï¼š`borrow_global` / `borrow_global_mut`
   - ç§»å‡ºï¼š`move_from`
   - é”€æ¯ï¼šè§£æ„

4. **è®¾è®¡æ¨¡å¼**ï¼š
   - çƒ­åœŸè±†æ¨¡å¼
   - è§è¯æ¨¡å¼
   - èƒ½åŠ›çº¦æŸ
   - ç±»å‹æ ‡è®°

### å¸¸è§é”™è¯¯åŠè§£å†³

1. **èƒ½åŠ›ä¸åŒ¹é…**
   ```move
   // âŒ é”™è¯¯
   struct Inner { }
   struct Outer has copy { inner: Inner }
   
   // âœ… æ­£ç¡®
   struct Inner has copy { }
   struct Outer has copy { inner: Inner }
   ```

2. **èµ„æºæœªå¤„ç†**
   ```move
   // âŒ é”™è¯¯
   fun wrong() {
       let resource = Resource { };
       // ç¼–è¯‘é”™è¯¯ï¼šæœªä½¿ç”¨
   }
   
   // âœ… æ­£ç¡®
   fun correct(account: &signer) {
       let resource = Resource { };
       move_to(account, resource);
   }
   ```

3. **å¿˜è®° acquires**
   ```move
   // âŒ é”™è¯¯
   public fun read_data(addr: address): u64 {
       borrow_global<Data>(addr).value
   }
   
   // âœ… æ­£ç¡®
   public fun read_data(addr: address): u64 acquires Data {
       borrow_global<Data>(addr).value
   }
   ```

---

## ğŸ“– å»¶ä¼¸é˜…è¯»

- Move Book: Structs and Resources
- Aptos Framework: Coin æ ‡å‡†
- DeFi åè®®è®¾è®¡æ¨¡å¼
- æ™ºèƒ½åˆçº¦å®‰å…¨æœ€ä½³å®è·µ

**æ­å–œå®Œæˆ Day 04 çš„å­¦ä¹ ï¼ç»§ç»­åŠ æ²¹ï¼** ğŸ‰

# å¥—åˆ©æœºå™¨äººæ ¸å¿ƒæ¦‚å¿µæ·±åº¦è§£æ

## ğŸ“š ç›®å½•

1. [å¥—åˆ©æœºå™¨äººç³»ç»Ÿæ¶æ„](#1-å¥—åˆ©æœºå™¨äººç³»ç»Ÿæ¶æ„)
2. [æ ¸å¿ƒæ¨¡å—è¯¦è§£](#2-æ ¸å¿ƒæ¨¡å—è¯¦è§£)
3. [å¥—åˆ©ç­–ç•¥å®ç°](#3-å¥—åˆ©ç­–ç•¥å®ç°)
4. [é£é™©æ§åˆ¶æœºåˆ¶](#4-é£é™©æ§åˆ¶æœºåˆ¶)
5. [æ€§èƒ½ä¼˜åŒ–æŠ€å·§](#5-æ€§èƒ½ä¼˜åŒ–æŠ€å·§)
6. [Aptos ç‰¹æ€§åº”ç”¨](#6-aptos-ç‰¹æ€§åº”ç”¨)

---

## 1. å¥—åˆ©æœºå™¨äººç³»ç»Ÿæ¶æ„

### 1.1 æ•´ä½“æ¶æ„è®¾è®¡

å¥—åˆ©æœºå™¨äººç³»ç»Ÿç”±ä¸‰å±‚ç»„æˆï¼š

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚            åº”ç”¨å±‚ (Application Layer)            â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚ æ§åˆ¶é¢æ¿  â”‚  â”‚ å‘Šè­¦ç³»ç»Ÿ  â”‚  â”‚ æ•°æ®åˆ†æ  â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                      â–²
                      â”‚ API/WebSocket
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚             ä¸­é—´å±‚ (Middleware Layer)            â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚         ä»·æ ¼ç›‘æ§ (Price Monitor)          â”‚  â”‚
â”‚  â”‚  â€¢ WebSocket è¿æ¥  â€¢ æ•°æ®ç¼“å­˜  â€¢ å˜åŒ–é€šçŸ¥ â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚      æœºä¼šå‘ç° (Opportunity Finder)        â”‚  â”‚
â”‚  â”‚  â€¢ ä»·å·®è®¡ç®—  â€¢ è·¯å¾„æœç´¢  â€¢ åˆ©æ¶¦ä¼°ç®—      â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚       ç­–ç•¥è¯„ä¼° (Strategy Evaluator)       â”‚  â”‚
â”‚  â”‚  â€¢ Gas ä¼°ç®—  â€¢ é£é™©è¯„ä¼°  â€¢ æ”¶ç›Šé¢„æµ‹      â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚       æ‰§è¡Œå¼•æ“ (Execution Engine)         â”‚  â”‚
â”‚  â”‚  â€¢ äº¤æ˜“æ„å»º  â€¢ ç­¾åæäº¤  â€¢ çŠ¶æ€è¿½è¸ª      â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                      â”‚ Aptos SDK
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚            åŒºå—é“¾å±‚ (Blockchain Layer)           â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚      å¥—åˆ©åˆçº¦ (Arbitrage Contract)        â”‚  â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚  â”‚
â”‚  â”‚  â”‚é—ªç”µè´·   â”‚ â”‚æ‰§è¡Œå™¨   â”‚ â”‚å®‰å…¨æ£€æŸ¥ â”‚     â”‚  â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚
â”‚  â”‚ DEX A   â”‚ â”‚ DEX B   â”‚ â”‚ DEX C   â”‚  ...    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 1.2 æ•°æ®æµè®¾è®¡

```
ä»·æ ¼æ›´æ–°æµ:
DEX Events â†’ WebSocket â†’ Price Monitor â†’ Cache Update â†’ 
Opportunity Finder â†’ Strategy Evaluator â†’ Execution Engine â†’ 
Blockchain

æ‰§è¡Œæµ:
User/Auto Trigger â†’ Build Transaction â†’ Sign â†’ Submit â†’ 
Wait Confirmation â†’ Record Result â†’ Update Statistics
```

### 1.3 æ¨¡å—èŒè´£åˆ’åˆ†

| æ¨¡å— | èŒè´£ | è¾“å…¥ | è¾“å‡º |
|------|------|------|------|
| ä»·æ ¼ç›‘æ§ | å®æ—¶è·å–ä»·æ ¼æ•°æ® | DEX WebSocket | ä»·æ ¼æ›´æ–°äº‹ä»¶ |
| æœºä¼šå‘ç° | è¯†åˆ«å¥—åˆ©æœºä¼š | ä»·æ ¼æ•°æ® | å¥—åˆ©æœºä¼šåˆ—è¡¨ |
| ç­–ç•¥è¯„ä¼° | è¯„ä¼°æœºä¼šå¯è¡Œæ€§ | å¥—åˆ©æœºä¼š | å¯æ‰§è¡Œç­–ç•¥ |
| æ‰§è¡Œå¼•æ“ | æäº¤äº¤æ˜“ | ç­–ç•¥ | äº¤æ˜“ç»“æœ |
| ç»Ÿè®¡åˆ†æ | åˆ†ææ€§èƒ½ | æ‰§è¡Œç»“æœ | ç»Ÿè®¡æŠ¥å‘Š |

---

## 2. æ ¸å¿ƒæ¨¡å—è¯¦è§£

### 2.1 ä»·æ ¼ç›‘æ§æ¨¡å—

#### è®¾è®¡ç›®æ ‡
- å®æ—¶æ€§ï¼šå»¶è¿Ÿ < 100ms
- å¯é æ€§ï¼šè‡ªåŠ¨é‡è¿ã€é”™è¯¯å¤„ç†
- æ•ˆç‡ï¼šæ‰¹é‡å¤„ç†ã€ç¼“å­˜ä¼˜åŒ–

#### å®ç°æ–¹æ¡ˆ

```typescript
interface PriceUpdate {
  dex: string;           // DEX åç§°
  pair: string;          // äº¤æ˜“å¯¹ (å¦‚ "APT/USDC")
  price: number;         // å½“å‰ä»·æ ¼
  liquidity: number;     // æµåŠ¨æ€§
  volume_24h: number;    // 24å°æ—¶äº¤æ˜“é‡
  timestamp: number;     // æ—¶é—´æˆ³
}

class PriceMonitor {
  private connections: Map<string, WebSocket>;
  private priceCache: Map<string, PriceUpdate>;
  private listeners: ((update: PriceUpdate) => void)[];
  
  constructor(private dexConfigs: DexConfig[]) {
    this.connections = new Map();
    this.priceCache = new Map();
    this.listeners = [];
  }
  
  // è¿æ¥æ‰€æœ‰ DEX
  async connectAll() {
    const promises = this.dexConfigs.map(config => 
      this.connectDex(config)
    );
    await Promise.all(promises);
  }
  
  // è¿æ¥å•ä¸ª DEX
  private async connectDex(config: DexConfig) {
    const ws = new WebSocket(config.wsUrl);
    
    ws.on('open', () => {
      console.log(`Connected to ${config.name}`);
      this.subscribe(ws, config.pairs);
    });
    
    ws.on('message', (data) => {
      const update = this.parsePriceUpdate(data, config.name);
      this.handlePriceUpdate(update);
    });
    
    ws.on('error', (error) => {
      console.error(`WebSocket error for ${config.name}:`, error);
    });
    
    ws.on('close', () => {
      console.log(`Connection closed for ${config.name}`);
      this.reconnect(config);
    });
    
    this.connections.set(config.name, ws);
  }
  
  // å¤„ç†ä»·æ ¼æ›´æ–°
  private handlePriceUpdate(update: PriceUpdate) {
    // æ›´æ–°ç¼“å­˜
    const key = `${update.dex}:${update.pair}`;
    const cached = this.priceCache.get(key);
    
    // æ£€æŸ¥ä»·æ ¼æ˜¯å¦çœŸçš„å˜åŒ–äº†
    if (!cached || Math.abs(cached.price - update.price) / cached.price > 0.0001) {
      this.priceCache.set(key, update);
      
      // é€šçŸ¥æ‰€æœ‰ç›‘å¬å™¨
      this.listeners.forEach(listener => listener(update));
    }
  }
  
  // è®¢é˜…ä»·æ ¼æ›´æ–°
  onPriceUpdate(listener: (update: PriceUpdate) => void) {
    this.listeners.push(listener);
  }
  
  // è·å–å½“å‰ä»·æ ¼
  getPrice(dex: string, pair: string): PriceUpdate | null {
    return this.priceCache.get(`${dex}:${pair}`) || null;
  }
  
  // è·å–æ‰€æœ‰ä»·æ ¼
  getAllPrices(pair: string): PriceUpdate[] {
    const prices: PriceUpdate[] = [];
    for (const [key, value] of this.priceCache) {
      if (value.pair === pair) {
        prices.push(value);
      }
    }
    return prices;
  }
}
```

#### æ•°æ®ç¼“å­˜ç­–ç•¥

```typescript
class PriceCache {
  private cache: Map<string, CachedPrice>;
  private readonly TTL = 5000; // 5ç§’è¿‡æœŸ
  private readonly MAX_SIZE = 1000; // æœ€å¤§ç¼“å­˜æ¡ç›®
  
  constructor() {
    this.cache = new Map();
    this.startCleanup();
  }
  
  set(key: string, price: number, metadata: any) {
    // å¦‚æœç¼“å­˜æ»¡äº†ï¼Œåˆ é™¤æœ€æ—§çš„æ¡ç›®
    if (this.cache.size >= this.MAX_SIZE) {
      this.evictOldest();
    }
    
    this.cache.set(key, {
      price,
      metadata,
      timestamp: Date.now(),
      accessCount: 0
    });
  }
  
  get(key: string): CachedPrice | null {
    const cached = this.cache.get(key);
    if (!cached) return null;
    
    // æ£€æŸ¥æ˜¯å¦è¿‡æœŸ
    if (Date.now() - cached.timestamp > this.TTL) {
      this.cache.delete(key);
      return null;
    }
    
    // å¢åŠ è®¿é—®è®¡æ•°ï¼ˆç”¨äº LRUï¼‰
    cached.accessCount++;
    return cached;
  }
  
  private evictOldest() {
    let oldestKey: string | null = null;
    let oldestTime = Date.now();
    
    for (const [key, value] of this.cache) {
      if (value.timestamp < oldestTime) {
        oldestTime = value.timestamp;
        oldestKey = key;
      }
    }
    
    if (oldestKey) {
      this.cache.delete(oldestKey);
    }
  }
  
  private startCleanup() {
    setInterval(() => {
      const now = Date.now();
      for (const [key, value] of this.cache) {
        if (now - value.timestamp > this.TTL) {
          this.cache.delete(key);
        }
      }
    }, 10000); // æ¯10ç§’æ¸…ç†ä¸€æ¬¡
  }
}
```

### 2.2 æœºä¼šå‘ç°æ¨¡å—

#### ç®€å•å¥—åˆ©æ£€æµ‹

```typescript
interface ArbitrageOpportunity {
  type: 'simple' | 'triangular' | 'flashloan';
  buy_dex: string;
  sell_dex: string;
  pair: string;
  buy_price: number;
  sell_price: number;
  price_diff_percent: number;
  optimal_amount: number;
  estimated_profit: number;
  estimated_gas: number;
  net_profit: number;
  confidence: number; // 0-1
}

class OpportunityFinder {
  private readonly MIN_PROFIT_PERCENT = 0.5;  // æœ€å°åˆ©æ¶¦ 0.5%
  private readonly MIN_NET_PROFIT = 10;        // æœ€å°å‡€åˆ©æ¶¦ 10 USD
  
  // æŸ¥æ‰¾ç®€å•å¥—åˆ©æœºä¼š
  findSimpleArbitrage(pair: string, prices: PriceUpdate[]): ArbitrageOpportunity[] {
    const opportunities: ArbitrageOpportunity[] = [];
    
    // ä¸¤ä¸¤æ¯”è¾ƒæ‰€æœ‰ DEX
    for (let i = 0; i < prices.length; i++) {
      for (let j = i + 1; j < prices.length; j++) {
        const priceA = prices[i];
        const priceB = prices[j];
        
        // è®¡ç®—ä»·å·®
        const priceDiff = Math.abs(priceA.price - priceB.price);
        const priceDiffPercent = (priceDiff / Math.min(priceA.price, priceB.price)) * 100;
        
        if (priceDiffPercent < this.MIN_PROFIT_PERCENT) {
          continue;
        }
        
        // ç¡®å®šä¹°å…¥å’Œå–å‡º DEX
        const [buyDex, sellDex] = priceA.price < priceB.price 
          ? [priceA, priceB] 
          : [priceB, priceA];
        
        // è®¡ç®—æœ€ä¼˜äº¤æ˜“é‡
        const optimalAmount = this.calculateOptimalAmount(buyDex, sellDex);
        
        // ä¼°ç®—åˆ©æ¶¦
        const grossProfit = optimalAmount * (sellDex.price - buyDex.price);
        const estimatedGas = this.estimateGasCost('simple', 2);
        const netProfit = grossProfit - estimatedGas;
        
        if (netProfit < this.MIN_NET_PROFIT) {
          continue;
        }
        
        // è®¡ç®—ç½®ä¿¡åº¦
        const confidence = this.calculateConfidence(buyDex, sellDex, optimalAmount);
        
        opportunities.push({
          type: 'simple',
          buy_dex: buyDex.dex,
          sell_dex: sellDex.dex,
          pair: pair,
          buy_price: buyDex.price,
          sell_price: sellDex.price,
          price_diff_percent: priceDiffPercent,
          optimal_amount: optimalAmount,
          estimated_profit: grossProfit,
          estimated_gas: estimatedGas,
          net_profit: netProfit,
          confidence: confidence
        });
      }
    }
    
    // æŒ‰å‡€åˆ©æ¶¦æ’åº
    return opportunities.sort((a, b) => b.net_profit - a.net_profit);
  }
  
  // è®¡ç®—æœ€ä¼˜äº¤æ˜“é‡ï¼ˆè€ƒè™‘ä»·æ ¼å½±å“ï¼‰
  private calculateOptimalAmount(
    buyDex: PriceUpdate,
    sellDex: PriceUpdate
  ): number {
    // ç®€åŒ–çš„ä»·æ ¼å½±å“æ¨¡å‹
    // å®é™…åº”è¯¥ä½¿ç”¨ AMM çš„ x*y=k å…¬å¼
    
    // å¯ç”¨æµåŠ¨æ€§
    const buyLiquidity = buyDex.liquidity;
    const sellLiquidity = sellDex.liquidity;
    
    // é™åˆ¶æœ€å¤§äº¤æ˜“é‡ä¸ºæµåŠ¨æ€§çš„ 5%ï¼ˆé¿å…è¿‡å¤§çš„ä»·æ ¼å½±å“ï¼‰
    const maxAmount = Math.min(buyLiquidity, sellLiquidity) * 0.05;
    
    // è€ƒè™‘ä»·æ ¼å½±å“çš„æœ€ä¼˜é‡ï¼ˆè¿™æ˜¯ç®€åŒ–ç‰ˆæœ¬ï¼‰
    const priceDiff = sellDex.price - buyDex.price;
    const priceImpactFactor = 0.003; // å‡è®¾æ¯ 1% çš„æ± å­ä½¿ç”¨ä¼šå¯¼è‡´ 0.3% çš„ä»·æ ¼å½±å“
    
    // æœ€ä¼˜é‡ä½¿å¾—ï¼šè¾¹é™…æ”¶ç›Š = è¾¹é™…æˆæœ¬
    // è¿™é‡Œä½¿ç”¨ç®€åŒ–çš„çº¿æ€§è¿‘ä¼¼
    const optimalAmount = Math.min(
      maxAmount,
      priceDiff / (2 * priceImpactFactor * buyDex.price)
    );
    
    return Math.floor(optimalAmount);
  }
  
  // è®¡ç®—ç½®ä¿¡åº¦
  private calculateConfidence(
    buyDex: PriceUpdate,
    sellDex: PriceUpdate,
    amount: number
  ): number {
    let confidence = 1.0;
    
    // æµåŠ¨æ€§å› ç´ ï¼šæµåŠ¨æ€§è¶Šé«˜ï¼Œç½®ä¿¡åº¦è¶Šé«˜
    const liquidityRatio = Math.min(buyDex.liquidity, sellDex.liquidity) / amount;
    if (liquidityRatio < 20) {
      confidence *= 0.7;
    } else if (liquidityRatio < 50) {
      confidence *= 0.85;
    }
    
    // æ—¶é—´å› ç´ ï¼šæ•°æ®è¶Šæ–°ï¼Œç½®ä¿¡åº¦è¶Šé«˜
    const now = Date.now();
    const maxAge = 5000; // 5ç§’
    const avgAge = ((now - buyDex.timestamp) + (now - sellDex.timestamp)) / 2;
    if (avgAge > maxAge) {
      confidence *= 0.5;
    } else {
      confidence *= (1 - avgAge / (2 * maxAge));
    }
    
    // äº¤æ˜“é‡å› ç´ ï¼šäº¤æ˜“é‡è¶Šå¤§ï¼Œç½®ä¿¡åº¦è¶Šé«˜
    const minVolume = Math.min(buyDex.volume_24h, sellDex.volume_24h);
    if (minVolume < 10000) {
      confidence *= 0.6;
    } else if (minVolume < 100000) {
      confidence *= 0.8;
    }
    
    return confidence;
  }
  
  // ä¼°ç®— Gas æˆæœ¬
  private estimateGasCost(type: string, swapCount: number): number {
    // åŸºç¡€ Gas
    const BASE_GAS = 0.001; // APT
    
    // æ¯æ¬¡ swap çš„ Gas
    const SWAP_GAS = 0.0005; // APT
    
    // é—ªç”µè´·é¢å¤– Gas
    const FLASHLOAN_GAS = type === 'flashloan' ? 0.0003 : 0;
    
    const totalGasAPT = BASE_GAS + swapCount * SWAP_GAS + FLASHLOAN_GAS;
    
    // å‡è®¾ APT ä»·æ ¼ä¸º $10
    const APT_PRICE = 10;
    
    return totalGasAPT * APT_PRICE;
  }
}
```

#### ä¸‰è§’å¥—åˆ©æ£€æµ‹

```typescript
interface TriangularPath {
  dex: string;
  tokens: [string, string, string];  // [A, B, C]
  prices: [number, number, number];  // [Aâ†’B, Bâ†’C, Câ†’A]
  start_amount: number;
  end_amount: number;
  profit: number;
  profit_percent: number;
}

class TriangularArbitrageFinder {
  // æŸ¥æ‰¾ä¸‰è§’å¥—åˆ©è·¯å¾„
  findTriangularPaths(
    dex: string,
    pairs: Map<string, PriceUpdate>
  ): TriangularPath[] {
    const paths: TriangularPath[] = [];
    const tokens = this.getUniqueTokens(pairs);
    
    // éå†æ‰€æœ‰å¯èƒ½çš„ä¸‰è§’ç»„åˆ
    for (const tokenA of tokens) {
      for (const tokenB of tokens) {
        for (const tokenC of tokens) {
          if (tokenA === tokenB || tokenB === tokenC || tokenA === tokenC) {
            continue;
          }
          
          // æ£€æŸ¥è·¯å¾„æ˜¯å¦å­˜åœ¨ï¼šA â†’ B â†’ C â†’ A
          const priceAB = this.getPrice(pairs, tokenA, tokenB);
          const priceBC = this.getPrice(pairs, tokenB, tokenC);
          const priceCA = this.getPrice(pairs, tokenC, tokenA);
          
          if (!priceAB || !priceBC || !priceCA) {
            continue;
          }
          
          // è®¡ç®—æœ€ç»ˆé‡‘é¢
          const startAmount = 1000; // ä» 1000 å•ä½å¼€å§‹
          let amount = startAmount;
          
          // A â†’ B
          amount = amount * priceAB;
          // B â†’ C
          amount = amount * priceBC;
          // C â†’ A
          amount = amount * priceCA;
          
          const profit = amount - startAmount;
          const profitPercent = (profit / startAmount) * 100;
          
          // å¦‚æœæœ‰åˆ©æ¶¦
          if (profitPercent > 0.3) { // è‡³å°‘ 0.3% åˆ©æ¶¦
            paths.push({
              dex,
              tokens: [tokenA, tokenB, tokenC],
              prices: [priceAB, priceBC, priceCA],
              start_amount: startAmount,
              end_amount: amount,
              profit,
              profit_percent: profitPercent
            });
          }
        }
      }
    }
    
    return paths.sort((a, b) => b.profit - a.profit);
  }
  
  private getUniqueTokens(pairs: Map<string, PriceUpdate>): string[] {
    const tokens = new Set<string>();
    for (const [key, _] of pairs) {
      const [tokenA, tokenB] = key.split('/');
      tokens.add(tokenA);
      tokens.add(tokenB);
    }
    return Array.from(tokens);
  }
  
  private getPrice(
    pairs: Map<string, PriceUpdate>,
    from: string,
    to: string
  ): number | null {
    // å°è¯•ç›´æ¥äº¤æ˜“å¯¹
    const directKey = `${from}/${to}`;
    const direct = pairs.get(directKey);
    if (direct) {
      return direct.price;
    }
    
    // å°è¯•åå‘äº¤æ˜“å¯¹
    const reverseKey = `${to}/${from}`;
    const reverse = pairs.get(reverseKey);
    if (reverse) {
      return 1 / reverse.price;
    }
    
    return null;
  }
}
```

### 2.3 ç­–ç•¥è¯„ä¼°æ¨¡å—

```typescript
interface EvaluatedStrategy {
  opportunity: ArbitrageOpportunity;
  score: number;              // ç»¼åˆè¯„åˆ† 0-100
  risk_level: 'low' | 'medium' | 'high';
  recommended_amount: number;  // æ¨èäº¤æ˜“é‡
  expected_profit: number;
  max_loss: number;
  execution_priority: number;  // æ‰§è¡Œä¼˜å…ˆçº§
}

class StrategyEvaluator {
  evaluate(opportunity: ArbitrageOpportunity): EvaluatedStrategy {
    // 1. è®¡ç®—æ”¶ç›Šè¯„åˆ† (0-40åˆ†)
    const profitScore = this.calculateProfitScore(opportunity);
    
    // 2. è®¡ç®—é£é™©è¯„åˆ† (0-30åˆ†)
    const riskScore = this.calculateRiskScore(opportunity);
    
    // 3. è®¡ç®—å¯è¡Œæ€§è¯„åˆ† (0-30åˆ†)
    const feasibilityScore = this.calculateFeasibilityScore(opportunity);
    
    // ç»¼åˆè¯„åˆ†
    const totalScore = profitScore + riskScore + feasibilityScore;
    
    // é£é™©ç­‰çº§
    const riskLevel = this.determineRiskLevel(opportunity);
    
    // æ¨èäº¤æ˜“é‡ï¼ˆå¯èƒ½è°ƒæ•´åŸå§‹å»ºè®®é‡ï¼‰
    const recommendedAmount = this.adjustAmount(opportunity, riskLevel);
    
    // é¢„æœŸåˆ©æ¶¦å’Œæœ€å¤§æŸå¤±
    const expectedProfit = this.calculateExpectedProfit(opportunity, recommendedAmount);
    const maxLoss = this.calculateMaxLoss(opportunity, recommendedAmount);
    
    // æ‰§è¡Œä¼˜å…ˆçº§
    const executionPriority = this.calculatePriority(totalScore, riskLevel);
    
    return {
      opportunity,
      score: totalScore,
      risk_level: riskLevel,
      recommended_amount: recommendedAmount,
      expected_profit: expectedProfit,
      max_loss: maxLoss,
      execution_priority: executionPriority
    };
  }
  
  private calculateProfitScore(opp: ArbitrageOpportunity): number {
    // åŸºäºå‡€åˆ©æ¶¦å’Œåˆ©æ¶¦ç‡
    const profitRatio = opp.net_profit / (opp.optimal_amount * opp.buy_price);
    
    // å‡€åˆ©æ¶¦è¯„åˆ† (0-20)
    let netProfitScore = Math.min(opp.net_profit / 10, 20);
    
    // åˆ©æ¶¦ç‡è¯„åˆ† (0-20)
    let profitRatioScore = Math.min(profitRatio * 1000, 20);
    
    return netProfitScore + profitRatioScore;
  }
  
  private calculateRiskScore(opp: ArbitrageOpportunity): number {
    // ç½®ä¿¡åº¦è¯„åˆ† (0-15)
    const confidenceScore = opp.confidence * 15;
    
    // æµåŠ¨æ€§è¯„åˆ† (0-15)
    // è¿™é‡Œéœ€è¦ä»æœºä¼šä¸­è·å–æµåŠ¨æ€§ä¿¡æ¯
    const liquidityScore = 15; // ç®€åŒ–å¤„ç†
    
    return confidenceScore + liquidityScore;
  }
  
  private calculateFeasibilityScore(opp: ArbitrageOpportunity): number {
    // Gas æˆæœ¬åˆç†æ€§ (0-15)
    const gasCostRatio = opp.estimated_gas / opp.estimated_profit;
    const gasCostScore = gasCostRatio < 0.1 ? 15 : gasCostRatio < 0.3 ? 10 : 5;
    
    // äº¤æ˜“ç±»å‹è¯„åˆ† (0-15)
    const typeScore = opp.type === 'simple' ? 15 : opp.type === 'flashloan' ? 10 : 12;
    
    return gasCostScore + typeScore;
  }
  
  private determineRiskLevel(opp: ArbitrageOpportunity): 'low' | 'medium' | 'high' {
    if (opp.confidence > 0.8 && opp.price_diff_percent > 1) {
      return 'low';
    } else if (opp.confidence > 0.5 && opp.price_diff_percent > 0.5) {
      return 'medium';
    } else {
      return 'high';
    }
  }
  
  private adjustAmount(
    opp: ArbitrageOpportunity,
    riskLevel: 'low' | 'medium' | 'high'
  ): number {
    const multiplier = {
      'low': 1.0,
      'medium': 0.7,
      'high': 0.5
    }[riskLevel];
    
    return opp.optimal_amount * multiplier;
  }
  
  private calculateExpectedProfit(
    opp: ArbitrageOpportunity,
    amount: number
  ): number {
    const ratio = amount / opp.optimal_amount;
    return opp.net_profit * ratio * opp.confidence;
  }
  
  private calculateMaxLoss(
    opp: ArbitrageOpportunity,
    amount: number
  ): number {
    // æœ€å¤§æŸå¤± = Gas æˆæœ¬ + å¯èƒ½çš„æ»‘ç‚¹æŸå¤±
    const slippageLoss = amount * opp.buy_price * 0.01; // å‡è®¾æœ€å¤§ 1% æ»‘ç‚¹
    return opp.estimated_gas + slippageLoss;
  }
  
  private calculatePriority(
    score: number,
    riskLevel: 'low' | 'medium' | 'high'
  ): number {
    const riskPenalty = {
      'low': 0,
      'medium': 10,
      'high': 20
    }[riskLevel];
    
    return Math.max(0, score - riskPenalty);
  }
}
```

### 2.4 æ‰§è¡Œå¼•æ“æ¨¡å—

```typescript
interface ExecutionResult {
  success: boolean;
  txn_hash?: string;
  profit?: number;
  error?: string;
  execution_time_ms: number;
  gas_used?: number;
}

class ExecutionEngine {
  private client: AptosClient;
  private account: AptosAccount;
  private readonly MAX_RETRY = 3;
  private readonly TIMEOUT_MS = 5000;
  
  constructor(nodeUrl: string, privateKey: string) {
    this.client = new AptosClient(nodeUrl);
    this.account = new AptosAccount(hexToBytes(privateKey));
  }
  
  // æ‰§è¡Œå¥—åˆ©ç­–ç•¥
  async execute(strategy: EvaluatedStrategy): Promise<ExecutionResult> {
    const startTime = Date.now();
    
    try {
      // 1. æ„å»ºäº¤æ˜“
      const rawTxn = await this.buildTransaction(strategy);
      
      // 2. ç­¾å
      const signedTxn = await this.client.signTransaction(this.account, rawTxn);
      
      // 3. æäº¤ï¼ˆå¸¦è¶…æ—¶å’Œé‡è¯•ï¼‰
      const txnHash = await this.submitWithRetry(signedTxn);
      
      // 4. ç­‰å¾…ç¡®è®¤
      const result = await this.waitForConfirmation(txnHash);
      
      // 5. è§£æç»“æœ
      const profit = this.extractProfit(result);
      const gasUsed = this.extractGasUsed(result);
      
      return {
        success: true,
        txn_hash: txnHash,
        profit: profit,
        gas_used: gasUsed,
        execution_time_ms: Date.now() - startTime
      };
    } catch (error) {
      return {
        success: false,
        error: error.message,
        execution_time_ms: Date.now() - startTime
      };
    }
  }
  
  // æ„å»ºäº¤æ˜“
  private async buildTransaction(
    strategy: EvaluatedStrategy
  ): Promise<TxnBuilderTypes.RawTransaction> {
    const opp = strategy.opportunity;
    
    let payload;
    
    if (opp.type === 'simple') {
      // ç®€å•å¥—åˆ©
      payload = {
        function: `${CONTRACT_ADDRESS}::arbitrage::execute_simple`,
        type_arguments: [],
        arguments: [
          opp.buy_dex,
          opp.sell_dex,
          opp.pair,
          strategy.recommended_amount,
          Math.floor(strategy.expected_profit * 0.95) // 95% çš„é¢„æœŸåˆ©æ¶¦ä½œä¸ºæœ€å°æ¥å—
        ]
      };
    } else if (opp.type === 'flashloan') {
      // é—ªç”µè´·å¥—åˆ©
      payload = {
        function: `${CONTRACT_ADDRESS}::arbitrage::execute_flashloan`,
        type_arguments: [],
        arguments: [
          strategy.recommended_amount,
          opp.buy_dex,
          opp.sell_dex,
          opp.pair,
          Math.floor(strategy.expected_profit * 0.95)
        ]
      };
    }
    
    return await this.client.generateTransaction(
      this.account.address(),
      payload,
      {
        max_gas_amount: '100000',
        gas_unit_price: '100'
      }
    );
  }
  
  // æäº¤äº¤æ˜“ï¼ˆå¸¦é‡è¯•ï¼‰
  private async submitWithRetry(
    signedTxn: Uint8Array
  ): Promise<string> {
    for (let i = 0; i < this.MAX_RETRY; i++) {
      try {
        const result = await Promise.race([
          this.client.submitTransaction(signedTxn),
          new Promise((_, reject) => 
            setTimeout(() => reject(new Error('Submission timeout')), this.TIMEOUT_MS)
          )
        ]);
        
        return result.hash;
      } catch (error) {
        console.error(`Submission attempt ${i + 1} failed:`, error);
        
        if (i === this.MAX_RETRY - 1) {
          throw error;
        }
        
        // æŒ‡æ•°é€€é¿
        await sleep(Math.pow(2, i) * 1000);
      }
    }
    
    throw new Error('Failed to submit after retries');
  }
  
  // ç­‰å¾…äº¤æ˜“ç¡®è®¤
  private async waitForConfirmation(txnHash: string): Promise<any> {
    return await this.client.waitForTransactionWithResult(txnHash, {
      checkSuccess: true
    });
  }
  
  // æå–åˆ©æ¶¦
  private extractProfit(txnResult: any): number {
    // ä»äº¤æ˜“äº‹ä»¶ä¸­æå–åˆ©æ¶¦ä¿¡æ¯
    const events = txnResult.events || [];
    const profitEvent = events.find(e => 
      e.type.includes('ProfitEvent')
    );
    
    if (profitEvent) {
      return parseFloat(profitEvent.data.profit);
    }
    
    return 0;
  }
  
  // æå– Gas ä½¿ç”¨
  private extractGasUsed(txnResult: any): number {
    return parseInt(txnResult.gas_used || '0');
  }
}

function sleep(ms: number): Promise<void> {
  return new Promise(resolve => setTimeout(resolve, ms));
}
```

---

## 3. å¥—åˆ©ç­–ç•¥å®ç°

### 3.1 ç®€å•å¥—åˆ©ç­–ç•¥

```move
module arbitrage_bot::simple_arbitrage {
    use std::signer;
    use aptos_framework::coin::{Self, Coin};
    use aptos_framework::event;
    
    /// å¥—åˆ©æ‰§è¡Œäº‹ä»¶
    struct ArbitrageExecutedEvent has drop, store {
        executor: address,
        token_in: address,
        token_out: address,
        amount_in: u64,
        amount_out: u64,
        profit: u64,
        timestamp: u64
    }
    
    /// äº‹ä»¶å¥æŸ„
    struct EventHolder has key {
        arbitrage_events: event::EventHandle<ArbitrageExecutedEvent>,
    }
    
    /// æ‰§è¡Œç®€å•å¥—åˆ©
    /// buy_dex: ä¹°å…¥çš„ DEX
    /// sell_dex: å–å‡ºçš„ DEX
    /// amount: äº¤æ˜“é‡‘é¢
    /// min_profit: æœ€å°åˆ©æ¶¦è¦æ±‚
    public entry fun execute_simple<TokenIn, TokenOut>(
        executor: &signer,
        buy_dex: address,
        sell_dex: address,
        amount: u64,
        min_profit: u64
    ) acquires EventHolder {
        let executor_addr = signer::address_of(executor);
        
        // 1. ä»ç”¨æˆ·è´¦æˆ·å–å‡º TokenIn
        let token_in = coin::withdraw<TokenIn>(executor, amount);
        
        // 2. åœ¨ buy_dex ä¹°å…¥ TokenOut
        let token_out = swap_at_dex<TokenIn, TokenOut>(
            buy_dex,
            token_in
        );
        let amount_out = coin::value(&token_out);
        
        // 3. åœ¨ sell_dex å–å‡º TokenOutï¼Œæ¢å› TokenIn
        let token_in_back = swap_at_dex<TokenOut, TokenIn>(
            sell_dex,
            token_out
        );
        let amount_back = coin::value(&token_in_back);
        
        // 4. è®¡ç®—åˆ©æ¶¦
        assert!(amount_back > amount, ERROR_NO_PROFIT);
        let profit = amount_back - amount;
        assert!(profit >= min_profit, ERROR_INSUFFICIENT_PROFIT);
        
        // 5. å­˜å›ç”¨æˆ·è´¦æˆ·
        coin::deposit(executor_addr, token_in_back);
        
        // 6. å‘å‡ºäº‹ä»¶
        let event_holder = borrow_global_mut<EventHolder>(executor_addr);
        event::emit_event(&mut event_holder.arbitrage_events, ArbitrageExecutedEvent {
            executor: executor_addr,
            token_in: type_info::type_of<TokenIn>(),
            token_out: type_info::type_of<TokenOut>(),
            amount_in: amount,
            amount_out: amount_back,
            profit: profit,
            timestamp: timestamp::now_seconds()
        });
    }
    
    /// åœ¨æŒ‡å®š DEX æ‰§è¡Œäº¤æ¢
    fun swap_at_dex<From, To>(
        dex: address,
        from_coin: Coin<From>
    ): Coin<To> {
        // è¿™é‡Œéœ€è¦è°ƒç”¨å…·ä½“ DEX çš„ swap å‡½æ•°
        // ç®€åŒ–ç¤ºä¾‹ï¼Œå®é™…éœ€è¦æ ¹æ® DEX çš„æ¥å£è°ƒç”¨
        
        // ç¤ºä¾‹: å‡è®¾æ‰€æœ‰ DEX éƒ½æœ‰ç»Ÿä¸€çš„ swap æ¥å£
        // dex_interface::swap<From, To>(dex, from_coin)
        
        // è¿™é‡Œè¿”å›å ä½ç¬¦
        abort ERROR_NOT_IMPLEMENTED
    }
    
    // é”™è¯¯ç 
    const ERROR_NO_PROFIT: u64 = 1;
    const ERROR_INSUFFICIENT_PROFIT: u64 = 2;
    const ERROR_NOT_IMPLEMENTED: u64 = 999;
}
```

### 3.2 é—ªç”µè´·å¥—åˆ©ç­–ç•¥

```move
module arbitrage_bot::flashloan_arbitrage {
    use std::signer;
    use aptos_framework::coin::{Self, Coin};
    use arbitrage_bot::flashloan;
    
    /// é—ªç”µè´·å›è°ƒæ•°æ®
    struct FlashloanCallbackData has drop {
        buy_dex: address,
        sell_dex: address,
        min_profit: u64,
    }
    
    /// ä½¿ç”¨é—ªç”µè´·æ‰§è¡Œå¥—åˆ©
    public entry fun execute_with_flashloan<TokenIn, TokenOut>(
        executor: &signer,
        amount: u64,
        buy_dex: address,
        sell_dex: address,
        min_profit: u64
    ) {
        let callback_data = FlashloanCallbackData {
            buy_dex,
            sell_dex,
            min_profit,
        };
        
        // å€Ÿå‡ºé—ªç”µè´·å¹¶æ‰§è¡Œå¥—åˆ©
        flashloan::borrow_and_execute<TokenIn>(
            executor,
            amount,
            callback_data,
            execute_arbitrage_callback<TokenIn, TokenOut>
        );
    }
    
    /// é—ªç”µè´·å›è°ƒå‡½æ•°
    fun execute_arbitrage_callback<TokenIn, TokenOut>(
        executor: &signer,
        borrowed: Coin<TokenIn>,
        callback_data: FlashloanCallbackData
    ): Coin<TokenIn> {
        let amount = coin::value(&borrowed);
        
        // 1. åœ¨ buy_dex ä¹°å…¥ TokenOut
        let token_out = swap_at_dex<TokenIn, TokenOut>(
            callback_data.buy_dex,
            borrowed
        );
        
        // 2. åœ¨ sell_dex å–å‡º TokenOutï¼Œæ¢å› TokenIn
        let token_in_back = swap_at_dex<TokenOut, TokenIn>(
            callback_data.sell_dex,
            token_out
        );
        
        let amount_back = coin::value(&token_in_back);
        
        // 3. è®¡ç®—åˆ©æ¶¦ï¼ˆæ‰£é™¤é—ªç”µè´·è´¹ç”¨ï¼‰
        let fee = flashloan::calculate_fee(amount);
        let required_amount = amount + fee;
        
        assert!(amount_back > required_amount, ERROR_NO_PROFIT);
        let profit = amount_back - required_amount;
        assert!(profit >= callback_data.min_profit, ERROR_INSUFFICIENT_PROFIT);
        
        // 4. åˆ†ç¦»å½’è¿˜é‡‘é¢å’Œåˆ©æ¶¦
        let repay_coin = coin::extract(&mut token_in_back, required_amount);
        
        // 5. å°†åˆ©æ¶¦å­˜å…¥æ‰§è¡Œè€…è´¦æˆ·
        let executor_addr = signer::address_of(executor);
        coin::deposit(executor_addr, token_in_back);
        
        // 6. è¿”å›å½’è¿˜é‡‘é¢
        repay_coin
    }
    
    fun swap_at_dex<From, To>(
        dex: address,
        from_coin: Coin<From>
    ): Coin<To> {
        abort ERROR_NOT_IMPLEMENTED
    }
    
    const ERROR_NO_PROFIT: u64 = 1;
    const ERROR_INSUFFICIENT_PROFIT: u64 = 2;
    const ERROR_NOT_IMPLEMENTED: u64 = 999;
}
```

---

## 4. é£é™©æ§åˆ¶æœºåˆ¶

### 4.1 æ»‘ç‚¹ä¿æŠ¤

```move
/// å¸¦æ»‘ç‚¹ä¿æŠ¤çš„äº¤æ¢
public fun swap_with_slippage_protection<From, To>(
    from_coin: Coin<From>,
    min_amount_out: u64
): Coin<To> {
    let amount_in = coin::value(&from_coin);
    
    // è®¡ç®—é¢„æœŸè¾“å‡º
    let expected_out = calculate_output<From, To>(amount_in);
    
    // æ‰§è¡Œäº¤æ¢
    let to_coin = swap<From, To>(from_coin);
    let actual_out = coin::value(&to_coin);
    
    // æ£€æŸ¥æ»‘ç‚¹
    assert!(actual_out >= min_amount_out, ERROR_SLIPPAGE_EXCEEDED);
    
    to_coin
}
```

### 4.2 æœ€å¤§æŸå¤±é™åˆ¶

```typescript
class RiskController {
  private readonly MAX_LOSS_PER_TRADE = 100; // USD
  private readonly MAX_DAILY_LOSS = 1000;    // USD
  private dailyLoss: number = 0;
  
  canExecute(strategy: EvaluatedStrategy): boolean {
    // æ£€æŸ¥å•ç¬”æœ€å¤§æŸå¤±
    if (strategy.max_loss > this.MAX_LOSS_PER_TRADE) {
      console.log('Max loss per trade exceeded');
      return false;
    }
    
    // æ£€æŸ¥æ¯æ—¥æŸå¤±é™é¢
    if (this.dailyLoss + strategy.max_loss > this.MAX_DAILY_LOSS) {
      console.log('Daily loss limit would be exceeded');
      return false;
    }
    
    return true;
  }
  
  recordResult(result: ExecutionResult) {
    if (!result.success) {
      // è®°å½•æŸå¤±
      this.dailyLoss += result.gas_used || 0;
    } else {
      // è®°å½•å‡€æ”¶ç›Šï¼ˆå¯èƒ½ä¸ºè´Ÿï¼‰
      const netProfit = (result.profit || 0) - (result.gas_used || 0);
      if (netProfit < 0) {
        this.dailyLoss += Math.abs(netProfit);
      }
    }
  }
  
  resetDailyStats() {
    this.dailyLoss = 0;
  }
}
```

### 4.3 å¹¶å‘æ§åˆ¶

```typescript
class ConcurrencyController {
  private runningExecutions: Map<string, Promise<ExecutionResult>>;
  private readonly MAX_CONCURRENT = 3;
  
  constructor() {
    this.runningExecutions = new Map();
  }
  
  async execute(
    strategyId: string,
    executor: () => Promise<ExecutionResult>
  ): Promise<ExecutionResult> {
    // æ£€æŸ¥æ˜¯å¦å·²åœ¨æ‰§è¡Œ
    if (this.runningExecutions.has(strategyId)) {
      throw new Error('Strategy already executing');
    }
    
    // æ£€æŸ¥å¹¶å‘æ•°
    if (this.runningExecutions.size >= this.MAX_CONCURRENT) {
      throw new Error('Max concurrent executions reached');
    }
    
    // æ‰§è¡Œ
    const promise = executor().finally(() => {
      this.runningExecutions.delete(strategyId);
    });
    
    this.runningExecutions.set(strategyId, promise);
    
    return promise;
  }
}
```

---

## 5. æ€§èƒ½ä¼˜åŒ–æŠ€å·§

### 5.1 æ‰¹é‡æ•°æ®è·å–

```typescript
// ä¸å¥½çš„åšæ³•ï¼šé€ä¸ªè·å–
for (const pair of pairs) {
  const price = await fetchPrice(pair);
  // å¤„ç†...
}

// å¥½çš„åšæ³•ï¼šæ‰¹é‡è·å–
const pricePromises = pairs.map(pair => fetchPrice(pair));
const prices = await Promise.all(pricePromises);
// å¤„ç†...
```

### 5.2 è¿æ¥æ± 

```typescript
class ConnectionPool {
  private connections: WebSocket[] = [];
  private readonly poolSize = 5;
  
  async getConnection(url: string): Promise<WebSocket> {
    // å¤ç”¨ç°æœ‰è¿æ¥
    const existing = this.connections.find(c => 
      c.url === url && c.readyState === WebSocket.OPEN
    );
    
    if (existing) {
      return existing;
    }
    
    // åˆ›å»ºæ–°è¿æ¥
    if (this.connections.length < this.poolSize) {
      const ws = new WebSocket(url);
      await this.waitForOpen(ws);
      this.connections.push(ws);
      return ws;
    }
    
    // ç­‰å¾…è¿æ¥å¯ç”¨
    return this.waitForAvailable(url);
  }
  
  private waitForOpen(ws: WebSocket): Promise<void> {
    return new Promise((resolve, reject) => {
      ws.once('open', () => resolve());
      ws.once('error', reject);
    });
  }
}
```

### 5.3 æ™ºèƒ½è·¯ç”±

```typescript
class SmartRouter {
  // é€‰æ‹©æœ€ä¼˜æ‰§è¡Œè·¯å¾„
  selectBestPath(
    strategies: EvaluatedStrategy[]
  ): EvaluatedStrategy | null {
    if (strategies.length === 0) {
      return null;
    }
    
    // æŒ‰ä¼˜å…ˆçº§æ’åº
    const sorted = strategies.sort((a, b) => 
      b.execution_priority - a.execution_priority
    );
    
    // é€‰æ‹©å¾—åˆ†æœ€é«˜ä¸”é£é™©å¯æ¥å—çš„ç­–ç•¥
    for (const strategy of sorted) {
      if (strategy.risk_level !== 'high' && strategy.score > 60) {
        return strategy;
      }
    }
    
    return null;
  }
}
```

---

## 6. Aptos ç‰¹æ€§åº”ç”¨

### 6.1 Block-STM å¹¶å‘ä¼˜åŒ–

Aptos çš„ Block-STM å…è®¸å¹¶è¡Œæ‰§è¡Œä¸å†²çªçš„äº¤æ˜“ï¼š

```move
// è®¾è®¡æ— å†²çªçš„äº¤æ˜“
// æ¯ä¸ªç”¨æˆ·æœ‰ç‹¬ç«‹çš„èµ„æºï¼Œä¸ä¼šäº§ç”Ÿå†™å†²çª

struct UserArbitrageState has key {
    total_profit: u64,
    execution_count: u64,
}

public entry fun execute_arbitrage(
    user: &signer,
    // ...
) acquires UserArbitrageState {
    let user_addr = signer::address_of(user);
    
    // æ¯ä¸ªç”¨æˆ·ä¿®æ”¹è‡ªå·±çš„çŠ¶æ€ï¼Œä¸ä¼šå†²çª
    let state = borrow_global_mut<UserArbitrageState>(user_addr);
    state.execution_count = state.execution_count + 1;
    // ...
}
```

### 6.2 Table å­˜å‚¨ä¼˜åŒ–

```move
use aptos_std::table::{Self, Table};

struct ArbitrageHistory has key {
    records: Table<u64, ArbitrageRecord>,
    next_id: u64,
}

struct ArbitrageRecord has store {
    profit: u64,
    timestamp: u64,
    // ...
}

// ä½¿ç”¨ Table è€Œä¸æ˜¯ vectorï¼Œé¿å…å¤§æ•°æ®ç»“æ„çš„åºåˆ—åŒ–æˆæœ¬
```

### 6.3 äº‹ä»¶é©±åŠ¨è®¾è®¡

```move
// å‘å‡ºè¯¦ç»†äº‹ä»¶ï¼Œä¾¿äºé“¾ä¸‹ç´¢å¼•
struct DetailedArbitrageEvent has drop, store {
    executor: address,
    strategy_type: u8,
    tokens: vector<address>,
    amounts: vector<u64>,
    profit: u64,
    gas_used: u64,
    timestamp: u64,
}
```

---

## ğŸ“ æ€»ç»“

å¥—åˆ©æœºå™¨äººæ˜¯ä¸€ä¸ªå¤æ‚çš„ç³»ç»Ÿå·¥ç¨‹ï¼Œéœ€è¦ï¼š

1. **æ¶æ„è®¾è®¡**: æ¨¡å—åŒ–ã€å¯æ‰©å±•ã€é«˜å¯ç”¨
2. **å®æ—¶æ€§**: ä½å»¶è¿Ÿçš„æ•°æ®è·å–å’Œå¤„ç†
3. **å‡†ç¡®æ€§**: ç²¾ç¡®çš„åˆ©æ¶¦è®¡ç®—å’Œé£é™©è¯„ä¼°
4. **å¯é æ€§**: å®Œå–„çš„é”™è¯¯å¤„ç†å’Œé‡è¯•æœºåˆ¶
5. **å®‰å…¨æ€§**: å¤šå±‚æ¬¡çš„é£é™©æ§åˆ¶
6. **æ€§èƒ½**: å……åˆ†åˆ©ç”¨å¹¶å‘å’Œç¼“å­˜

æŒæ¡è¿™äº›æ ¸å¿ƒæ¦‚å¿µåï¼Œä½ å°±èƒ½æ„å»ºå‡ºé«˜æ•ˆã€ç¨³å®šã€ç›ˆåˆ©çš„å¥—åˆ©æœºå™¨äººç³»ç»Ÿï¼

---

**ä¸‹ä¸€æ­¥**: æŸ¥çœ‹ `ä»£ç ç¤ºä¾‹.move` äº†è§£å®Œæ•´çš„å®ç°ä»£ç ã€‚

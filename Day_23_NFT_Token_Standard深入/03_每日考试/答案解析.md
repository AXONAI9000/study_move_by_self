# Day 23 每日考试 - 答案解析

## 选择题答案解析

### 第一部分：基础概念

#### 1. Aptos Token Standard v2 的核心特性是什么？
**答案：B - 基于 Object Model 实现**

**解析**：
- Token v2 的最大改进是采用了 Object Model，而不是之前的账户模型
- Object Model 使得 NFT 成为独立的对象，拥有自己的地址和资源
- 这种设计更灵活、更高效，支持更复杂的功能

错误选项分析：
- A：Token v2 不使用账户模型，这是 v1 的设计
- C：Token v2 完全支持版税功能
- D：可以选择固定或无限供应量

---

#### 2. 以下关于 Collection 的说法，哪个是正确的？
**答案：C - Collection 可以配置版税信息**

**解析**：
```move
let constructor_ref = collection::create_fixed_collection(
    creator,
    description,
    max_supply,
    name,
    option::some(royalty::create(numerator, denominator, payee)),  // 版税配置
    uri,
);
```

Collection 在创建时可以设置版税，后续所有 Token 都会继承这个版税配置（除非 Token 指定自己的版税）。

---

#### 3. `create_fixed_collection` 和 `create_unlimited_collection` 的主要区别？
**答案：B - 前者有最大供应量限制，后者没有**

**解析**：
- `create_fixed_collection(max_supply: u64, ...)`：创建时必须指定 max_supply
- `create_unlimited_collection(...)`：不限制供应量，可以无限铸造

两者在其他方面（版税、URI 修改等）功能相同。

---

#### 4. 在 Aptos Token v2 中，Token 的所有权如何表示？
**答案：B - 通过 Object 的 owner 字段**

**解析**：
Token 是一个 Object，所有权信息存储在 Object 的内部结构中：
```move
// 检查所有权
object::is_owner(token, account_addr)

// 获取所有者
let owner = object::owner(token);
```

这与 Token v1 完全不同，v1 使用 `TokenStore` 资源存储在账户下。

---

#### 5. 以下哪个引用用于修改 Token 的元数据？
**答案：C - MutatorRef**

**解析**：
```move
let mutator_ref = token::generate_mutator_ref(&constructor_ref);

// 修改描述
token::set_description(&mutator_ref, new_description);

// 修改 URI
token::set_uri(&mutator_ref, new_uri);
```

各引用的作用：
- `MutatorRef`：修改 Token 元数据（名称、描述、URI）
- `TransferRef`：控制转移权限
- `DeleteRef`：销毁 Token
- `ExtendRef`：生成 Signer，访问 Token 内部资源

---

#### 6. Property Map 不支持以下哪种数据类型？
**答案：C - vector<String>**

**解析**：
Property Map 支持的类型：
- 整数：`u8`, `u64`, `u128`, `u256`
- 布尔：`bool`
- 地址：`address`
- 字符串：`String`
- 字节数组：`vector<u8>`

**不支持**嵌套复杂类型（如 `vector<String>`），如果需要存储多个字符串，可以：
1. 序列化为 `vector<u8>`
2. 使用多个属性（`key1`, `key2`, ...）

---

#### 7. 版税计算公式是？
**答案：B - price * (royalty_numerator / royalty_denominator)**

**解析**：
```move
let royalty = token::royalty(token);
let numerator = royalty::numerator(&royalty);       // 如 250
let denominator = royalty::denominator(&royalty);   // 如 10000
let royalty_amount = (price * numerator) / denominator;
// 如果 price = 1000, royalty = 250/10000 = 2.5%
// royalty_amount = (1000 * 250) / 10000 = 25
```

注意：先乘后除，避免精度损失。

---

#### 8. 以下关于 DeleteRef 的说法，哪个是正确的？
**答案：C - DeleteRef 存储在 Token 对象中，可以被转移**

**解析**：
```move
struct TokenRefs has key {
    delete_ref: DeleteRef,
    extend_ref: ExtendRef,
    // ...
}

// 存储在 Token 对象内部
move_to(&token_signer, TokenRefs { ... });
```

- DeleteRef 存储在 Token 对象的资源中，随 Token 一起转移
- 理论上任何拥有 Token 的人都可以使用 DeleteRef 销毁它
- 实际使用中需要通过权限控制限制销毁行为

---

### 第二部分：进阶知识

#### 9. `option::none()` 在 create_named_token 中的作用？
**答案：B - 创建一个继承 Collection 版税的 NFT**

**解析**：
```move
token::create_named_token(
    creator,
    collection_name,
    description,
    name,
    option::none(),  // 不设置 Token 特定版税，使用 Collection 的
    uri,
);
```

如果需要 Token 有独立版税：
```move
option::some(royalty::create(numerator, denominator, payee))
```

---

#### 10. 如何禁止 Token 的自由转移？
**答案：D - A 和 B 都可以**

**解析**：
方法一：不生成 TransferRef
```move
let constructor_ref = token::create(...);
// 不调用 object::generate_transfer_ref(&constructor_ref)
```

方法二：生成后禁用
```move
let transfer_ref = object::generate_transfer_ref(&constructor_ref);
object::disable_ungated_transfer(&transfer_ref);
```

禁用后只能通过 `LinearTransferRef` 转移（需要有权限的代码控制）。

---

#### 11. 如何获取 Collection 的地址？
**答案：B - collection::create_collection_address**

**解析**：
```move
let collection_addr = collection::create_collection_address(
    &creator_address,
    &collection_name
);

// 然后转换为对象
let collection_obj = object::address_to_object<collection::Collection>(collection_addr);
```

这是确定性地址生成，基于创建者地址和 Collection 名称。

---

#### 12. Property Map 更新操作需要什么权限？
**答案：C - 持有 PropertyMutatorRef 的账户**

**解析**：
```move
struct TokenRefs has key {
    property_mutator_ref: property_map::MutatorRef,
    // ...
}

// 只有持有 MutatorRef 的代码才能修改属性
property_map::update_typed(&mutator_ref, &key, new_value);
```

- 不是 Token 所有者就能修改
- 不是创建者就能修改
- 必须有 `PropertyMutatorRef`

---

#### 13. 以下关于 ExtendRef 的说法，哪个是错误的？
**答案：C - 可以转移 Object 的所有权**

**解析**：
`ExtendRef` 的作用：
```move
let extend_ref = object::generate_extend_ref(&constructor_ref);

// 生成 Signer（访问 Object 内部资源）
let object_signer = object::generate_signer_for_extending(&extend_ref);

// 存储额外数据
move_to(&object_signer, CustomData { ... });
```

`ExtendRef` **不能**用于转移所有权，转移需要：
- 所有者调用 `object::transfer`
- 或使用 `TransferRef`

---

#### 14. Token 的唯一标识符是什么？
**答案：B - Token 的 Object 地址**

**解析**：
每个 Token 都有唯一的 Object 地址：
```move
let token_addr = object::object_address(&token);
```

- Token 名称可能重复（不同 Collection）
- URI 可能相同
- 只有 Object 地址是全局唯一的

---

### 第三部分：实战应用

#### 15. 代码问题分析
**答案：D - 以上都是**

**问题分析**：
```move
public entry fun mint_nft(creator: &signer, collection_name: String) {
    let constructor_ref = token::create_named_token(...);
    // 问题：
    // 1. 没有检查供应量
    // 2. 没有保存 MutatorRef、PropertyMutatorRef 等
    // 3. 没有更新 minted_count
    // 4. 没有发出事件
}
```

正确实现：
```move
public entry fun mint_nft(...) acquires CollectionStats {
    // 1. 检查供应量
    let stats = borrow_global_mut<CollectionStats>(collection_addr);
    assert!(stats.minted_count < stats.max_supply, ERROR_MAX_SUPPLY);
    
    // 2. 创建 Token
    let constructor_ref = token::create_named_token(...);
    
    // 3. 保存引用
    let mutator_ref = token::generate_mutator_ref(&constructor_ref);
    let property_mutator_ref = property_map::generate_mutator_ref(&constructor_ref);
    move_to(&token_signer, TokenRefs { mutator_ref, property_mutator_ref, ... });
    
    // 4. 更新统计
    stats.minted_count = stats.minted_count + 1;
    
    // 5. 发出事件
    event::emit(TokenMintedEvent { ... });
}
```

---

#### 16. 带版税转移的正确顺序
**答案：C - 1-2-5-4-3**

**解析**：
```move
public entry fun buy_nft(buyer: &signer, seller: address, token: Object<Token>, price: u64) {
    // 1. 验证买家余额充足
    assert!(coin::balance<APT>(buyer_addr) >= price, ERROR_INSUFFICIENT);
    
    // 2. 计算版税金额
    let royalty_amount = (price * numerator) / denominator;
    let seller_amount = price - royalty_amount;
    
    // 3. 支付创作者版税（先支付！）
    coin::transfer<APT>(buyer, creator_addr, royalty_amount);
    
    // 4. 支付卖家
    coin::transfer<APT>(buyer, seller, seller_amount);
    
    // 5. 转移 Token（最后转移！）
    object::transfer(seller_signer, token, buyer_addr);
}
```

原因：先完成资金转移，确保支付成功后再转移 Token，避免原子性问题。

---

#### 17. 实现"灵魂绑定 NFT"的方法
**答案：D - A 或 B**

**解析**：
方法 A：不生成 TransferRef
```move
let constructor_ref = token::create(...);
// 不调用：
// let transfer_ref = object::generate_transfer_ref(&constructor_ref);
```

方法 B：生成后禁用
```move
let transfer_ref = object::generate_transfer_ref(&constructor_ref);
object::disable_ungated_transfer(&transfer_ref);
```

两种方法都可以阻止普通转移，区别：
- 方法 A：完全不能转移
- 方法 B：可以通过 `LinearTransferRef` 转移（合约控制）

---

### 第四部分：综合分析

#### 18. 项目需求与引用选择
**答案：A - 1, 2, 5**

**需求分析**：
1. ✅ NFT 总量 10000 → 需要 `CollectionStats`，不需要特定 Token 引用
2. ✅ 版税 2.5% → Collection 级别配置，不需要 Token 引用
3. ✅ 属性动态更新 → 需要 **PropertyMutatorRef (2)**
4. ✅ 支持 NFT 升级（修改 URI）→ 需要 **MutatorRef (1)**
5. ✅ 记录转移历史 → 需要 **ExtendRef (5)** 存储历史数据

不需要的引用：
- `TransferRef` (3)：允许自由转移，不需要控制
- `DeleteRef` (4)：没有销毁需求

```move
struct TokenRefs has key {
    mutator_ref: token::MutatorRef,               // (1)
    property_mutator_ref: property_map::MutatorRef,  // (2)
    extend_ref: object::ExtendRef,                // (5)
}

struct TransferHistory has key {
    records: vector<TransferRecord>,
}

// 使用 ExtendRef 存储历史
let signer = object::generate_signer_for_extending(&extend_ref);
move_to(&signer, TransferHistory { records: vector::empty() });
```

---

#### 19. 批量铸造性能优化
**答案：B - 选项 B 更优**

**性能分析**：

**选项 A**（性能差）：
```move
public entry fun batch_mint_v1(creator: &signer, collection: String, count: u64) {
    let i = 0;
    while (i < count) {
        mint_nft(creator, collection, ...);  // 每次调用都借用 CollectionStats
        i = i + 1;
    };
}
```
- 每次循环调用 `mint_nft`
- 每次调用都执行 `borrow_global_mut<CollectionStats>`
- **10 次铸造 = 10 次全局资源借用**

**选项 B**（性能优）：
```move
public entry fun batch_mint_v2(creator: &signer, collection: String, names: vector<String>) {
    let stats = borrow_global_mut<CollectionStats>(collection_addr);  // 只借用一次
    let len = vector::length(&names);
    let i = 0;
    while (i < len) {
        // 创建 Token
        stats.minted_count = stats.minted_count + 1;
        i = i + 1;
    };
}
```
- 循环外借用一次 `CollectionStats`
- 循环内直接修改
- **10 次铸造 = 1 次全局资源借用**

Gas 节省估计：约 30-40%

---

#### 20. NFT 市场交易实现
**答案：A - 选项 A 正确**

**安全性分析**：

**选项 A**（正确）：
```move
// 先转账，后转 Token
coin::transfer<APT>(buyer, creator, royalty_amount);   // 1. 版税
coin::transfer<APT>(buyer, seller, seller_amount);     // 2. 卖家收入
object::transfer(seller_signer, token, buyer_addr);    // 3. 转移 Token
```
- 如果转账失败（余额不足），交易回滚，Token 不转移
- 如果转账成功但 Token 转移失败，交易也会回滚
- ✅ 原子性保证

**选项 B**（有风险）：
```move
// 先转 Token，后转账
object::transfer(seller_signer, token, buyer_addr);    // 1. Token 已转移
coin::transfer<APT>(buyer, creator, royalty_amount);   // 2. 可能失败
coin::transfer<APT>(buyer, seller, seller_amount);     // 3. 可能失败
```
- 如果 Token 转移成功，但买家余额不足
- Token 已经转给买家，但卖家没收到钱
- ❌ 需要额外的回滚逻辑

**更安全的实现**（托管模式）：
```move
public entry fun safe_buy_nft(...) {
    // 1. 买家先将资金存入托管合约
    coin::transfer<APT>(buyer, @escrow, price);
    
    // 2. 卖家将 Token 转入托管
    object::transfer(seller, token, @escrow);
    
    // 3. 托管合约验证后分配
    //    - 版税给创作者
    //    - 剩余给卖家
    //    - Token 给买家
}
```

---

## 编程题答案

### 编程题一：艺术品 NFT Collection

```move
module art_nft::gallery {
    use std::signer;
    use std::string::{Self, String};
    use std::option;
    use aptos_framework::object::{Self, Object, ExtendRef};
    use aptos_framework::event;
    use aptos_token_objects::collection;
    use aptos_token_objects::royalty;

    const ERROR_NOT_CREATOR: u64 = 1;

    struct CollectionConfig has key {
        extend_ref: ExtendRef,
        mutator_ref: collection::MutatorRef,
    }

    struct CollectionStats has key {
        minted_count: u64,
        max_supply: u64,
    }

    #[event]
    struct CollectionCreatedEvent has store, drop {
        creator: address,
        collection_address: address,
        collection_name: String,
    }

    public entry fun create_gallery(
        creator: &signer,
        description: String,
        uri: String,
    ) {
        let creator_addr = signer::address_of(creator);
        let collection_name = string::utf8(b"Digital Art Gallery");

        // 创建 Collection（版税 3%）
        let constructor_ref = collection::create_fixed_collection(
            creator,
            description,
            500,  // max_supply
            collection_name,
            option::some(royalty::create(300, 10000, creator_addr)),  // 3%
            uri,
        );

        // 生成引用
        let extend_ref = object::generate_extend_ref(&constructor_ref);
        let mutator_ref = collection::generate_mutator_ref(&constructor_ref);
        let collection_signer = object::generate_signer(&constructor_ref);

        // 存储配置
        move_to(&collection_signer, CollectionConfig {
            extend_ref,
            mutator_ref,
        });

        move_to(&collection_signer, CollectionStats {
            minted_count: 0,
            max_supply: 500,
        });

        // 发出事件
        let collection_addr = object::address_from_constructor_ref(&constructor_ref);
        event::emit(CollectionCreatedEvent {
            creator: creator_addr,
            collection_address: collection_addr,
            collection_name,
        });
    }

    public entry fun update_description(
        creator: &signer,
        collection: Object<collection::Collection>,
        new_description: String,
    ) acquires CollectionConfig {
        let collection_addr = object::object_address(&collection);
        let config = borrow_global<CollectionConfig>(collection_addr);

        // 验证创建者
        let creator_addr = signer::address_of(creator);
        let collection_creator = collection::creator(collection);
        assert!(creator_addr == collection_creator, ERROR_NOT_CREATOR);

        // 修改描述
        collection::set_description(&config.mutator_ref, new_description);
    }

    public entry fun update_uri(
        creator: &signer,
        collection: Object<collection::Collection>,
        new_uri: String,
    ) acquires CollectionConfig {
        let collection_addr = object::object_address(&collection);
        let config = borrow_global<CollectionConfig>(collection_addr);

        // 验证创建者
        let creator_addr = signer::address_of(creator);
        let collection_creator = collection::creator(collection);
        assert!(creator_addr == collection_creator, ERROR_NOT_CREATOR);

        // 修改 URI
        collection::set_uri(&config.mutator_ref, new_uri);
    }

    public fun get_gallery_info(
        collection: Object<collection::Collection>
    ): (String, String, u64, u64) acquires CollectionStats {
        let name = collection::name(collection);
        let description = collection::description(collection);
        
        let collection_addr = object::object_address(&collection);
        let stats = borrow_global<CollectionStats>(collection_addr);
        
        (name, description, stats.minted_count, stats.max_supply)
    }
}
```

---

### 编程题二：带属性的 NFT 铸造

```move
module art_nft::artwork {
    use std::signer;
    use std::string::{Self, String};
    use std::option;
    use aptos_framework::object::{Self, Object};
    use aptos_token_objects::token::{Self, Token};
    use aptos_token_objects::property_map;
    use art_nft::gallery;

    const ERROR_MAX_SUPPLY_REACHED: u64 = 1;
    const ERROR_NOT_OWNER: u64 = 2;

    struct TokenRefs has key {
        property_mutator_ref: property_map::MutatorRef,
    }

    public entry fun mint_artwork(
        creator: &signer,
        collection_name: String,
        name: String,
        description: String,
        uri: String,
        artist: String,
        created_year: u64,
        medium: String,
        edition: u64,
        is_signed: bool,
    ) {
        // 创建 Token
        let constructor_ref = token::create_named_token(
            creator,
            collection_name,
            description,
            name,
            option::none(),
            uri,
        );

        // 生成属性可变引用
        let property_mutator_ref = property_map::generate_mutator_ref(&constructor_ref);
        let token_signer = object::generate_signer(&constructor_ref);

        // 添加自定义属性
        property_map::add_typed(&property_mutator_ref, &string::utf8(b"artist"), artist);
        property_map::add_typed(&property_mutator_ref, &string::utf8(b"created_year"), created_year);
        property_map::add_typed(&property_mutator_ref, &string::utf8(b"medium"), medium);
        property_map::add_typed(&property_mutator_ref, &string::utf8(b"edition"), edition);
        property_map::add_typed(&property_mutator_ref, &string::utf8(b"is_signed"), is_signed);
        property_map::add_typed(&property_mutator_ref, &string::utf8(b"exhibition_count"), 0u64);

        // 保存引用
        move_to(&token_signer, TokenRefs {
            property_mutator_ref,
        });
    }

    public entry fun add_exhibition(
        owner: &signer,
        token: Object<Token>,
        exhibition_name: String,
        location: String,
        year: u64,
    ) acquires TokenRefs {
        // 验证所有权
        let owner_addr = signer::address_of(owner);
        assert!(object::is_owner(token, owner_addr), ERROR_NOT_OWNER);

        // 获取引用
        let token_addr = object::object_address(&token);
        let refs = borrow_global<TokenRefs>(token_addr);

        // 读取并更新 exhibition_count
        let count_key = string::utf8(b"exhibition_count");
        let current_count = property_map::read_u64(&token, &count_key);
        property_map::update_typed(&refs.property_mutator_ref, &count_key, current_count + 1);

        // 添加展览记录
        let exhibition_key = string::utf8(b"exhibition_");
        string::append(&mut exhibition_key, u64_to_string(current_count));
        
        let record = string::utf8(b"");
        string::append(&mut record, exhibition_name);
        string::append_utf8(&mut record, b"|");
        string::append(&mut record, location);
        string::append_utf8(&mut record, b"|");
        string::append(&mut record, u64_to_string(year));
        
        property_map::add_typed(&refs.property_mutator_ref, &exhibition_key, record);
    }

    public fun get_artwork_info(token: Object<Token>): ArtworkInfo {
        ArtworkInfo {
            artist: property_map::read_string(&token, &string::utf8(b"artist")),
            created_year: property_map::read_u64(&token, &string::utf8(b"created_year")),
            medium: property_map::read_string(&token, &string::utf8(b"medium")),
            edition: property_map::read_u64(&token, &string::utf8(b"edition")),
            is_signed: property_map::read_bool(&token, &string::utf8(b"is_signed")),
            owner: object::owner(token),
        }
    }

    struct ArtworkInfo has drop {
        artist: String,
        created_year: u64,
        medium: String,
        edition: u64,
        is_signed: bool,
        owner: address,
    }

    fun u64_to_string(value: u64): String {
        // 简化实现
        if (value == 0) {
            string::utf8(b"0")
        } else {
            string::utf8(b"1")  // 实际需要完整实现
        }
    }
}
```

---

### 其他编程题答案（由于篇幅限制，提供关键部分）

**编程题三关键代码**：
```move
public entry fun buy_nft(buyer: &signer, seller: address, token: Object<Token>, price: u64) {
    // 1. 验证
    assert!(object::is_owner(token, seller), ERROR_NOT_OWNER);
    
    // 2. 获取版税信息
    let royalty = token::royalty(token);
    let numerator = royalty::numerator(&royalty);
    let denominator = royalty::denominator(&royalty);
    let creator = royalty::payee_address(&royalty);
    
    // 3. 计算金额
    let royalty_amount = (price * numerator) / denominator;
    let seller_amount = price - royalty_amount;
    
    // 4. 支付（先转账）
    coin::transfer<AptosCoin>(buyer, creator, royalty_amount);
    coin::transfer<AptosCoin>(buyer, seller, seller_amount);
    
    // 5. 转移 Token（后转移）
    object::transfer(seller_signer, token, signer::address_of(buyer));
}
```

---

**总结**：
- 选择题重点：Object Model 理解、版税计算、引用类型
- 编程题重点：Collection 管理、属性系统、交易逻辑
- 难点：批量优化、原子性保证、权限控制

# Day 02 æ¯æ—¥è€ƒè¯• - ç­”æ¡ˆè§£æ

## é€‰æ‹©é¢˜ç­”æ¡ˆ

### ç¬¬ 1 é¢˜ï¼šB

**è§£æ**ï¼šMoveæ”¯æŒå››ç§æ•´æ•°ç±»å‹ï¼š`u8`ã€`u64`ã€`u128`ã€`u256`ã€‚æ²¡æœ‰`u32`ç±»å‹ã€‚

**çŸ¥è¯†ç‚¹**ï¼šåŸºæœ¬æ•°æ®ç±»å‹

---

### ç¬¬ 2 é¢˜ï¼šB

**è§£æ**ï¼šMove**åªæ”¯æŒæ— ç¬¦å·æ•´æ•°**ï¼Œæ²¡æœ‰æœ‰ç¬¦å·æ•´æ•°ç±»å‹ã€‚è¿™æ˜¯ä¸ºäº†é˜²æ­¢ä½™é¢å˜ä¸ºè´Ÿæ•°ç­‰å®‰å…¨é—®é¢˜ã€‚

**çŸ¥è¯†ç‚¹**ï¼šç±»å‹ç³»ç»Ÿè®¾è®¡ç†å¿µ

---

### ç¬¬ 3 é¢˜ï¼šB

**è§£æ**ï¼š`u8`æ˜¯8ä½æ— ç¬¦å·æ•´æ•°ï¼Œå–å€¼èŒƒå›´æ˜¯0åˆ°255ï¼ˆ2^8 - 1ï¼‰ã€‚

**çŸ¥è¯†ç‚¹**ï¼šæ•´æ•°ç±»å‹èŒƒå›´

---

### ç¬¬ 4 é¢˜ï¼šC

**è§£æ**ï¼š1000è½¬æ¢ä¸ºu8æ—¶ä¼šå‘ç”Ÿæˆªæ–­ã€‚1000 % 256 = 232ï¼Œæ‰€ä»¥y = 232ã€‚

**è®¡ç®—è¿‡ç¨‹**ï¼š
```
1000 / 256 = 3 ä½™ 232
æ‰€ä»¥ 1000 mod 256 = 232
```

**çŸ¥è¯†ç‚¹**ï¼šç±»å‹è½¬æ¢æˆªæ–­

---

### ç¬¬ 5 é¢˜ï¼šB

**è§£æ**ï¼šMoveä¸­çš„å˜é‡**é»˜è®¤æ˜¯ä¸å¯å˜çš„**ã€‚éœ€è¦ä½¿ç”¨`mut`å…³é”®å­—å£°æ˜å¯å˜å˜é‡ã€‚

**çŸ¥è¯†ç‚¹**ï¼šå˜é‡å¯å˜æ€§

---

### ç¬¬ 6 é¢˜ï¼šC

**è§£æ**ï¼šé€‰é¡¹Cè¯•å›¾ä¿®æ”¹ä¸å¯å˜å˜é‡ï¼Œä¼šç¼–è¯‘é”™è¯¯ã€‚é€‰é¡¹Dæ˜¯å˜é‡é®è”½ï¼Œåˆæ³•ã€‚

**çŸ¥è¯†ç‚¹**ï¼šä¸å¯å˜å˜é‡

---

### ç¬¬ 7 é¢˜ï¼šD

**è§£æ**ï¼šé®è”½æ˜¯**åˆ›å»ºæ–°å˜é‡**ï¼Œä¸ä¼šä¿®æ”¹åŸå˜é‡ã€‚æ–°å˜é‡åªæ˜¯é®ç›–äº†æ—§å˜é‡çš„å¯è§æ€§ã€‚

**çŸ¥è¯†ç‚¹**ï¼šå˜é‡é®è”½

---

### ç¬¬ 8 é¢˜ï¼šC

**è§£æ**ï¼š255 + 1ä¼šå¯¼è‡´æº¢å‡ºï¼ŒMoveä¼šåœ¨è¿è¡Œæ—¶**abort**ï¼Œä¸ä¼šé™é»˜å›ç»•ã€‚

**çŸ¥è¯†ç‚¹**ï¼šæº¢å‡ºæ£€æŸ¥

---

### ç¬¬ 9 é¢˜ï¼šC

**è§£æ**ï¼šå¸¸é‡ä½¿ç”¨`UPPER_CASE`å‘½åè§„èŒƒï¼Œå¦‚`MAX_SUPPLY`ã€‚

**çŸ¥è¯†ç‚¹**ï¼šå‘½åè§„èŒƒ

---

### ç¬¬ 10 é¢˜ï¼šC

**è§£æ**ï¼šæ­£ç¡®çš„å¸¸é‡å®šä¹‰è¯­æ³•æ˜¯`const NAME: type = value;`

**çŸ¥è¯†ç‚¹**ï¼šå¸¸é‡å®šä¹‰

---

### ç¬¬ 11 é¢˜ï¼šC

**è§£æ**ï¼šåŸºæœ¬ç±»å‹ï¼ˆu8ã€u64ç­‰ï¼‰æœ‰Copyèƒ½åŠ›ä¼šè¢«å¤åˆ¶ï¼›ç»“æ„ä½“é»˜è®¤ä¼šè¢«ç§»åŠ¨ï¼Œé™¤éæ˜¾å¼å£°æ˜`copy`èƒ½åŠ›ã€‚

**çŸ¥è¯†ç‚¹**ï¼šMoveè¯­ä¹‰

---

### ç¬¬ 12 é¢˜ï¼šB

**è§£æ**ï¼š`Box`æ²¡æœ‰`copy`èƒ½åŠ›ï¼Œ`box1`è¢«ç§»åŠ¨åˆ°`box2`åä¸èƒ½å†ä½¿ç”¨ã€‚

**è¯¦ç»†è¯´æ˜**ï¼š
```move
let box2 = box1;  // box1è¢«ç§»åŠ¨ï¼Œæ‰€æœ‰æƒè½¬ç§»
let box3 = box1;  // âŒ ç¼–è¯‘é”™è¯¯ï¼šbox1å·²ç»ä¸å­˜åœ¨
```

**çŸ¥è¯†ç‚¹**ï¼šæ‰€æœ‰æƒè½¬ç§»

---

### ç¬¬ 13 é¢˜ï¼šB

**è§£æ**ï¼š`copy`èƒ½åŠ›å…è®¸å€¼è¢«å¤åˆ¶ã€‚

**å››ç§èƒ½åŠ›**ï¼š
- `copy`: å¯ä»¥å¤åˆ¶
- `drop`: å¯ä»¥è¢«ä¸¢å¼ƒ
- `key`: å¯ä»¥ä½œä¸ºå…¨å±€å­˜å‚¨çš„é”®
- `store`: å¯ä»¥å­˜å‚¨åœ¨å…¶ä»–ç»“æ„ä½“ä¸­

**çŸ¥è¯†ç‚¹**ï¼šèƒ½åŠ›ç³»ç»Ÿ

---

### ç¬¬ 14 é¢˜ï¼šC

**è§£æ**ï¼šå¯å˜å¼•ç”¨å’Œä¸å¯å˜å¼•ç”¨**ä¸èƒ½åŒæ—¶å­˜åœ¨**ã€‚è¿™æ˜¯å€Ÿç”¨è§„åˆ™çš„æ ¸å¿ƒã€‚

**å€Ÿç”¨è§„åˆ™**ï¼š
1. å¯ä»¥æœ‰å¤šä¸ªä¸å¯å˜å¼•ç”¨
2. å¯å˜å¼•ç”¨åŒæ—¶åªèƒ½æœ‰ä¸€ä¸ª
3. å¯å˜å¼•ç”¨å’Œä¸å¯å˜å¼•ç”¨äº’æ–¥

**çŸ¥è¯†ç‚¹**ï¼šå€Ÿç”¨è§„åˆ™

---

### ç¬¬ 15 é¢˜ï¼šB

**è§£æ**ï¼šé€šè¿‡å¯å˜å¼•ç”¨ä¿®æ”¹å€¼ï¼ŒåŸå˜é‡çš„å€¼ä¹Ÿä¼šæ”¹å˜ã€‚`*ref_x = 20`å°†xçš„å€¼æ”¹ä¸º20ã€‚

**çŸ¥è¯†ç‚¹**ï¼šå¯å˜å¼•ç”¨

---

### ç¬¬ 16 é¢˜ï¼šC

**è§£æ**ï¼šå…ƒç»„`(u64, bool, address)`åŒ…å«3ä¸ªå…ƒç´ ã€‚

**çŸ¥è¯†ç‚¹**ï¼šå…ƒç»„

---

### ç¬¬ 17 é¢˜ï¼šA

**è§£æ**ï¼šå…ƒç»„ä½¿ç”¨åœ†æ‹¬å·è§£æ„ï¼š`let (a, b, c) = triple;`

**çŸ¥è¯†ç‚¹**ï¼šå…ƒç»„è§£æ„

---

### ç¬¬ 18 é¢˜ï¼šC

**è§£æ**ï¼šåœ°å€ç±»å‹åªæ”¯æŒç›¸ç­‰æ€§æ¯”è¾ƒï¼ˆ`==`ã€`!=`ï¼‰ï¼Œä¸æ”¯æŒç®—æœ¯è¿ç®—ã€‚

**çŸ¥è¯†ç‚¹**ï¼šåœ°å€ç±»å‹æ“ä½œ

---

### ç¬¬ 19 é¢˜ï¼šB

**è§£æ**ï¼šMoveçš„é™¤æ³•æ˜¯**æ•´æ•°é™¤æ³•**ï¼Œç»“æœå‘ä¸‹å–æ•´ã€‚10 / 3 = 3ã€‚

**çŸ¥è¯†ç‚¹**ï¼šæ•´æ•°é™¤æ³•

---

### ç¬¬ 20 é¢˜ï¼šD

**è§£æ**ï¼š`**`ä¸æ˜¯Moveçš„è¿ç®—ç¬¦ã€‚Moveæ”¯æŒçš„ä½è¿ç®—æœ‰ï¼š`&`ã€`|`ã€`^`ã€`<<`ã€`>>`ã€‚

**çŸ¥è¯†ç‚¹**ï¼šä½è¿ç®—ç¬¦

---

### ç¬¬ 21 é¢˜ï¼šD

**è§£æ**ï¼š`assert!(condition, error_code)` - å½“æ¡ä»¶ä¸º**false**æ—¶ç¨‹åºä¸­æ­¢å¹¶è¿”å›é”™è¯¯ç ã€‚

**çŸ¥è¯†ç‚¹**ï¼šæ–­è¨€

---

### ç¬¬ 22 é¢˜ï¼šB

**è§£æ**ï¼šç¼ºå°‘**ä¸‹æº¢æ£€æŸ¥**ã€‚å¦‚æœamount > *balanceï¼Œä¼šå‘ç”Ÿä¸‹æº¢å¯¼è‡´abortã€‚

**æ­£ç¡®åšæ³•**ï¼š
```move
public fun withdraw(balance: &mut u64, amount: u64) {
    assert!(*balance >= amount, E_INSUFFICIENT_BALANCE);
    *balance = *balance - amount;
}
```

**çŸ¥è¯†ç‚¹**ï¼šå®‰å…¨æ€§æ£€æŸ¥

---

### ç¬¬ 23 é¢˜ï¼šB

**è§£æ**ï¼šå‰è€…æ˜¯**ä¿®æ”¹åŒä¸€ä¸ªå˜é‡**ï¼Œåè€…æ˜¯**åˆ›å»ºæ–°å˜é‡**ï¼ˆé®è”½ï¼‰ã€‚

**åŒºåˆ«**ï¼š
```move
let mut x = 10;
x = 20;  // ä¿®æ”¹x

let x = 10;
let x = 20;  // åˆ›å»ºæ–°çš„xï¼Œé®è”½æ—§çš„x
```

**çŸ¥è¯†ç‚¹**ï¼šå¯å˜æ€§ vs é®è”½

---

### ç¬¬ 24 é¢˜ï¼šC

**è§£æ**ï¼š`key`èƒ½åŠ›å…è®¸å€¼ä½œä¸ºå…¨å±€å­˜å‚¨çš„é”®ã€‚`store`å…è®¸å€¼è¢«å­˜å‚¨åœ¨å…¶ä»–ç»“æ„ä½“ä¸­ã€‚

**çŸ¥è¯†ç‚¹**ï¼šèƒ½åŠ›ç³»ç»Ÿ

---

### ç¬¬ 25 é¢˜ï¼šD

**è§£æ**ï¼š
- `false && f()` - ä¸ä¼šæ‰§è¡Œf()ï¼ˆ&&çŸ­è·¯ï¼‰
- `true || f()` - ä¸ä¼šæ‰§è¡Œf()ï¼ˆ||çŸ­è·¯ï¼‰

**çŸ¥è¯†ç‚¹**ï¼šçŸ­è·¯æ±‚å€¼

---

### ç¬¬ 26 é¢˜ï¼ˆé™„åŠ é¢˜ï¼‰ï¼šC

**è§£æ**ï¼š`200 + 100`ä¼šå¯¼è‡´u8æº¢å‡ºï¼Œè¿è¡Œæ—¶abortã€‚

**è®¡ç®—**ï¼š200 + 100 = 300ï¼Œè¶…è¿‡u8æœ€å¤§å€¼255ã€‚

**çŸ¥è¯†ç‚¹**ï¼šè¿è¡Œæ—¶æº¢å‡ºæ£€æŸ¥

---

### ç¬¬ 27 é¢˜ï¼ˆé™„åŠ é¢˜ï¼‰ï¼šB

**è§£æ**ï¼š
- Aï¼šä¼šç§»åŠ¨ï¼ˆâœ…ï¼‰
- Bï¼šå­˜å‚¨åˆ°å…¨å±€ï¼ˆâœ… `key`èƒ½åŠ›æ”¯æŒï¼‰
- Cï¼šä¸èƒ½å¤åˆ¶ï¼ˆâŒ æ²¡æœ‰`copy`ï¼‰
- Dï¼šä¸èƒ½éšæ„ä¸¢å¼ƒï¼ˆâŒ æ²¡æœ‰`drop`ï¼‰

**çŸ¥è¯†ç‚¹**ï¼šèµ„æºç±»å‹çš„èƒ½åŠ›é™åˆ¶

---

## ç¼–ç¨‹é¢˜ç­”æ¡ˆ

### ç¼–ç¨‹é¢˜ 1ï¼šå®‰å…¨çš„æ•°å€¼è¿ç®—åº“

```move
module my_addr::safe_math {
    
    const MAX_U64: u128 = 18446744073709551615;
    const E_OVERFLOW: u64 = 1;
    const E_UNDERFLOW: u64 = 2;
    const E_DIVISION_BY_ZERO: u64 = 3;

    public fun checked_add(a: u64, b: u64): u64 {
        let a_u128 = (a as u128);
        let b_u128 = (b as u128);
        let sum = a_u128 + b_u128;
        assert!(sum <= MAX_U64, E_OVERFLOW);
        (sum as u64)
    }

    public fun checked_sub(a: u64, b: u64): u64 {
        assert!(a >= b, E_UNDERFLOW);
        a - b
    }

    public fun checked_mul(a: u64, b: u64): u64 {
        let a_u128 = (a as u128);
        let b_u128 = (b as u128);
        let product = a_u128 * b_u128;
        assert!(product <= MAX_U64, E_OVERFLOW);
        (product as u64)
    }

    public fun checked_div(a: u64, b: u64): u64 {
        assert!(b != 0, E_DIVISION_BY_ZERO);
        a / b
    }

    public fun percentage(value: u64, percent: u64): u64 {
        let value_u128 = (value as u128);
        let percent_u128 = (percent as u128);
        let result = (value_u128 * percent_u128) / 100;
        assert!(result <= MAX_U64, E_OVERFLOW);
        (result as u64)
    }
}
```

**å…³é”®ç‚¹**ï¼š
1. ä½¿ç”¨u128è¿›è¡Œä¸­é—´è®¡ç®—é¿å…æº¢å‡º
2. æ¯æ¬¡è¿ç®—åæ£€æŸ¥ç»“æœæ˜¯å¦åœ¨u64èŒƒå›´å†…
3. å‡æ³•å‰æ£€æŸ¥a >= b
4. é™¤æ³•å‰æ£€æŸ¥é™¤æ•°ä¸ä¸º0

---

### ç¼–ç¨‹é¢˜ 2ï¼šç±»å‹å®‰å…¨çš„æ¸©åº¦è½¬æ¢å™¨

```move
module my_addr::temperature {
    
    struct Celsius has copy, drop, store {
        value: u64
    }

    struct Fahrenheit has copy, drop, store {
        value: u64
    }

    struct Kelvin has copy, drop, store {
        value: u64
    }

    public fun celsius(value: u64): Celsius {
        Celsius { value }
    }

    public fun fahrenheit(value: u64): Fahrenheit {
        Fahrenheit { value }
    }

    public fun kelvin(value: u64): Kelvin {
        Kelvin { value }
    }

    /// F = C * 9/5 + 32
    /// å› ä¸ºvalueæ˜¯*100çš„ï¼Œæ‰€ä»¥32è¦å˜æˆ3200
    public fun celsius_to_fahrenheit(c: Celsius): Fahrenheit {
        let f_value = (c.value * 9 / 5) + 3200;
        fahrenheit(f_value)
    }

    /// K = C + 273.15
    /// 273.15 * 100 = 27315
    public fun celsius_to_kelvin(c: Celsius): Kelvin {
        let k_value = c.value + 27315;
        kelvin(k_value)
    }

    /// C = (F - 32) * 5/9
    /// (F - 3200) * 5/9
    public fun fahrenheit_to_celsius(f: Fahrenheit): Celsius {
        let c_value = if (f.value >= 3200) {
            (f.value - 3200) * 5 / 9
        } else {
            // åæ°æ¸©åº¦ä½äº32Â°Fï¼Œæ‘„æ°ä¸ºè´Ÿæ•°
            // è¿™é‡Œç®€åŒ–å¤„ç†ï¼Œå®é™…åº”è¯¥æ”¯æŒè´Ÿæ•°æˆ–ä½¿ç”¨æœ‰ç¬¦å·ç±»å‹
            0
        };
        celsius(c_value)
    }

    /// C = K - 273.15
    public fun kelvin_to_celsius(k: Kelvin): Celsius {
        let c_value = if (k.value >= 27315) {
            k.value - 27315
        } else {
            0  // å¼€å°”æ–‡ä¸åº”è¯¥ä½äº0
        };
        celsius(c_value)
    }

    public fun get_celsius_value(c: Celsius): u64 {
        c.value
    }

    public fun get_fahrenheit_value(f: Fahrenheit): u64 {
        f.value
    }

    public fun get_kelvin_value(k: Kelvin): u64 {
        k.value
    }
}
```

**å…³é”®ç‚¹**ï¼š
1. æ‰€æœ‰æ¸©åº¦å€¼éƒ½ä¹˜ä»¥100å­˜å‚¨ï¼ˆå®šç‚¹æ•°è¡¨ç¤ºï¼‰
2. è½¬æ¢å…¬å¼è¦è°ƒæ•´ï¼š32Â°F = 3200ï¼Œ273.15K = 27315
3. æ³¨æ„å¤„ç†å¯èƒ½çš„è´Ÿæ•°æƒ…å†µ
4. é™¤æ³•ä¼šæœ‰èˆå…¥ï¼Œè¿™æ˜¯æ­£å¸¸çš„

---

### ç¼–ç¨‹é¢˜ 3ï¼šå˜é‡è¿½è¸ªå™¨

```move
module my_addr::variable_tracker {
    use std::signer;
    use std::vector;

    struct VariableTracker has key {
        current_value: u64,
        history: vector<u64>,
        timestamps: vector<u64>,
        max_history: u64
    }

    const E_TRACKER_EXISTS: u64 = 1;
    const E_TRACKER_NOT_FOUND: u64 = 2;
    const E_INDEX_OUT_OF_BOUNDS: u64 = 3;

    public fun create_tracker(account: &signer, initial_value: u64, max_history: u64) {
        let addr = signer::address_of(account);
        assert!(!exists<VariableTracker>(addr), E_TRACKER_EXISTS);
        
        move_to(account, VariableTracker {
            current_value: initial_value,
            history: vector::empty<u64>(),
            timestamps: vector::empty<u64>(),
            max_history
        });
    }

    public fun update_value(account: &signer, new_value: u64, timestamp: u64) acquires VariableTracker {
        let addr = signer::address_of(account);
        let tracker = borrow_global_mut<VariableTracker>(addr);
        
        // å¦‚æœå†å²æ»¡äº†ï¼Œåˆ é™¤æœ€æ—§çš„
        if (vector::length(&tracker.history) >= tracker.max_history) {
            vector::remove(&mut tracker.history, 0);
            vector::remove(&mut tracker.timestamps, 0);
        };
        
        // å°†å½“å‰å€¼åŠ å…¥å†å²
        vector::push_back(&mut tracker.history, tracker.current_value);
        vector::push_back(&mut tracker.timestamps, timestamp);
        
        // æ›´æ–°å½“å‰å€¼
        tracker.current_value = new_value;
    }

    public fun get_current_value(addr: address): u64 acquires VariableTracker {
        borrow_global<VariableTracker>(addr).current_value
    }

    public fun get_history_count(addr: address): u64 acquires VariableTracker {
        vector::length(&borrow_global<VariableTracker>(addr).history)
    }

    public fun get_history_at(addr: address, index: u64): (u64, u64) acquires VariableTracker {
        let tracker = borrow_global<VariableTracker>(addr);
        assert!(index < vector::length(&tracker.history), E_INDEX_OUT_OF_BOUNDS);
        
        let value = *vector::borrow(&tracker.history, index);
        let timestamp = *vector::borrow(&tracker.timestamps, index);
        (value, timestamp)
    }

    public fun get_average_value(addr: address): u64 acquires VariableTracker {
        let tracker = borrow_global<VariableTracker>(addr);
        
        let sum = tracker.current_value;
        let count = 1u64;
        
        let i = 0;
        let len = vector::length(&tracker.history);
        while (i < len) {
            sum = sum + *vector::borrow(&tracker.history, i);
            count = count + 1;
            i = i + 1;
        };
        
        sum / count
    }

    public fun get_max_value(addr: address): u64 acquires VariableTracker {
        let tracker = borrow_global<VariableTracker>(addr);
        
        let max = tracker.current_value;
        
        let i = 0;
        let len = vector::length(&tracker.history);
        while (i < len) {
            let val = *vector::borrow(&tracker.history, i);
            if (val > max) {
                max = val;
            };
            i = i + 1;
        };
        
        max
    }

    public fun get_min_value(addr: address): u64 acquires VariableTracker {
        let tracker = borrow_global<VariableTracker>(addr);
        
        let min = tracker.current_value;
        
        let i = 0;
        let len = vector::length(&tracker.history);
        while (i < len) {
            let val = *vector::borrow(&tracker.history, i);
            if (val < min) {
                min = val;
            };
            i = i + 1;
        };
        
        min
    }
}
```

**å…³é”®ç‚¹**ï¼š
1. æ›´æ–°å€¼æ—¶å…ˆæ£€æŸ¥å†å²æ˜¯å¦æ»¡ï¼Œæ»¡äº†åˆ é™¤æœ€æ—§çš„
2. å°†æ—§çš„current_valueåŠ å…¥å†å²ï¼Œç„¶åæ›´æ–°current_value
3. ç»Ÿè®¡å‡½æ•°è¦åŒ…æ‹¬å½“å‰å€¼å’Œæ‰€æœ‰å†å²å€¼
4. ä½¿ç”¨å¾ªç¯éå†vector

---

## æ€»ç»“

### æ ¸å¿ƒçŸ¥è¯†ç‚¹

1. **ç±»å‹å®‰å…¨**
   - Moveåªæœ‰æ— ç¬¦å·æ•´æ•°
   - ç±»å‹è½¬æ¢å¯èƒ½æˆªæ–­
   - éœ€è¦æ˜¾å¼æ£€æŸ¥æº¢å‡º/ä¸‹æº¢

2. **å˜é‡ç³»ç»Ÿ**
   - é»˜è®¤ä¸å¯å˜
   - å¯å˜æ€§ç”¨`mut`å£°æ˜
   - é®è”½åˆ›å»ºæ–°å˜é‡

3. **Moveè¯­ä¹‰**
   - åŸºæœ¬ç±»å‹å¤åˆ¶
   - ç»“æ„ä½“é»˜è®¤ç§»åŠ¨
   - èƒ½åŠ›ç³»ç»Ÿæ§åˆ¶è¡Œä¸º

4. **å¼•ç”¨å€Ÿç”¨**
   - ä¸å¯å˜å¼•ç”¨å¯å¤šä¸ª
   - å¯å˜å¼•ç”¨ç‹¬å 
   - ä¸¤è€…ä¸èƒ½å…±å­˜

5. **å®šç‚¹æ•°**
   - ä¹˜ä»¥10^nå­˜å‚¨
   - è¿ç®—è¦è°ƒæ•´
   - æ³¨æ„ç²¾åº¦æŸå¤±

### å¸¸è§é”™è¯¯æ€»ç»“

1. å¿˜è®°æº¢å‡ºæ£€æŸ¥
2. ç±»å‹è½¬æ¢æˆªæ–­
3. å¼•ç”¨å€Ÿç”¨å†²çª
4. å®šç‚¹æ•°è¿ç®—é”™è¯¯
5. Vectoræ“ä½œé¡ºåºé”™è¯¯

### å­¦ä¹ å»ºè®®

- å¤šç»ƒä¹ ç±»å‹è½¬æ¢å’Œæº¢å‡ºæ£€æŸ¥
- ç†è§£Moveè¯­ä¹‰å’Œèƒ½åŠ›ç³»ç»Ÿ
- æŒæ¡å¼•ç”¨çš„ä½¿ç”¨åœºæ™¯
- ç†Ÿæ‚‰Vectorçš„å„ç§æ“ä½œ
- æ³¨æ„è¾¹ç•Œæ¡ä»¶å¤„ç†

ç»§ç»­åŠ æ²¹ï¼ğŸ’ª

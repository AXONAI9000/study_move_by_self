# Day 31 å®è·µä»»åŠ¡

## ğŸ“‹ ä»»åŠ¡æ¦‚è§ˆ

ä»Šå¤©æœ‰ **3 ä¸ªé€’è¿›å¼å®è·µä»»åŠ¡**ï¼Œä»åŸºç¡€é—ªç”µè´·å®ç°åˆ°å®Œæ•´çš„å¥—åˆ©ç³»ç»Ÿã€‚

| ä»»åŠ¡ | éš¾åº¦ | é¢„è®¡æ—¶é—´ | é‡ç‚¹ |
|------|------|---------|------|
| ä»»åŠ¡ä¸€ | â­â­ | 60åˆ†é’Ÿ | åŸºç¡€é—ªç”µè´·åè®® |
| ä»»åŠ¡äºŒ | â­â­â­ | 90åˆ†é’Ÿ | DEX å¥—åˆ©ç­–ç•¥ |
| ä»»åŠ¡ä¸‰ | â­â­â­â­ | 90åˆ†é’Ÿ | é—ªç”µè´·èšåˆå™¨ |

---

## ğŸ¯ ä»»åŠ¡ä¸€ï¼šå®ç°åŸºç¡€é—ªç”µè´·åè®®

### ä»»åŠ¡ç›®æ ‡

å®ç°ä¸€ä¸ªå®Œæ•´çš„å•èµ„äº§é—ªç”µè´·åè®®ï¼ŒåŒ…æ‹¬å€Ÿæ¬¾ã€è¿˜æ¬¾å’ŒåŸºç¡€ç®¡ç†åŠŸèƒ½ã€‚

### åŠŸèƒ½è¦æ±‚

#### 1. æ ¸å¿ƒæ•°æ®ç»“æ„

```move
module flash_loan::basic_pool {
    
    /// èµ„äº§æ± 
    struct Pool<phantom CoinType> has key {
        reserves: Coin<CoinType>,      // æµåŠ¨æ€§å‚¨å¤‡
        fee_rate: u64,                 // æ‰‹ç»­è´¹ç‡ï¼ˆåŸºç‚¹ï¼‰
        admin: address,                // ç®¡ç†å‘˜
        total_flash_loans: u64,        // æ€»å€Ÿè´·æ¬¡æ•°
        total_fees: u64,               // æ€»æ‰‹ç»­è´¹
        paused: bool,                  // æš‚åœæ ‡å¿—
    }
    
    /// Hot Potato
    struct FlashLoan {
        amount: u64,
        fee: u64,
    }
}
```

#### 2. å¿…éœ€å®ç°çš„å‡½æ•°

```move
// ç®¡ç†å‡½æ•°
public entry fun initialize<CoinType>(
    admin: &signer,
    initial_liquidity: u64,
    fee_rate: u64
)

public entry fun add_liquidity<CoinType>(
    provider: &signer,
    pool_address: address,
    amount: u64
)

public entry fun remove_liquidity<CoinType>(
    admin: &signer,
    amount: u64
)

public entry fun set_fee_rate<CoinType>(
    admin: &signer,
    new_fee_rate: u64
)

public entry fun pause<CoinType>(admin: &signer)

public entry fun unpause<CoinType>(admin: &signer)

// æ ¸å¿ƒå€Ÿè´·å‡½æ•°
public fun flash_loan<CoinType>(
    pool_address: address,
    amount: u64
): (Coin<CoinType>, FlashLoan)

public fun repay<CoinType>(
    pool_address: address,
    coins: Coin<CoinType>,
    flash_loan: FlashLoan
)

// æŸ¥è¯¢å‡½æ•°
public fun get_liquidity<CoinType>(pool_address: address): u64

public fun get_fee_rate<CoinType>(pool_address: address): u64

public fun calculate_fee(amount: u64, fee_rate: u64): u64
```

### è¦æ±‚ä¸çº¦æŸ

1. **å®‰å…¨æ£€æŸ¥**
   - âœ… å€Ÿæ¬¾é‡‘é¢ > 0
   - âœ… æ± å­æµåŠ¨æ€§å……è¶³
   - âœ… æ± å­æœªæš‚åœ
   - âœ… å½’è¿˜é‡‘é¢ >= æœ¬é‡‘ + æ‰‹ç»­è´¹
   - âœ… ä»…ç®¡ç†å‘˜å¯ä»¥è°ƒç”¨ç®¡ç†å‡½æ•°

2. **ä¸å˜é‡**
   - âœ… è¿˜æ¬¾åï¼Œæ± å­ä½™é¢ >= åˆå§‹ä½™é¢ + æ‰‹ç»­è´¹
   - âœ… æ‰‹ç»­è´¹ç‡ <= æœ€å¤§å€¼ï¼ˆå¦‚ 1%ï¼‰

3. **äº‹ä»¶**
   ```move
   struct FlashLoanEvent has drop, store {
       borrower: address,
       amount: u64,
       fee: u64,
       timestamp: u64,
   }
   
   struct RepayEvent has drop, store {
       borrower: address,
       amount: u64,
       fee: u64,
       timestamp: u64,
   }
   ```

### æµ‹è¯•è¦æ±‚

ç¼–å†™ä»¥ä¸‹æµ‹è¯•ç”¨ä¾‹ï¼š

```move
#[test_only]
module flash_loan::basic_pool_tests {
    
    #[test(admin = @0x1)]
    fun test_initialize(admin: &signer)
    
    #[test(admin = @0x1, provider = @0x2)]
    fun test_add_liquidity(admin: &signer, provider: &signer)
    
    #[test(admin = @0x1)]
    fun test_flash_loan_success(admin: &signer)
    
    #[test(admin = @0x1)]
    fun test_flash_loan_repay(admin: &signer)
    
    #[test(admin = @0x1)]
    #[expected_failure(abort_code = E_INSUFFICIENT_LIQUIDITY)]
    fun test_flash_loan_insufficient_liquidity(admin: &signer)
    
    #[test(admin = @0x1)]
    #[expected_failure(abort_code = E_INSUFFICIENT_REPAYMENT)]
    fun test_repay_insufficient(admin: &signer)
}
```

### æç¤º

1. **æ‰‹ç»­è´¹è®¡ç®—**
   ```move
   const FEE_DENOMINATOR: u64 = 10000;
   
   fun calculate_fee(amount: u64, fee_rate: u64): u64 {
       (amount * fee_rate) / FEE_DENOMINATOR
   }
   ```

2. **ä¸å˜é‡æ£€æŸ¥**
   ```move
   public fun repay<CoinType>(...) {
       let balance_before = coin::value(&pool.reserves);
       
       // ... å½’è¿˜æ“ä½œ ...
       
       let balance_after = coin::value(&pool.reserves);
       assert!(balance_after >= balance_before + fee, E_INVARIANT_VIOLATION);
   }
   ```

3. **Hot Potato ä½¿ç”¨**
   ```move
   // åˆ›å»º
   let flash_loan = FlashLoan { amount, fee };
   
   // æ¶ˆè´¹
   let FlashLoan { amount, fee } = flash_loan;
   ```

---

## ğŸ¯ ä»»åŠ¡äºŒï¼šå®ç° DEX å¥—åˆ©ç­–ç•¥

### ä»»åŠ¡ç›®æ ‡

ä½¿ç”¨é—ªç”µè´·å®ç°ä¸€ä¸ªå®Œæ•´çš„ DEX å¥—åˆ©ç­–ç•¥ï¼ŒåŒ…æ‹¬å¥—åˆ©æœºä¼šæ£€æµ‹å’Œè‡ªåŠ¨æ‰§è¡Œã€‚

### åŠŸèƒ½è¦æ±‚

#### 1. æ ¸å¿ƒæ¨¡å—ç»“æ„

```move
module flash_loan::arbitrage {
    
    /// å¥—åˆ©é…ç½®
    struct ArbitrageConfig has key {
        flash_pool: address,           // é—ªç”µè´·æ± åœ°å€
        dex_a: address,                // DEX A åœ°å€
        dex_b: address,                // DEX B åœ°å€
        min_profit: u64,               // æœ€å°åˆ©æ¶¦è¦æ±‚
        max_slippage: u64,             // æœ€å¤§æ»‘ç‚¹ï¼ˆåŸºç‚¹ï¼‰
    }
    
    /// å¥—åˆ©ç»“æœ
    struct ArbitrageResult has drop, store {
        profit: u64,
        gas_used: u64,
        timestamp: u64,
    }
}
```

#### 2. å¿…éœ€å®ç°çš„å‡½æ•°

```move
/// è®¡ç®—å¥—åˆ©æœºä¼š
/// è¿”å›ï¼š(æ˜¯å¦æœ‰åˆ©å¯å›¾, é¢„æœŸåˆ©æ¶¦, å»ºè®®å€Ÿæ¬¾é‡‘é¢)
public fun calculate_arbitrage_opportunity<CoinX, CoinY>(
    dex_a: address,
    dex_b: address,
    flash_loan_fee_rate: u64,
    test_amount: u64
): (bool, u64, u64)

/// æ‰§è¡Œå¥—åˆ©
public entry fun execute_arbitrage<CoinX, CoinY>(
    executor: &signer,
    flash_pool: address,
    dex_a: address,
    dex_b: address,
    borrow_amount: u64,
    min_profit: u64
)

/// æ£€æŸ¥æ˜¯å¦å€¼å¾—å¥—åˆ©
/// è€ƒè™‘ Gas æˆæœ¬
public fun is_profitable(
    gross_profit: u64,
    gas_cost: u64,
    min_profit: u64
): bool

/// è®¡ç®—æœ€ä¼˜å€Ÿæ¬¾é‡‘é¢
/// ä½¿ç”¨äºŒåˆ†æœç´¢æ‰¾åˆ°æœ€å¤§åŒ–åˆ©æ¶¦çš„é‡‘é¢
public fun calculate_optimal_amount<CoinX, CoinY>(
    dex_a: address,
    dex_b: address,
    flash_fee_rate: u64,
    max_amount: u64
): u64
```

### å®ç°æ­¥éª¤

#### æ­¥éª¤ 1: å®ç°å¥—åˆ©æœºä¼šæ£€æµ‹

```move
public fun calculate_arbitrage_opportunity<CoinX, CoinY>(
    dex_a: address,
    dex_b: address,
    flash_loan_fee_rate: u64,
    test_amount: u64
): (bool, u64, u64) {
    // 1. è·å– DEX A å’Œ DEX B çš„å‚¨å¤‡é‡
    let (reserve_a_x, reserve_a_y) = dex::get_reserves<CoinX, CoinY>(dex_a);
    let (reserve_b_y, reserve_b_x) = dex::get_reserves<CoinY, CoinX>(dex_b);
    
    // 2. æ¨¡æ‹Ÿäº¤æ¢
    // DEX A: X â†’ Y
    let output_y = calculate_output_with_fee(
        test_amount,
        reserve_a_x,
        reserve_a_y,
        30  // 0.3% DEX fee
    );
    
    // DEX B: Y â†’ X
    let output_x = calculate_output_with_fee(
        output_y,
        reserve_b_y,
        reserve_b_x,
        30
    );
    
    // 3. è®¡ç®—æˆæœ¬
    let flash_fee = (test_amount * flash_loan_fee_rate) / 10000;
    let total_cost = test_amount + flash_fee;
    
    // 4. è®¡ç®—åˆ©æ¶¦
    if (output_x > total_cost) {
        let profit = output_x - total_cost;
        (true, profit, test_amount)
    } else {
        (false, 0, 0)
    }
}
```

#### æ­¥éª¤ 2: å®ç°å¥—åˆ©æ‰§è¡Œ

```move
public entry fun execute_arbitrage<CoinX, CoinY>(
    executor: &signer,
    flash_pool: address,
    dex_a: address,
    dex_b: address,
    borrow_amount: u64,
    min_profit: u64
) acquires Pool {
    // 1. æ£€æŸ¥å¥—åˆ©æœºä¼š
    let (is_profitable, expected_profit, _) = calculate_arbitrage_opportunity<CoinX, CoinY>(
        dex_a,
        dex_b,
        get_fee_rate<CoinX>(flash_pool),
        borrow_amount
    );
    assert!(is_profitable, E_NO_ARBITRAGE_OPPORTUNITY);
    assert!(expected_profit >= min_profit, E_PROFIT_TOO_LOW);
    
    // 2. é—ªç”µè´·å€Ÿå…¥ CoinX
    let (borrowed_x, flash_loan) = flash_loan<CoinX>(flash_pool, borrow_amount);
    
    // 3. DEX A: X â†’ Y
    let bought_y = dex::swap_exact_input<CoinX, CoinY>(
        dex_a,
        borrowed_x,
        0  // å®é™…åº”è®¾ç½®æ»‘ç‚¹ä¿æŠ¤
    );
    
    // 4. DEX B: Y â†’ X
    let sold_x = dex::swap_exact_input<CoinY, CoinX>(
        dex_b,
        bought_y,
        borrow_amount + flash_loan.fee  // è‡³å°‘éœ€è¦è¿™ä¹ˆå¤š
    );
    
    // 5. å½’è¿˜é—ªç”µè´·
    repay<CoinX>(flash_pool, sold_x, flash_loan);
    
    // 6. åˆ©æ¶¦ï¼ˆå¦‚æœæœ‰ï¼‰å·²ç»ç•™åœ¨ executor è´¦æˆ·ä¸­
    // å‘å°„äº‹ä»¶è®°å½•
}
```

### æµ‹è¯•è¦æ±‚

```move
#[test_only]
module flash_loan::arbitrage_tests {
    
    #[test]
    fun test_calculate_opportunity()
    
    #[test]
    fun test_execute_arbitrage_success()
    
    #[test]
    #[expected_failure]
    fun test_execute_arbitrage_no_opportunity()
    
    #[test]
    fun test_optimal_amount_calculation()
}
```

### æç¤º

1. **æ’å®šä¹˜ç§¯å…¬å¼è®¡ç®—è¾“å‡º**
   ```move
   fun calculate_output_with_fee(
       input: u64,
       reserve_in: u64,
       reserve_out: u64,
       fee_bps: u64
   ): u64 {
       let input_with_fee = input * (10000 - fee_bps);
       let numerator = input_with_fee * reserve_out;
       let denominator = (reserve_in * 10000) + input_with_fee;
       numerator / denominator
   }
   ```

2. **æ»‘ç‚¹ä¿æŠ¤**
   ```move
   let min_output = (expected_output * (10000 - max_slippage_bps)) / 10000;
   ```

---

## ğŸ¯ ä»»åŠ¡ä¸‰ï¼šæ„å»ºé—ªç”µè´·èšåˆå™¨

### ä»»åŠ¡ç›®æ ‡

å®ç°ä¸€ä¸ªé—ªç”µè´·èšåˆå™¨ï¼Œæ”¯æŒä»å¤šä¸ªæ± å­å€Ÿæ¬¾ï¼Œå¹¶å®ç°æ™ºèƒ½è·¯ç”±é€‰æ‹©æœ€ä¼˜çš„å€Ÿæ¬¾æ–¹æ¡ˆã€‚

### åŠŸèƒ½è¦æ±‚

#### 1. æ ¸å¿ƒæ•°æ®ç»“æ„

```move
module flash_loan::aggregator {
    
    /// èšåˆå™¨é…ç½®
    struct Aggregator has key {
        pools: vector<PoolInfo>,       // æ”¯æŒçš„æ± å­åˆ—è¡¨
        admin: address,
    }
    
    /// æ± å­ä¿¡æ¯
    struct PoolInfo has store, drop {
        pool_address: address,
        coin_type: TypeInfo,
        fee_rate: u64,
        available_liquidity: u64,
    }
    
    /// å¤šèµ„äº§é—ªç”µè´·
    struct MultiFlashLoan {
        loans: vector<SingleLoan>,
    }
    
    struct SingleLoan has drop, store {
        pool_address: address,
        amount: u64,
        fee: u64,
    }
}
```

#### 2. å¿…éœ€å®ç°çš„å‡½æ•°

```move
/// åˆå§‹åŒ–èšåˆå™¨
public entry fun initialize_aggregator(admin: &signer)

/// æ·»åŠ æ”¯æŒçš„æ± å­
public entry fun add_pool<CoinType>(
    admin: &signer,
    pool_address: address
)

/// ç§»é™¤æ± å­
public entry fun remove_pool(
    admin: &signer,
    pool_address: address
)

/// æŸ¥è¯¢æœ€ä¼˜å€Ÿæ¬¾æ–¹æ¡ˆ
/// è¿”å›ï¼š(æ± å­åœ°å€, é¢„æœŸæ‰‹ç»­è´¹)
public fun find_best_pool<CoinType>(
    aggregator_address: address,
    amount: u64
): (address, u64)

/// æ‰¹é‡å€Ÿæ¬¾
/// ä»å¤šä¸ªæ± å­å€Ÿå…¥ä¸åŒèµ„äº§
public fun multi_borrow(
    aggregator_address: address,
    requests: vector<BorrowRequest>
): (vector<Coin>, MultiFlashLoan)

struct BorrowRequest has drop {
    coin_type: TypeInfo,
    amount: u64,
}

/// æ‰¹é‡è¿˜æ¬¾
public fun multi_repay(
    coins: vector<Coin>,
    multi_loan: MultiFlashLoan
)

/// æ™ºèƒ½å€Ÿæ¬¾ï¼ˆè‡ªåŠ¨é€‰æ‹©æœ€ä¼˜æ± å­ï¼‰
public fun smart_borrow<CoinType>(
    aggregator_address: address,
    amount: u64
): (Coin<CoinType>, FlashLoan)
```

### é«˜çº§åŠŸèƒ½

#### 1. åˆ†æ‹†å€Ÿæ¬¾

å½“å•ä¸ªæ± å­æµåŠ¨æ€§ä¸è¶³æ—¶ï¼Œä»å¤šä¸ªæ± å­åˆ†æ‹†å€Ÿæ¬¾ï¼š

```move
/// åˆ†æ‹†å€Ÿæ¬¾ç­–ç•¥
/// å¦‚æœéœ€è¦ 100,000 USDCï¼Œä½†å•ä¸ªæ± å­æœ€å¤šåªæœ‰ 60,000
/// åˆ™ä»ä¸¤ä¸ªæ± å­åˆ†åˆ«å€Ÿ 50,000 å’Œ 50,000
public fun split_borrow<CoinType>(
    aggregator_address: address,
    total_amount: u64
): (vector<Coin<CoinType>>, MultiFlashLoan)
```

#### 2. æ‰‹ç»­è´¹ä¼˜åŒ–

é€‰æ‹©æ‰‹ç»­è´¹æœ€ä½çš„æ± å­ç»„åˆï¼š

```move
/// è®¡ç®—å€Ÿæ¬¾æˆæœ¬
public fun calculate_borrow_cost(
    amount: u64,
    pools: &vector<PoolInfo>
): u64

/// æ‰¾åˆ°æœ€ä¼˜ç»„åˆ
/// è¿”å›ï¼š[(æ± å­åœ°å€, å€Ÿæ¬¾é‡‘é¢)]
public fun find_optimal_combination<CoinType>(
    aggregator_address: address,
    total_amount: u64
): vector<(address, u64)>
```

#### 3. æµåŠ¨æ€§ç®¡ç†

å®æ—¶æ›´æ–°æ± å­æµåŠ¨æ€§ä¿¡æ¯ï¼š

```move
/// æ›´æ–°æ± å­æµåŠ¨æ€§ä¿¡æ¯
public fun update_pool_liquidity(
    aggregator_address: address,
    pool_address: address
)

/// è·å–æ‰€æœ‰æ± å­çš„æ€»æµåŠ¨æ€§
public fun get_total_liquidity<CoinType>(
    aggregator_address: address
): u64
```

### å®ç°ç¤ºä¾‹

```move
public fun smart_borrow<CoinType>(
    aggregator_address: address,
    amount: u64
): (Coin<CoinType>, FlashLoan) acquires Aggregator {
    // 1. è·å–èšåˆå™¨
    let aggregator = borrow_global<Aggregator>(aggregator_address);
    
    // 2. æŸ¥æ‰¾æœ€ä¼˜æ± å­
    let best_pool = address::zero();
    let lowest_fee = MAX_U64;
    
    let i = 0;
    let len = vector::length(&aggregator.pools);
    while (i < len) {
        let pool_info = vector::borrow(&aggregator.pools, i);
        
        // æ£€æŸ¥ç±»å‹åŒ¹é…å’ŒæµåŠ¨æ€§
        if (pool_info.coin_type == type_info::type_of<CoinType>() &&
            pool_info.available_liquidity >= amount) {
            
            let fee = (amount * pool_info.fee_rate) / 10000;
            if (fee < lowest_fee) {
                lowest_fee = fee;
                best_pool = pool_info.pool_address;
            }
        }
        
        i = i + 1;
    };
    
    // 3. ä»æœ€ä¼˜æ± å­å€Ÿæ¬¾
    assert!(best_pool != address::zero(), E_NO_SUITABLE_POOL);
    basic_pool::flash_loan<CoinType>(best_pool, amount)
}

public fun multi_borrow(
    aggregator_address: address,
    requests: vector<BorrowRequest>
): (vector<Coin>, MultiFlashLoan) acquires Aggregator {
    let coins = vector::empty<Coin>();
    let loans = vector::empty<SingleLoan>();
    
    // éå†æ¯ä¸ªå€Ÿæ¬¾è¯·æ±‚
    let i = 0;
    while (i < vector::length(&requests)) {
        let request = vector::borrow(&requests, i);
        
        // æ‰¾åˆ°æœ€ä¼˜æ± å­å¹¶å€Ÿæ¬¾
        // ï¼ˆè¿™é‡Œéœ€è¦ä½¿ç”¨åŠ¨æ€åˆ†å‘æˆ–å®ï¼‰
        
        i = i + 1;
    };
    
    let multi_loan = MultiFlashLoan { loans };
    (coins, multi_loan)
}
```

### æµ‹è¯•è¦æ±‚

```move
#[test_only]
module flash_loan::aggregator_tests {
    
    #[test]
    fun test_initialize_aggregator()
    
    #[test]
    fun test_add_remove_pool()
    
    #[test]
    fun test_find_best_pool()
    
    #[test]
    fun test_smart_borrow()
    
    #[test]
    fun test_split_borrow()
    
    #[test]
    fun test_multi_borrow_repay()
}
```

---

## ğŸ“Š è¯„åˆ†æ ‡å‡†

### ä»»åŠ¡ä¸€ï¼ˆ30åˆ†ï¼‰

| é¡¹ç›® | åˆ†å€¼ | è¯´æ˜ |
|------|------|------|
| æ•°æ®ç»“æ„è®¾è®¡ | 5åˆ† | Pool å’Œ FlashLoan ç»“æ„æ­£ç¡® |
| å€Ÿæ¬¾å‡½æ•°å®ç° | 8åˆ† | flash_loan() é€»è¾‘æ­£ç¡® |
| è¿˜æ¬¾å‡½æ•°å®ç° | 8åˆ† | repay() é€»è¾‘æ­£ç¡®ï¼ŒHot Potato æ­£ç¡®ä½¿ç”¨ |
| å®‰å…¨æ£€æŸ¥ | 5åˆ† | æ‰€æœ‰å¿…è¦çš„ assert æ£€æŸ¥ |
| æµ‹è¯•è¦†ç›– | 4åˆ† | æ‰€æœ‰æµ‹è¯•ç”¨ä¾‹é€šè¿‡ |

### ä»»åŠ¡äºŒï¼ˆ35åˆ†ï¼‰

| é¡¹ç›® | åˆ†å€¼ | è¯´æ˜ |
|------|------|------|
| å¥—åˆ©æœºä¼šæ£€æµ‹ | 10åˆ† | calculate_opportunity æ­£ç¡® |
| å¥—åˆ©æ‰§è¡Œé€»è¾‘ | 12åˆ† | execute_arbitrage æ­£ç¡®ä½¿ç”¨é—ªç”µè´· |
| æ•°å­¦è®¡ç®—å‡†ç¡® | 8åˆ† | æ’å®šä¹˜ç§¯å…¬å¼ã€æ‰‹ç»­è´¹è®¡ç®—æ­£ç¡® |
| æ»‘ç‚¹ä¿æŠ¤ | 3åˆ† | å®ç°æ»‘ç‚¹ä¿æŠ¤æœºåˆ¶ |
| æµ‹è¯•è¦†ç›– | 2åˆ† | æµ‹è¯•ç”¨ä¾‹å®Œæ•´ |

### ä»»åŠ¡ä¸‰ï¼ˆ35åˆ†ï¼‰

| é¡¹ç›® | åˆ†å€¼ | è¯´æ˜ |
|------|------|------|
| èšåˆå™¨æ¶æ„ | 8åˆ† | æ•°æ®ç»“æ„è®¾è®¡åˆç† |
| æœ€ä¼˜æ± å­é€‰æ‹© | 10åˆ† | find_best_pool ç®—æ³•æ­£ç¡® |
| å¤šèµ„äº§å€Ÿæ¬¾ | 10åˆ† | multi_borrow/repay å®ç°æ­£ç¡® |
| é«˜çº§åŠŸèƒ½ | 5åˆ† | åˆ†æ‹†å€Ÿæ¬¾æˆ–æ‰‹ç»­è´¹ä¼˜åŒ– |
| æµ‹è¯•è¦†ç›– | 2åˆ† | æµ‹è¯•ç”¨ä¾‹å®Œæ•´ |

### ä»£ç è´¨é‡ï¼ˆé¢å¤–åˆ†ï¼‰

| é¡¹ç›® | åˆ†å€¼ | è¯´æ˜ |
|------|------|------|
| ä»£ç é£æ ¼ | +5åˆ† | å‘½åè§„èŒƒã€æ³¨é‡Šæ¸…æ™° |
| é”™è¯¯å¤„ç† | +3åˆ† | å®Œå–„çš„é”™è¯¯ç å’Œæ¶ˆæ¯ |
| Gas ä¼˜åŒ– | +2åˆ† | è€ƒè™‘ Gas æˆæœ¬ä¼˜åŒ– |

**æ€»åˆ†**ï¼š100åˆ†ï¼ˆåŸºç¡€ï¼‰+ 10åˆ†ï¼ˆé¢å¤–ï¼‰

---

## ğŸ” æäº¤è¦æ±‚

### æ–‡ä»¶ç»“æ„

```
sources/
â”œâ”€â”€ basic_pool.move          # ä»»åŠ¡ä¸€
â”œâ”€â”€ arbitrage.move           # ä»»åŠ¡äºŒ
â”œâ”€â”€ aggregator.move          # ä»»åŠ¡ä¸‰
â””â”€â”€ helpers.move             # è¾…åŠ©å‡½æ•°ï¼ˆå¯é€‰ï¼‰

tests/
â”œâ”€â”€ basic_pool_tests.move
â”œâ”€â”€ arbitrage_tests.move
â””â”€â”€ aggregator_tests.move

scripts/
â”œâ”€â”€ deploy_basic.sh          # éƒ¨ç½²è„šæœ¬
â”œâ”€â”€ test_arbitrage.sh        # æµ‹è¯•å¥—åˆ©
â””â”€â”€ demo.sh                  # æ¼”ç¤ºè„šæœ¬
```

### æµ‹è¯•å‘½ä»¤

```bash
# ç¼–è¯‘
aptos move compile

# è¿è¡Œæ‰€æœ‰æµ‹è¯•
aptos move test

# è¿è¡Œç‰¹å®šæµ‹è¯•
aptos move test --filter basic_pool
aptos move test --filter arbitrage
aptos move test --filter aggregator

# éƒ¨ç½²åˆ°æµ‹è¯•ç½‘
./scripts/deploy_basic.sh
```

### æ–‡æ¡£è¦æ±‚

æ¯ä¸ªä»»åŠ¡éœ€è¦æä¾›ï¼š

1. **README.md**
   - æ¨¡å—åŠŸèƒ½è¯´æ˜
   - ä½¿ç”¨ç¤ºä¾‹
   - æµ‹è¯•ç»“æœæˆªå›¾

2. **DESIGN.md**ï¼ˆä»»åŠ¡ä¸‰ï¼‰
   - æ¶æ„è®¾è®¡è¯´æ˜
   - ç®—æ³•é€‰æ‹©ç†ç”±
   - ä¼˜åŒ–æ€è·¯

---

## ğŸ’¡ å­¦ä¹ å»ºè®®

1. **å¾ªåºæ¸è¿›**
   - å…ˆå®Œæˆä»»åŠ¡ä¸€ï¼Œç†è§£ Hot Potato
   - å†å®Œæˆä»»åŠ¡äºŒï¼Œç†è§£å¥—åˆ©é€»è¾‘
   - æœ€åå®Œæˆä»»åŠ¡ä¸‰ï¼Œç»¼åˆåº”ç”¨

2. **æµ‹è¯•é©±åŠ¨**
   - å…ˆå†™æµ‹è¯•ç”¨ä¾‹
   - å†å®ç°åŠŸèƒ½
   - ç¡®ä¿æµ‹è¯•é€šè¿‡

3. **å‚è€ƒä»£ç **
   - æŸ¥çœ‹ `01_ç†è®ºå­¦ä¹ /ä»£ç ç¤ºä¾‹.move`
   - ç†è§£åè‡ªå·±å®ç°ï¼Œä¸è¦å¤åˆ¶ç²˜è´´

4. **è°ƒè¯•æŠ€å·§**
   ```move
   use aptos_std::debug;
   
   debug::print(&b"Borrowed amount: ");
   debug::print(&amount);
   ```

---

## â“ å¸¸è§é—®é¢˜

**Q: Hot Potato å¦‚ä½•æµ‹è¯•ï¼Ÿ**
A: åœ¨æµ‹è¯•ä¸­å¯ä»¥ä½¿ç”¨ `#[test_only]` å‡½æ•°æ¥é”€æ¯å®ƒï¼š
```move
#[test_only]
public fun destroy_for_test(flash_loan: FlashLoan) {
    let FlashLoan { amount: _, fee: _ } = flash_loan;
}
```

**Q: å¦‚ä½•æ¨¡æ‹Ÿ DEXï¼Ÿ**
A: åœ¨æµ‹è¯•ä¸­åˆ›å»ºç®€å•çš„æ’å®šä¹˜ç§¯æ± ï¼š
```move
#[test_only]
module test_dex {
    struct Pool<X, Y> has key {
        reserve_x: Coin<X>,
        reserve_y: Coin<Y>,
    }
    
    public fun swap<X, Y>(...): Coin<Y> {
        // æ’å®šä¹˜ç§¯å…¬å¼
    }
}
```

**Q: èšåˆå™¨å¦‚ä½•å¤„ç†ä¸åŒç±»å‹çš„ Coinï¼Ÿ**
A: ä½¿ç”¨æ³›å‹å’Œ `TypeInfo`ï¼š
```move
use std::type_info::{Self, TypeInfo};

if (type_info::type_of<CoinType>() == pool_info.coin_type) {
    // ...
}
```

---

## ğŸ“ å­¦ä¹ æˆæœæ£€æŸ¥

å®Œæˆæ‰€æœ‰ä»»åŠ¡åï¼Œä½ åº”è¯¥èƒ½å¤Ÿï¼š

- [ ] å®ç°å®Œæ•´çš„é—ªç”µè´·åè®®
- [ ] æ­£ç¡®ä½¿ç”¨ Hot Potato æ¨¡å¼
- [ ] è®¡ç®—å¥—åˆ©æœºä¼šå’Œæ‰§è¡Œå¥—åˆ©
- [ ] è®¾è®¡å’Œå®ç°é—ªç”µè´·èšåˆå™¨
- [ ] ç¼–å†™å®Œæ•´çš„æµ‹è¯•ç”¨ä¾‹
- [ ] ç†è§£é—ªç”µè´·çš„å®‰å…¨è¦ç‚¹

**å®Œæˆåï¼Œç»§ç»­å‰å¾€ `03_æ¯æ—¥è€ƒè¯•` æ£€éªŒå­¦ä¹ æˆæœï¼** ğŸ“

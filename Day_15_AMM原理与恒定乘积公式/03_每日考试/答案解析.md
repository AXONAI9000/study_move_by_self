# Day 15 每日考试 - 答案解析

---

## 📝 选择题答案（40分）

### 第一部分：基础概念（1-8题）

#### 1. AMM 的核心公式是什么？

**正确答案**：B. x * y = k

**解析**：
- 恒定乘积公式 `x * y = k` 是 Uniswap 和大多数 AMM 的核心
- x 和 y 分别代表两种代币的储备量
- k 是一个恒定值（忽略手续费时）
- 这个公式确保无论如何交易，两种代币的乘积保持不变

**相关概念**：
- Curve 使用的是混合曲线（稳定币优化）
- Balancer 支持多代币池

---

#### 2. 在恒定乘积公式 x * y = k 中，k 代表什么？

**正确答案**：C. 恒定乘积（常数）

**解析**：
- k 代表流动性池的恒定乘积
- 交易前后 k 保持不变（忽略手续费）
- k 越大，表示流动性越深
- 手续费会导致 k 缓慢增长，这就是 LP 的收益来源

**示例**：
```
初始：x = 10,000, y = 20,000, k = 200,000,000
交换后（不含手续费）：x = 11,000, y = 18,181.82
验证：11,000 * 18,181.82 ≈ 200,000,000 ✅
```

---

#### 3. Uniswap V2 的默认交易手续费是多少？

**正确答案**：B. 0.3%

**解析**：
- Uniswap V2: 0.3% 手续费全部给 LP
- Uniswap V3: 0.05%, 0.3%, 1% 可选
- SushiSwap: 0.3% (0.25% LP + 0.05% 国库)
- PancakeSwap: 0.25% (0.17% LP + 0.08% 其他)

**计算示例**：
```
交易 1,000 代币
手续费 = 1,000 * 0.3% = 3 代币
实际用于交换 = 997 代币
```

---

#### 4. 首次添加流动性时，LP Token 的数量如何计算？

**正确答案**：C. LP = √(x * y)

**解析**：
- 使用几何平均数（geometric mean）
- 确保 LP Token 价值与流动性成正比
- 避免初始价格操纵

**为什么不用算术平均？**
```
假设用算术平均：LP = (x + y) / 2

场景 1：1,000 A + 1,000 B → LP = 1,000
场景 2：1 A + 1,999 B → LP = 1,000

但场景 2 的流动性价值远低于场景 1！❌

用几何平均：
场景 1：LP = √(1000 * 1000) = 1,000
场景 2：LP = √(1 * 1999) ≈ 45 ✅
```

---

#### 5. 后续添加流动性时，必须遵循什么原则？

**正确答案**：B. 按照当前储备比例添加

**解析**：
- 必须保持当前的储备比例
- 否则会导致套利机会和损失

**示例**：
```
当前池子：10,000 A, 20,000 B
比例：1:2

添加 1,000 A：
需要的 B = (1,000 / 10,000) * 20,000 = 2,000 B ✅

如果添加 1,000 A + 1,000 B：
比例变为 1:1.91 ❌ 不符合
会被套利者利用
```

---

#### 6. 流动性池中的价格如何确定？

**正确答案**：B. 由储备比例决定：P = y / x

**解析**：
- 价格完全由储备比例决定
- 没有订单簿，没有人为设置
- 套利者确保价格接近市场价

**示例**：
```
储备：10,000 APTOS, 20,000 USDC
价格 = 20,000 / 10,000 = 2.0 USDC/APTOS

如果市场价是 2.5：
套利者会在 AMM 买入 APTOS（便宜）
然后在 CEX 卖出（贵）
直到 AMM 价格上涨到 2.5
```

---

#### 7. 什么是 LP Token？

**正确答案**：B. 代表流动性份额的凭证

**解析**：
- LP Token 是流动性提供者的凭证
- 可以随时赎回对应的代币
- 类似于基金份额

**LP Token 的作用**：
1. 证明流动性所有权
2. 可转让（代表流动性转移）
3. 可用于流动性挖矿
4. 可用作抵押品

---

#### 8. AMM 与传统订单簿的主要区别是什么？

**正确答案**：B. AMM 使用数学公式定价

**解析**：

| 特性 | 订单簿 | AMM |
|------|--------|-----|
| 定价方式 | 买卖盘匹配 | 数学公式 |
| 流动性 | 需要做市商 | 任何人可提供 |
| 价格发现 | 精确 | 有滑点 |
| 大额交易 | 可能无法成交 | 始终可以交易（但滑点大） |
| 复杂度 | 高 | 低 |

---

### 第二部分：计算题（9-14题）

**给定**：10,000 代币 A，20,000 代币 B

#### 9. 当前池子的 k 值是多少？

**正确答案**：C. 200,000,000

**计算过程**：
```
k = x * y
k = 10,000 * 20,000
k = 200,000,000
```

**注意**：不要忘记零！

---

#### 10. 当前 B 相对于 A 的价格是多少？

**正确答案**：C. 2.0

**计算过程**：
```
价格 = y / x
价格 = 20,000 / 10,000
价格 = 2.0

意思：1 个 A 可以换 2 个 B
```

**反向价格**：
```
A 相对于 B 的价格 = x / y = 10,000 / 20,000 = 0.5
意思：1 个 B 可以换 0.5 个 A
```

---

#### 11. 用 1,000 个 A 换 B（不考虑手续费），能换到多少 B？

**正确答案**：A. 约 1,818 B

**详细计算**：
```
公式：Δy = (Δx * y) / (x + Δx)

Δy = (1,000 * 20,000) / (10,000 + 1,000)
Δy = 20,000,000 / 11,000
Δy ≈ 1,818.18 B
```

**验证**：
```
新储备：x = 11,000, y = 18,181.82
新 k = 11,000 * 18,181.82 = 200,000,020 ≈ 200,000,000 ✅
```

**为什么不是 2,000 B？**
- 如果按初始价格 2.0，应该换到 2,000 B
- 但交易会改变价格！
- 所以实际只能换到 1,818 B
- 差价就是价格影响

---

#### 12. 添加 1,000 A 的流动性，需要多少 B？

**正确答案**：C. 2,000 B

**计算过程**：
```
必须保持比例：
需要的 B / 1,000 A = 20,000 B / 10,000 A
需要的 B = (1,000 / 10,000) * 20,000
需要的 B = 0.1 * 20,000
需要的 B = 2,000 B
```

**为什么必须是 2,000？**
- 当前比例是 1:2
- 添加流动性必须保持这个比例
- 否则会导致价格变化和套利机会

---

#### 13. 如果池子有 14,142 LP Token，添加 1,000 A + 2,000 B 能获得多少 LP？

**正确答案**：B. 1,414 LP

**计算过程**：
```
方法 1：基于 A
LP = (Δx / x) * total_lp
LP = (1,000 / 10,000) * 14,142
LP = 0.1 * 14,142
LP = 1,414.2 LP

方法 2：基于 B
LP = (Δy / y) * total_lp
LP = (2,000 / 20,000) * 14,142
LP = 0.1 * 14,142
LP = 1,414.2 LP

两种方法结果相同 ✅
```

---

#### 14. 含 0.3% 手续费时，用 1,000 A 换 B，实际用于交换的 A 是多少？

**正确答案**：B. 997 A

**计算过程**：
```
手续费 = 1,000 * 0.3% = 1,000 * 0.003 = 3 A
实际交换 = 1,000 - 3 = 997 A

或者直接：
实际交换 = 1,000 * (1 - 0.003) = 1,000 * 0.997 = 997 A
```

**手续费去哪了？**
- 3 A 留在池子中
- 增加了池子的储备
- 导致 k 值增长
- 这就是 LP 的收益来源

---

### 第三部分：高级概念（15-20题）

#### 15. 什么是价格影响（Price Impact）？

**正确答案**：B. 交易导致的价格变化

**解析**：
- 价格影响 = 交易前后价格的变化
- 大额交易会显著改变储备比例
- 从而改变价格

**示例**：
```
交易前：10,000 A, 20,000 B, 价格 = 2.0
买入 1,000 A
交易后：11,000 A, 18,182 B, 价格 = 1.653

价格影响 = (1.653 - 2.0) / 2.0 = -17.35%
```

---

#### 16. 价格影响与什么因素成反比？

**正确答案**：C. 流动性深度

**解析**：
- 流动性越深，价格影响越小
- 相同的交易量在大池子中影响小

**对比**：
```
小池子：1,000 A, 2,000 B
买入 100 A：
价格影响 = 9.09% ❌ 太高

大池子：100,000 A, 200,000 B
买入 100 A：
价格影响 = 0.1% ✅ 可接受
```

**流动性深度提高 100 倍，价格影响降低约 90 倍！**

---

#### 17. 什么是无常损失（Impermanent Loss）？

**正确答案**：B. 价格变化导致 LP 价值低于持币不动

**解析**：
- 当资产价格变化时，AMM 会自动再平衡
- 导致 LP 持有的代币比例变化
- 可能价值低于单纯持有

**示例**：
```
初始：
投入 1 ETH ($2,000) + 2,000 USDC
总价值 $4,000

ETH 涨到 $4,000：

AMM 自动再平衡：
持有 0.707 ETH + 2,828 USDC = $5,656

如果持币不动：
持有 1 ETH + 2,000 USDC = $6,000

无常损失 = $6,000 - $5,656 = $344 (5.7%)
```

**为什么叫"无常"？**
- 如果价格回到原点，损失消失
- 只有价格永久改变，损失才是永久的

---

#### 18. 在什么情况下无常损失最小？

**正确答案**：B. 两种代币价格保持稳定时

**解析**：

| 情况 | 无常损失 |
|------|---------|
| 稳定币对（USDC/USDT） | 接近 0% ✅ |
| 相关资产（ETH/stETH） | < 1% ✅ |
| 价格 1.25x | 0.6% |
| 价格 2x | 5.7% ⚠️ |
| 价格 5x | 25.5% ❌ |

**最佳实践**：
- 选择稳定币对
- 选择相关资产
- 确保手续费收益 > 无常损失

---

#### 19. 为什么需要锁定最小流动性（MINIMUM_LIQUIDITY）？

**正确答案**：B. 防止除零错误和价格操纵

**解析**：

**问题 1：除零错误**
```
如果允许完全移除流动性：
reserve_x = 0, reserve_y = 0
价格 = 0 / 0 = 未定义 ❌
```

**问题 2：价格操纵**
```
攻击步骤：
1. 移除几乎所有流动性
2. 池子只剩 1 A + 1 B
3. 添加 1 A + 1,000,000 B
4. 价格被操纵为 1,000,000 ❌
```

**解决方案**：
```
锁定 1,000 LP 永久不可移除
确保池子始终有最小流动性
```

---

#### 20. 套利者在 AMM 中的作用是什么？

**正确答案**：B. 维持 AMM 价格接近市场价格

**解析**：

**套利流程**：
```
1. 发现价差
   AMM: 1 APTOS = $1.90
   CEX: 1 APTOS = $2.00
   
2. 执行套利
   在 AMM 买入 APTOS（$1.90）
   在 CEX 卖出 APTOS（$2.00）
   利润：$0.10
   
3. 价格收敛
   AMM 价格上涨到 $2.00
   套利机会消失
```

**套利者的价值**：
- 维持价格准确性
- 提供价格发现机制
- 确保 AMM 可用性

**代价**：
- LP 承担价格偏差损失
- 但获得交易手续费补偿

---

## 💻 编程题答案（60分）

### 编程题 1：实现恒定乘积交换计算（20分）

```move
public fun calculate_swap_output(
    amount_in: u64,
    reserve_in: u64,
    reserve_out: u64,
): u64 {
    // 检查输入
    assert!(amount_in > 0, 1);
    assert!(reserve_in > 0 && reserve_out > 0, 2);
    
    // 使用 u128 避免溢出
    let numerator = (amount_in as u128) * (reserve_out as u128);
    let denominator = (reserve_in as u128) + (amount_in as u128);
    
    // 计算输出
    (numerator / denominator as u64)
}
```

**评分细则**：
- ✅ 公式正确（10分）
  - 正确计算 `(amount_in * reserve_out) / (reserve_in + amount_in)`
  
- ✅ 错误处理（5分）
  - 检查 `amount_in > 0`
  - 检查储备 > 0
  
- ✅ 溢出处理（5分）
  - 使用 `u128` 进行中间计算

**常见错误**：
```move
// ❌ 错误 1：整数溢出
let output = (amount_in * reserve_out) / (reserve_in + amount_in);

// ❌ 错误 2：先除后乘
let ratio = amount_in / reserve_in;
let output = ratio * reserve_out;  // 精度损失！

// ❌ 错误 3：缺少边界检查
// 没有检查储备是否为零
```

---

### 编程题 2：实现 LP Token 计算（20分）

#### 2.1 初始 LP 计算

```move
const MINIMUM_LIQUIDITY: u64 = 1000;

public fun calculate_initial_lp(
    amount_x: u64,
    amount_y: u64,
): u64 {
    assert!(amount_x > 0 && amount_y > 0, 1);
    
    // 计算 sqrt(x * y)
    let product = (amount_x as u128) * (amount_y as u128);
    let lp_total = sqrt(product);
    
    // 扣除最小流动性
    assert!(lp_total > MINIMUM_LIQUIDITY, 2);
    lp_total - MINIMUM_LIQUIDITY
}

fun sqrt(x: u128): u64 {
    if (x == 0) return 0;
    
    let z = (x + 1) / 2;
    let y = x;
    
    while (z < y) {
        y = z;
        z = (x / z + z) / 2;
    };
    
    (y as u64)
}
```

#### 2.2 后续 LP 计算

```move
public fun calculate_additional_lp(
    amount_x: u64,
    reserve_x: u64,
    total_lp: u64,
): u64 {
    assert!(amount_x > 0, 1);
    assert!(reserve_x > 0, 2);
    assert!(total_lp > 0, 3);
    
    // LP = (amount_x / reserve_x) * total_lp
    let lp = ((amount_x as u128) * (total_lp as u128) 
        / (reserve_x as u128) as u64);
    
    lp
}
```

**评分细则**：
- ✅ 初始 LP 计算（8分）
  - 正确使用 `sqrt(x * y)` （4分）
  - 正确扣除 MINIMUM_LIQUIDITY（4分）
  
- ✅ 后续 LP 计算（8分）
  - 正确计算比例（4分）
  - 正确乘以总量（4分）
  
- ✅ 错误处理（4分）
  - 检查所有参数 > 0
  - 检查 LP > MINIMUM_LIQUIDITY

**牛顿迭代法原理**：
```
要求 sqrt(n)，即求 x² = n 的解

迭代公式：x_new = (x_old + n/x_old) / 2

示例：sqrt(100)
x0 = 50.5
x1 = (50.5 + 100/50.5) / 2 = 26.24
x2 = (26.24 + 100/26.24) / 2 = 15.03
x3 = (15.03 + 100/15.03) / 2 = 10.84
x4 = (10.84 + 100/10.84) / 2 = 10.03
x5 = (10.03 + 100/10.03) / 2 = 10.00 ✅
```

---

### 编程题 3：实现含手续费的交换（20分）

```move
const FEE_NUMERATOR: u64 = 30;      // 0.3%
const FEE_DENOMINATOR: u64 = 10000;

public fun calculate_swap_with_fee(
    amount_in: u64,
    reserve_in: u64,
    reserve_out: u64,
): (u64, u64) {
    assert!(amount_in > 0, 1);
    assert!(reserve_in > 0 && reserve_out > 0, 2);
    
    // 计算手续费
    let fee = ((amount_in as u128) * (FEE_NUMERATOR as u128) 
        / (FEE_DENOMINATOR as u128) as u64);
    
    // 扣除手续费后的输入
    let amount_in_after_fee = amount_in - fee;
    
    // 计算输出
    let numerator = (amount_in_after_fee as u128) * (reserve_out as u128);
    let denominator = (reserve_in as u128) + (amount_in_after_fee as u128);
    let amount_out = (numerator / denominator as u64);
    
    (amount_out, fee)
}

public fun verify_k_increase(
    old_reserve_x: u64,
    old_reserve_y: u64,
    new_reserve_x: u64,
    new_reserve_y: u64,
): bool {
    let old_k = (old_reserve_x as u128) * (old_reserve_y as u128);
    let new_k = (new_reserve_x as u128) * (new_reserve_y as u128);
    
    new_k > old_k
}
```

**评分细则**：
- ✅ 手续费计算（8分）
  - 正确计算 0.3%（4分）
  - 正确扣除手续费（4分）
  
- ✅ 输出计算（8分）
  - 使用扣费后的金额计算（4分）
  - 公式正确（4分）
  
- ✅ k 值验证（4分）
  - 正确计算新旧 k 值（2分）
  - 正确比较（2分）

**为什么 k 会增加？**
```
示例：
旧储备：10,000 A, 20,000 B
旧 k = 200,000,000

交换：1,000 A 换 B
手续费：3 A

新储备：10,000 + 1,000 = 11,000 A
        20,000 - 1,812 = 18,188 B
        
新 k = 11,000 * 18,188 = 200,068,000

增长 = 200,068,000 - 200,000,000 = 68,000
增长率 = 68,000 / 200,000,000 = 0.034%

这 0.034% 就是 LP 的收益！
```

---

## 📊 总分计算

### 选择题评分

```
1. B  ✅ 2分
2. C  ✅ 2分
3. B  ✅ 2分
4. C  ✅ 2分
5. B  ✅ 2分
6. B  ✅ 2分
7. B  ✅ 2分
8. B  ✅ 2分
9. C  ✅ 2分
10. C ✅ 2分
11. A ✅ 2分
12. C ✅ 2分
13. B ✅ 2分
14. B ✅ 2分
15. B ✅ 2分
16. C ✅ 2分
17. B ✅ 2分
18. B ✅ 2分
19. B ✅ 2分
20. B ✅ 2分

选择题总分：40/40
```

### 编程题评分

```
编程题 1：
- 公式正确：10/10 ✅
- 错误处理：5/5 ✅
- 溢出处理：5/5 ✅
小计：20/20

编程题 2：
- 初始 LP：8/8 ✅
- 后续 LP：8/8 ✅
- 错误处理：4/4 ✅
小计：20/20

编程题 3：
- 手续费计算：8/8 ✅
- 输出计算：8/8 ✅
- k 值验证：4/4 ✅
小计：20/20

编程题总分：60/60
```

### 总分

```
选择题：40/40
编程题：60/60
────────────
总  分：100/100 🏆 满分！
```

---

## 🎯 评分等级

| 等级 | 分数范围 | 评价 |
|------|---------|------|
| 🏆 卓越 | 95-100 | 完全掌握 AMM 原理 |
| ⭐ 优秀 | 85-94 | 很好地理解核心概念 |
| ✅ 良好 | 75-84 | 基本掌握主要知识点 |
| 📖 及格 | 70-74 | 达到最低要求 |
| ❌ 不及格 | < 70 | 需要重新学习 |

---

## 💡 错题分析

### 如果你在计算题上失分

**建议**：
1. 重新阅读核心概念中的公式推导
2. 手工计算几个示例
3. 使用计算器验证结果
4. 画图理解双曲线

### 如果你在编程题上失分

**建议**：
1. 研究代码示例
2. 理解每一行代码的作用
3. 自己实现一遍
4. 运行测试验证

### 如果你在概念题上失分

**建议**：
1. 重新阅读理论学习材料
2. 理解每个概念的定义和意义
3. 思考为什么这样设计
4. 对比不同的解决方案

---

## 📚 深入学习

### 推荐阅读

1. **Uniswap V2 白皮书**
   - https://uniswap.org/whitepaper.pdf
   - 深入理解 x*y=k 模型

2. **恒定函数做市商**
   - https://arxiv.org/abs/2003.10001
   - 学术论文，数学推导

3. **无常损失计算器**
   - https://dailydefi.org/tools/impermanent-loss-calculator/
   - 实际计算无常损失

### 实战项目

1. **部署自己的 AMM**
   - 在测试网部署
   - 添加流动性
   - 执行交换

2. **开发套利机器人**
   - 监控价格差异
   - 自动执行套利
   - 计算收益

3. **分析真实 DEX**
   - 研究 Liquidswap 源码
   - 分析交易数据
   - 优化策略

---

## 🎓 下一步学习

如果你的得分 ≥ 70 分：
- ✅ 继续学习 Day 16: 简单 DEX - 流动性池
- 💡 开始实现完整的 DEX

如果你的得分 < 70 分：
- 🔄 重新学习今天的理论
- 💻 重做编程题
- 📖 阅读扩展资料
- 🤔 理解每个公式的推导

---

**恭喜完成 Day 15 的学习！继续加油！💪**

记住：
- 理解原理比记住公式更重要
- 动手实践比看教程更有效
- 思考为什么比知道怎么做更深刻

**下一站：Day 16 - 简单 DEX - 流动性池！🚀**

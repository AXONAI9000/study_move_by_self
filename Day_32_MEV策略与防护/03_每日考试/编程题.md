# Day 32 æ¯æ—¥è€ƒè¯• - ç¼–ç¨‹é¢˜

## ğŸ“ è€ƒè¯•è¯´æ˜

- **é¢˜ç›®æ•°é‡**: 3é¢˜
- **æ€»åˆ†**: 100åˆ†
- **è€ƒè¯•æ—¶é—´**: 60åˆ†é’Ÿ
- **æäº¤**: å®Œæ•´çš„Moveä»£ç  + æµ‹è¯•ç”¨ä¾‹

---

## ç¼–ç¨‹é¢˜ 1: MEVæ£€æµ‹å™¨ (30åˆ†)

### é¢˜ç›®æè¿°

å®ç°ä¸€ä¸ªMEVæ£€æµ‹å™¨ï¼Œèƒ½å¤Ÿè¯†åˆ«Sandwichæ”»å‡»æ¨¡å¼ã€‚

### åŠŸèƒ½è¦æ±‚

1. è®°å½•æœ€è¿‘çš„äº¤æ˜“ï¼ˆä¿ç•™æœ€è¿‘50ç¬”ï¼‰
2. æ£€æµ‹Sandwichæ”»å‡»æ¨¡å¼ï¼š
   - å‰åä¸¤ç¬”äº¤æ˜“æ¥è‡ªåŒä¸€åœ°å€
   - ä¸­é—´å¤¹ç€ä¸€ç¬”æ¥è‡ªä¸åŒåœ°å€çš„äº¤æ˜“
   - å‰åäº¤æ˜“é‡‘é¢ç›¸ä¼¼ï¼ˆå·®å¼‚ < 10%ï¼‰
   - ä¸‰ç¬”äº¤æ˜“åœ¨5ç§’å†…å®Œæˆ
3. å‘å‡ºå‘Šè­¦äº‹ä»¶
4. è®°å½•å¯ç–‘åœ°å€çš„æ”»å‡»æ¬¡æ•°

### ä»£ç æ¡†æ¶

```move
module exam::mev_detector {
    use std::signer;
    use std::vector;
    use aptos_framework::event::{Self, EventHandle};
    use aptos_framework::timestamp;

    struct Transaction has store, copy, drop {
        sender: address,
        amount: u64,
        timestamp: u64,
    }

    struct Detector has key {
        // TODO: å®ç°æ£€æµ‹å™¨ç»“æ„
    }

    struct SandwichAlert has drop, store {
        // TODO: å®šä¹‰å‘Šè­¦äº‹ä»¶
    }

    public fun initialize(admin: &signer) {
        // TODO: åˆå§‹åŒ–æ£€æµ‹å™¨
    }

    public fun record_transaction(
        detector_addr: address,
        sender: address,
        amount: u64,
    ) acquires Detector {
        // TODO: è®°å½•äº¤æ˜“å¹¶æ£€æµ‹
    }

    fun detect_sandwich(
        transactions: &vector<Transaction>
    ): bool {
        // TODO: æ£€æµ‹é€»è¾‘
    }

    public fun get_attack_count(
        detector_addr: address,
        attacker: address,
    ): u64 acquires Detector {
        // TODO: æŸ¥è¯¢æ”»å‡»æ¬¡æ•°
    }
}
```

### æµ‹è¯•ç”¨ä¾‹

```move
#[test_only]
module exam::mev_detector_test {
    use exam::mev_detector;
    use aptos_framework::timestamp;
    
    #[test(admin = @0x123)]
    public fun test_sandwich_detection(admin: &signer) {
        // TODO: æµ‹è¯•èƒ½æ£€æµ‹åˆ°sandwichæ”»å‡»
    }
    
    #[test(admin = @0x123)]
    public fun test_normal_transactions(admin: &signer) {
        // TODO: æµ‹è¯•æ­£å¸¸äº¤æ˜“ä¸ä¼šè¯¯æŠ¥
    }
}
```

### è¯„åˆ†æ ‡å‡† (30åˆ†)

- æ•°æ®ç»“æ„è®¾è®¡åˆç† (5åˆ†)
- äº¤æ˜“è®°å½•åŠŸèƒ½æ­£ç¡® (5åˆ†)
- Sandwichæ£€æµ‹é€»è¾‘å‡†ç¡® (10åˆ†)
- å‘Šè­¦å’Œç»Ÿè®¡åŠŸèƒ½å®Œæ•´ (5åˆ†)
- æµ‹è¯•ç”¨ä¾‹è¦†ç›–å®Œæ•´ (5åˆ†)

---

## ç¼–ç¨‹é¢˜ 2: æ»‘ç‚¹ä¿æŠ¤çš„Swap (35åˆ†)

### é¢˜ç›®æè¿°

å®ç°ä¸€ä¸ªå¸¦æ»‘ç‚¹ä¿æŠ¤å’ŒTWAPä»·æ ¼é¢„è¨€æœºçš„Swapæ¨¡å—ã€‚

### åŠŸèƒ½è¦æ±‚

1. **æ»‘ç‚¹ä¿æŠ¤**
   - ç”¨æˆ·è®¾ç½®æœ€å°è¾“å‡ºæ•°é‡
   - å¦‚æœå®é™…è¾“å‡º < æœ€å°å€¼ï¼Œæ‹’ç»äº¤æ˜“
   - æ ¹æ®äº¤æ˜“å¤§å°æ¨èåˆç†æ»‘ç‚¹

2. **TWAPä»·æ ¼é¢„è¨€æœº**
   - ç´¯ç§¯ä»·æ ¼ = Î£(ä»·æ ¼ Ã— æ—¶é—´)
   - è®¡ç®—æŒ‡å®šæ—¶é—´æ®µçš„TWAP
   - å®šæœŸæ›´æ–°ä»·æ ¼

3. **ä»·æ ¼å½±å“è®¡ç®—**
   - åŸºäºæ’å®šä¹˜ç§¯å…¬å¼
   - è¿”å›ä»·æ ¼å½±å“ç™¾åˆ†æ¯”

### ä»£ç æ¡†æ¶

```move
module exam::protected_swap {
    use std::signer;
    use aptos_framework::coin::{Self, Coin};
    use aptos_framework::timestamp;

    struct LiquidityPool<phantom CoinA, phantom CoinB> has key {
        reserve_a: u64,
        reserve_b: u64,
        // TODO: æ·»åŠ å…¶ä»–å¿…è¦å­—æ®µ
    }

    struct TWAPOracle has key {
        // TODO: å®ç°TWAPç»“æ„
    }

    const ERROR_SLIPPAGE_TOO_HIGH: u64 = 1;
    const ERROR_INSUFFICIENT_LIQUIDITY: u64 = 2;

    // ===== æ»‘ç‚¹ä¿æŠ¤ =====

    public fun swap_a_to_b<CoinA, CoinB>(
        user: &signer,
        amount_in: u64,
        min_amount_out: u64,
    ): Coin<CoinB> acquires LiquidityPool {
        // TODO: å®ç°å¸¦æ»‘ç‚¹ä¿æŠ¤çš„swap
    }

    public fun calculate_output_amount(
        amount_in: u64,
        reserve_in: u64,
        reserve_out: u64,
    ): u64 {
        // TODO: ä½¿ç”¨æ’å®šä¹˜ç§¯å…¬å¼è®¡ç®—è¾“å‡º
        // amount_out = (reserve_out * amount_in) / (reserve_in + amount_in)
    }

    public fun calculate_price_impact(
        amount_in: u64,
        reserve_in: u64,
    ): u64 {
        // TODO: è®¡ç®—ä»·æ ¼å½±å“ï¼ˆåŸºç‚¹ï¼‰
    }

    public fun recommend_slippage(
        amount_in: u64,
        reserve_in: u64,
    ): u64 {
        // TODO: æ¨èåˆç†çš„æ»‘ç‚¹
    }

    // ===== TWAPé¢„è¨€æœº =====

    public fun initialize_oracle(admin: &signer, initial_price: u64) {
        // TODO: åˆå§‹åŒ–TWAP
    }

    public fun update_price(
        oracle_addr: address,
        new_price: u64,
    ) acquires TWAPOracle {
        // TODO: æ›´æ–°ä»·æ ¼å¹¶ç´¯åŠ 
    }

    public fun get_twap(
        oracle_addr: address,
        period_seconds: u64,
    ): u64 acquires TWAPOracle {
        // TODO: è®¡ç®—TWAP
    }
}
```

### æµ‹è¯•ç”¨ä¾‹

```move
#[test_only]
module exam::protected_swap_test {
    #[test]
    fun test_output_calculation() {
        // æµ‹è¯•: reserve_in=10000, reserve_out=100000, amount_in=100
        // æœŸæœ›: amount_out â‰ˆ 990
    }
    
    #[test]
    fun test_slippage_protection() {
        // æµ‹è¯•: è®¾ç½®min_amount_out=1000
        // å¦‚æœå®é™…è¾“å‡º990ï¼Œåº”è¯¥æ‹’ç»äº¤æ˜“
    }
    
    #[test]
    fun test_twap_calculation() {
        // æµ‹è¯•TWAPè®¡ç®—å‡†ç¡®æ€§
    }
}
```

### è¯„åˆ†æ ‡å‡† (35åˆ†)

- æ’å®šä¹˜ç§¯å…¬å¼å®ç°æ­£ç¡® (8åˆ†)
- æ»‘ç‚¹ä¿æŠ¤é€»è¾‘å‡†ç¡® (8åˆ†)
- ä»·æ ¼å½±å“è®¡ç®—æ­£ç¡® (5åˆ†)
- TWAPé¢„è¨€æœºå®ç°å®Œæ•´ (10åˆ†)
- æµ‹è¯•ç”¨ä¾‹å……åˆ† (4åˆ†)

---

## ç¼–ç¨‹é¢˜ 3: å¥—åˆ©æœºä¼šè¯„ä¼°å™¨ (35åˆ†)

### é¢˜ç›®æè¿°

å®ç°ä¸€ä¸ªå¥—åˆ©æœºä¼šè¯„ä¼°ç³»ç»Ÿï¼Œèƒ½å¤Ÿæ‰«æå¤šä¸ªDEXå¹¶è®¡ç®—æœ€ä¼˜å¥—åˆ©ç­–ç•¥ã€‚

### åŠŸèƒ½è¦æ±‚

1. **æœºä¼šæ‰«æ**
   - æ¯”è¾ƒå¤šä¸ªDEXçš„ä»·æ ¼
   - è¯†åˆ«æœ‰åˆ©æ¶¦çš„ä»·æ ¼å·®å¼‚
   - åªè¿”å›åˆ©æ¶¦ > æœ€å°é˜ˆå€¼çš„æœºä¼š

2. **åˆ©æ¶¦è®¡ç®—**
   - è€ƒè™‘gasæˆæœ¬
   - è€ƒè™‘æ»‘ç‚¹å½±å“
   - è®¡ç®—å‡€åˆ©æ¶¦

3. **æœ€ä¼˜é‡‘é¢è®¡ç®—**
   - æ‰¾åˆ°åˆ©æ¶¦æœ€å¤§åŒ–çš„äº¤æ˜“é‡‘é¢
   - è€ƒè™‘æµåŠ¨æ€§é™åˆ¶

4. **é£é™©è¯„ä¼°**
   - è®¡ç®—æ‰§è¡Œé£é™©è¯„åˆ† (0-100)
   - åŸºäºæµåŠ¨æ€§ã€ä»·æ ¼æ³¢åŠ¨ç­‰å› ç´ 

### ä»£ç æ¡†æ¶

```move
module exam::arbitrage_evaluator {
    use std::vector;

    struct DEXInfo has copy, drop {
        dex_address: address,
        price: u64,        // ä»·æ ¼ (scaled by 10000)
        liquidity: u64,    // æµåŠ¨æ€§
    }

    struct ArbitrageOpportunity has copy, drop {
        buy_dex: address,
        sell_dex: address,
        buy_price: u64,
        sell_price: u64,
        optimal_amount: u64,
        expected_profit: u64,
        net_profit: u64,
        risk_score: u8,
    }

    const MIN_PROFIT_BPS: u64 = 30; // 0.3%

    /// æ‰«ææ‰€æœ‰DEXå¯¹ï¼Œæ‰¾å‡ºå¥—åˆ©æœºä¼š
    public fun scan_opportunities(
        dexes: vector<DEXInfo>,
        gas_cost: u64,
    ): vector<ArbitrageOpportunity> {
        // TODO: å®ç°æ‰«æé€»è¾‘
    }

    /// è®¡ç®—å¥—åˆ©åˆ©æ¶¦
    public fun calculate_profit(
        buy_price: u64,
        sell_price: u64,
        amount: u64,
        gas_cost: u64,
    ): (u64, u64) {
        // TODO: è®¡ç®—æ€»æ”¶å…¥å’Œå‡€åˆ©æ¶¦
        // è¿”å›: (gross_profit, net_profit)
    }

    /// è®¡ç®—æœ€ä¼˜äº¤æ˜“é‡‘é¢
    public fun calculate_optimal_amount(
        price_diff: u64,
        liquidity_a: u64,
        liquidity_b: u64,
    ): u64 {
        // TODO: è€ƒè™‘æ»‘ç‚¹çš„æœ€ä¼˜åŒ–
        // ç®€åŒ–ç‰ˆ: min(liquidity_a, liquidity_b) / 10
    }

    /// è¯„ä¼°æ‰§è¡Œé£é™©
    public fun assess_risk(
        price_diff: u64,
        liquidity: u64,
        optimal_amount: u64,
    ): u8 {
        // TODO: è®¡ç®—é£é™©è¯„åˆ† 0-100
        // é«˜æµåŠ¨æ€§ã€å°äº¤æ˜“é‡ = ä½é£é™©
        // ä½æµåŠ¨æ€§ã€å¤§äº¤æ˜“é‡ = é«˜é£é™©
    }

    /// æ¯”è¾ƒä¸¤ä¸ªæœºä¼šï¼Œè¿”å›æ›´å¥½çš„é‚£ä¸ª
    public fun compare_opportunities(
        opp1: &ArbitrageOpportunity,
        opp2: &ArbitrageOpportunity,
    ): bool {
        // TODO: ç»¼åˆè€ƒè™‘åˆ©æ¶¦å’Œé£é™©
        // è¿”å›: opp1æ˜¯å¦æ¯”opp2æ›´å¥½
    }
}
```

### æµ‹è¯•ç”¨ä¾‹

```move
#[test_only]
module exam::arbitrage_evaluator_test {
    use exam::arbitrage_evaluator;
    use std::vector;
    
    #[test]
    fun test_opportunity_detection() {
        let dexes = vector::empty();
        
        // DEX A: ä»·æ ¼10.0, æµåŠ¨æ€§100000
        vector::push_back(&mut dexes, /* ... */);
        
        // DEX B: ä»·æ ¼10.5, æµåŠ¨æ€§50000
        vector::push_back(&mut dexes, /* ... */);
        
        let opportunities = arbitrage_evaluator::scan_opportunities(
            dexes,
            50, // gasæˆæœ¬
        );
        
        // åº”è¯¥æ£€æµ‹åˆ°1ä¸ªæœºä¼š
        assert!(vector::length(&opportunities) == 1, 0);
    }
    
    #[test]
    fun test_profit_calculation() {
        // ä¹°å…¥ä»·10.0, å–å‡ºä»·10.5, æ•°é‡1000, gas=50
        let (gross, net) = arbitrage_evaluator::calculate_profit(
            10000, 10500, 1000, 50
        );
        // gross = 500, net = 450
        assert!(gross == 500, 1);
        assert!(net == 450, 2);
    }
    
    #[test]
    fun test_risk_assessment() {
        // é«˜æµåŠ¨æ€§ï¼Œå°äº¤æ˜“é‡ = ä½é£é™©
        let risk = arbitrage_evaluator::assess_risk(
            500,    // 5%ä»·æ ¼å·®
            100000, // é«˜æµåŠ¨æ€§
            1000,   // å°äº¤æ˜“é‡
        );
        assert!(risk < 30, 3); // åº”è¯¥æ˜¯ä½é£é™©
    }
}
```

### è¯„åˆ†æ ‡å‡† (35åˆ†)

- æœºä¼šæ‰«æé€»è¾‘æ­£ç¡® (8åˆ†)
- åˆ©æ¶¦è®¡ç®—å‡†ç¡® (8åˆ†)
- æœ€ä¼˜é‡‘é¢è®¡ç®—åˆç† (6åˆ†)
- é£é™©è¯„ä¼°å®ç° (8åˆ†)
- æµ‹è¯•ç”¨ä¾‹å®Œæ•´ (5åˆ†)

---

## ğŸ“Š æ€»ä½“è¯„åˆ†

| é¢˜ç›® | åˆ†æ•° | å¾—åˆ† |
|------|------|------|
| ç¼–ç¨‹é¢˜1: MEVæ£€æµ‹å™¨ | 30åˆ† | ____ |
| ç¼–ç¨‹é¢˜2: æ»‘ç‚¹ä¿æŠ¤çš„Swap | 35åˆ† | ____ |
| ç¼–ç¨‹é¢˜3: å¥—åˆ©æœºä¼šè¯„ä¼°å™¨ | 35åˆ† | ____ |
| **æ€»åˆ†** | **100åˆ†** | ____ |

**è¯„çº§æ ‡å‡†**:
- 90-100åˆ†: ä¼˜ç§€ â­â­â­â­â­
- 75-89åˆ†: è‰¯å¥½ â­â­â­â­
- 60-74åˆ†: åŠæ ¼ â­â­â­
- 60åˆ†ä»¥ä¸‹: éœ€è¦é‡æ–°å­¦ä¹ 

---

## ğŸ’¡ è§£é¢˜æç¤º

### ç¼–ç¨‹é¢˜1æç¤º

1. **Sandwichæ£€æµ‹å…³é”®**:
   ```move
   let len = vector::length(&transactions);
   if (len >= 3) {
       let t1 = vector::borrow(&transactions, len - 3);
       let t2 = vector::borrow(&transactions, len - 2);
       let t3 = vector::borrow(&transactions, len - 1);
       
       // æ£€æŸ¥æ¡ä»¶
       if (t1.sender == t3.sender && 
           t1.sender != t2.sender &&
           amounts_similar(t1.amount, t3.amount) &&
           t3.timestamp - t1.timestamp <= 5) {
           // æ£€æµ‹åˆ°sandwich!
       }
   }
   ```

2. **é‡‘é¢ç›¸ä¼¼åº¦**:
   ```move
   fun amounts_similar(a: u64, b: u64): bool {
       let diff = if (a > b) { a - b } else { b - a };
       diff <= a / 10 // 10%å®¹å·®
   }
   ```

### ç¼–ç¨‹é¢˜2æç¤º

1. **æ’å®šä¹˜ç§¯å…¬å¼**:
   ```move
   // amount_out = (reserve_out * amount_in) / (reserve_in + amount_in)
   let numerator = reserve_out * amount_in;
   let denominator = reserve_in + amount_in;
   amount_out = numerator / denominator;
   ```

2. **TWAPç´¯ç§¯**:
   ```move
   let elapsed = now - last_update;
   cumulative_price = cumulative_price + (last_price * elapsed);
   
   // è®¡ç®—TWAP
   let time_range = now - (now - period);
   let price_delta = current_cumulative - old_cumulative;
   twap = price_delta / time_range;
   ```

### ç¼–ç¨‹é¢˜3æç¤º

1. **æœºä¼šæ‰«æ**:
   ```move
   let i = 0;
   while (i < len) {
       let j = i + 1;
       while (j < len) {
           let dex_a = vector::borrow(&dexes, i);
           let dex_b = vector::borrow(&dexes, j);
           
           if (dex_b.price > dex_a.price) {
               let profit_bps = ((dex_b.price - dex_a.price) * 10000) / dex_a.price;
               if (profit_bps > MIN_PROFIT_BPS) {
                   // æ‰¾åˆ°æœºä¼š!
               }
           }
       }
   }
   ```

2. **é£é™©è¯„åˆ†**:
   ```move
   let size_ratio = (amount * 100) / liquidity;
   let risk = if (size_ratio < 5) {
       10  // ä½é£é™©
   } else if (size_ratio < 20) {
       50  // ä¸­é£é™©
   } else {
       90  // é«˜é£é™©
   };
   ```

---

## ğŸ“ æäº¤è¦æ±‚

1. **ä»£ç æ–‡ä»¶**
   - `mev_detector.move`
   - `protected_swap.move`
   - `arbitrage_evaluator.move`

2. **æµ‹è¯•æ–‡ä»¶**
   - æ¯ä¸ªæ¨¡å—çš„æµ‹è¯•ç”¨ä¾‹
   - æ‰€æœ‰æµ‹è¯•å¿…é¡»é€šè¿‡

3. **æ–‡æ¡£**
   - ç®€è¦è¯´æ˜ä½ çš„å®ç°æ€è·¯
   - åˆ—å‡ºé‡åˆ°çš„æŒ‘æˆ˜å’Œè§£å†³æ–¹æ¡ˆ

4. **è¿è¡Œè¯´æ˜**
   ```bash
   # ç¼–è¯‘
   aptos move compile
   
   # æµ‹è¯•
   aptos move test
   ```

---

**æç¤º**: å…ˆåœ¨çº¸ä¸Šè®¾è®¡æ•°æ®ç»“æ„å’Œç®—æ³•æµç¨‹ï¼Œå†å¼€å§‹ç¼–ç ã€‚æ³¨æ„è¾¹ç•Œæƒ…å†µå’Œé”™è¯¯å¤„ç†ï¼

**ç¥ä½ è€ƒè¯•é¡ºåˆ©ï¼** ğŸš€

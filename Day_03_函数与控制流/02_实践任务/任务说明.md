# Day 03 å®è·µä»»åŠ¡ - å‡½æ•°ä¸æ§åˆ¶æµ

## ä»»åŠ¡æ¦‚è¿°

é€šè¿‡ä¸‰ä¸ªé€’è¿›å¼ç¼–ç¨‹ä»»åŠ¡ï¼Œæ·±å…¥æŒæ¡Moveè¯­è¨€çš„å‡½æ•°å®šä¹‰ã€æ§åˆ¶æµå’Œå¸¸è§ç®—æ³•æ¨¡å¼ã€‚

---

## ä»»åŠ¡ 1ï¼šæ•°å­¦å·¥å…·åº“ï¼ˆ30 åˆ†ï¼‰

### ğŸ“‹ ä»»åŠ¡æè¿°

åˆ›å»ºä¸€ä¸ªå®Œæ•´çš„æ•°å­¦å·¥å…·åº“ï¼Œå®ç°å„ç§å¸¸ç”¨æ•°å­¦å‡½æ•°ã€‚

### ğŸ¯ åŠŸèƒ½è¦æ±‚

åˆ›å»º `sources/math_utils.move` æ–‡ä»¶ï¼Œå®ç°ï¼š

1. **åŸºç¡€è¿ç®—å‡½æ•°**
   - `is_even(n: u64): bool` - åˆ¤æ–­æ˜¯å¦ä¸ºå¶æ•°
   - `is_odd(n: u64): bool` - åˆ¤æ–­æ˜¯å¦ä¸ºå¥‡æ•°
   - `gcd(a: u64, b: u64): u64` - æœ€å¤§å…¬çº¦æ•°ï¼ˆæ¬§å‡ é‡Œå¾—ç®—æ³•ï¼‰
   - `lcm(a: u64, b: u64): u64` - æœ€å°å…¬å€æ•°

2. **è´¨æ•°ç›¸å…³**
   - `is_prime(n: u64): bool` - åˆ¤æ–­æ˜¯å¦ä¸ºè´¨æ•°
   - `next_prime(n: u64): u64` - æ‰¾åˆ°ä¸‹ä¸€ä¸ªè´¨æ•°
   - `count_primes(max: u64): u64` - ç»Ÿè®¡å°äºç­‰äºmaxçš„è´¨æ•°ä¸ªæ•°

3. **æ•°å­—æ“ä½œ**
   - `digit_sum(n: u64): u64` - è®¡ç®—å„ä½æ•°å­—ä¹‹å’Œ
   - `reverse_number(n: u64): u64` - åè½¬æ•°å­—ï¼ˆ123 -> 321ï¼‰
   - `is_palindrome(n: u64): bool` - åˆ¤æ–­æ˜¯å¦ä¸ºå›æ–‡æ•°

### ğŸ“ ä»£ç æ¡†æ¶

```move
module my_addr::math_utils {
    
    // é”™è¯¯ç 
    const E_ZERO_NOT_ALLOWED: u64 = 1;
    const E_OVERFLOW: u64 = 2;

    /// åˆ¤æ–­æ˜¯å¦ä¸ºå¶æ•°
    public fun is_even(n: u64): bool {
        n % 2 == 0
    }

    /// åˆ¤æ–­æ˜¯å¦ä¸ºå¥‡æ•°
    public fun is_odd(n: u64): bool {
        n % 2 == 1
    }

    /// æœ€å¤§å…¬çº¦æ•°ï¼ˆæ¬§å‡ é‡Œå¾—ç®—æ³•ï¼‰
    /// ç¤ºä¾‹ï¼šgcd(48, 18) = 6
    public fun gcd(a: u64, b: u64): u64 {
        // TODO: å®ç°
        // æç¤ºï¼šwhileå¾ªç¯ + å–ä½™
        // ç®—æ³•ï¼šå½“bä¸ä¸º0æ—¶ï¼Œa = b, b = a % b
        0
    }

    /// æœ€å°å…¬å€æ•°
    /// æç¤ºï¼šlcm(a, b) = a * b / gcd(a, b)
    public fun lcm(a: u64, b: u64): u64 {
        // TODO: å®ç°
        0
    }

    /// åˆ¤æ–­æ˜¯å¦ä¸ºè´¨æ•°
    /// è´¨æ•°å®šä¹‰ï¼šå¤§äº1ä¸”åªèƒ½è¢«1å’Œè‡ªå·±æ•´é™¤
    public fun is_prime(n: u64): bool {
        // TODO: å®ç°
        // æç¤ºï¼šæ£€æŸ¥ä»2åˆ°sqrt(n)çš„æ‰€æœ‰æ•°
        false
    }

    /// æ‰¾åˆ°å¤§äºnçš„ä¸‹ä¸€ä¸ªè´¨æ•°
    public fun next_prime(n: u64): u64 {
        // TODO: å®ç°
        // æç¤ºï¼šä»n+1å¼€å§‹ï¼Œä½¿ç”¨is_primeæ£€æŸ¥
        0
    }

    /// ç»Ÿè®¡å°äºç­‰äºmaxçš„è´¨æ•°ä¸ªæ•°
    public fun count_primes(max: u64): u64 {
        // TODO: å®ç°
        0
    }

    /// è®¡ç®—å„ä½æ•°å­—ä¹‹å’Œ
    /// ç¤ºä¾‹ï¼šdigit_sum(123) = 1 + 2 + 3 = 6
    public fun digit_sum(n: u64): u64 {
        // TODO: å®ç°
        // æç¤ºï¼šwhileå¾ªç¯ + å–ä½™å’Œé™¤æ³•
        0
    }

    /// åè½¬æ•°å­—
    /// ç¤ºä¾‹ï¼šreverse_number(123) = 321
    public fun reverse_number(n: u64): u64 {
        // TODO: å®ç°
        0
    }

    /// åˆ¤æ–­æ˜¯å¦ä¸ºå›æ–‡æ•°
    /// ç¤ºä¾‹ï¼š121, 1221æ˜¯å›æ–‡æ•°
    public fun is_palindrome(n: u64): bool {
        // TODO: å®ç°
        // æç¤ºï¼šæ¯”è¾ƒnå’Œreverse_number(n)
        false
    }

    // ============================================
    // æµ‹è¯•ç”¨ä¾‹
    // ============================================

    #[test]
    fun test_is_even() {
        assert!(is_even(2), 0);
        assert!(is_even(100), 0);
        assert!(!is_even(3), 0);
    }

    #[test]
    fun test_gcd() {
        assert!(gcd(48, 18) == 6, 0);
        assert!(gcd(100, 50) == 50, 0);
        assert!(gcd(17, 19) == 1, 0);
    }

    #[test]
    fun test_lcm() {
        assert!(lcm(4, 6) == 12, 0);
        assert!(lcm(21, 6) == 42, 0);
    }

    #[test]
    fun test_is_prime() {
        assert!(is_prime(2), 0);
        assert!(is_prime(17), 0);
        assert!(!is_prime(1), 0);
        assert!(!is_prime(15), 0);
    }

    #[test]
    fun test_digit_sum() {
        assert!(digit_sum(123) == 6, 0);
        assert!(digit_sum(999) == 27, 0);
    }

    #[test]
    fun test_is_palindrome() {
        assert!(is_palindrome(121), 0);
        assert!(is_palindrome(1221), 0);
        assert!(!is_palindrome(123), 0);
    }
}
```

### âœ… è¯„åˆ†æ ‡å‡†

- æ‰€æœ‰å‡½æ•°æ­£ç¡®å®ç°ï¼ˆ20åˆ†ï¼‰
- ç®—æ³•æ•ˆç‡ï¼ˆ5åˆ†ï¼‰
- ä»£ç é£æ ¼å’Œæ³¨é‡Šï¼ˆ5åˆ†ï¼‰

---

## ä»»åŠ¡ 2ï¼šå‘é‡æ“ä½œåº“ï¼ˆ35 åˆ†ï¼‰

### ğŸ“‹ ä»»åŠ¡æè¿°

å®ç°ä¸€ä¸ªåŠŸèƒ½å®Œæ•´çš„å‘é‡æ“ä½œåº“ï¼ŒåŒ…å«å„ç§ç»Ÿè®¡å’Œè½¬æ¢å‡½æ•°ã€‚

### ğŸ¯ åŠŸèƒ½è¦æ±‚

åˆ›å»º `sources/vector_ops.move` æ–‡ä»¶ï¼Œå®ç°ï¼š

1. **ç»Ÿè®¡å‡½æ•°**
   - `sum(vec: &vector<u64>): u64` - æ±‚å’Œ
   - `average(vec: &vector<u64>): u64` - å¹³å‡å€¼
   - `min(vec: &vector<u64>): u64` - æœ€å°å€¼
   - `max(vec: &vector<u64>): u64` - æœ€å¤§å€¼
   - `range(vec: &vector<u64>): u64` - æå·®ï¼ˆæœ€å¤§å€¼-æœ€å°å€¼ï¼‰

2. **æŸ¥æ‰¾å‡½æ•°**
   - `contains(vec: &vector<u64>, value: u64): bool` - æ˜¯å¦åŒ…å«
   - `index_of(vec: &vector<u64>, value: u64): u64` - æŸ¥æ‰¾ç´¢å¼•ï¼ˆä¸å­˜åœ¨è¿”å›é•¿åº¦ï¼‰
   - `count(vec: &vector<u64>, value: u64): u64` - ç»Ÿè®¡å‡ºç°æ¬¡æ•°

3. **è½¬æ¢å‡½æ•°**
   - `reverse(vec: &vector<u64>): vector<u64>` - åè½¬
   - `filter_even(vec: &vector<u64>): vector<u64>` - è¿‡æ»¤å¶æ•°
   - `map_double(vec: &vector<u64>): vector<u64>` - æ¯ä¸ªå…ƒç´ ä¹˜2
   - `slice(vec: &vector<u64>, start: u64, end: u64): vector<u64>` - åˆ‡ç‰‡

4. **åˆ¤æ–­å‡½æ•°**
   - `is_sorted(vec: &vector<u64>): bool` - æ˜¯å¦å‡åº
   - `all_positive(vec: &vector<u64>): bool` - æ˜¯å¦å…¨éƒ¨å¤§äº0
   - `any_greater_than(vec: &vector<u64>, threshold: u64): bool` - æ˜¯å¦æœ‰å…ƒç´ å¤§äºé˜ˆå€¼

### ğŸ“ ä»£ç æ¡†æ¶

```move
module my_addr::vector_ops {
    use std::vector;

    // é”™è¯¯ç 
    const E_EMPTY_VECTOR: u64 = 1;
    const E_INDEX_OUT_OF_BOUNDS: u64 = 2;
    const E_INVALID_RANGE: u64 = 3;

    /// æ±‚å’Œ
    public fun sum(vec: &vector<u64>): u64 {
        let len = vector::length(vec);
        let mut total = 0;
        let mut i = 0;
        
        while (i < len) {
            total = total + *vector::borrow(vec, i);
            i = i + 1;
        };
        
        total
    }

    /// å¹³å‡å€¼ï¼ˆå‘ä¸‹å–æ•´ï¼‰
    public fun average(vec: &vector<u64>): u64 {
        assert!(vector::length(vec) > 0, E_EMPTY_VECTOR);
        // TODO: å®ç°
        0
    }

    /// æœ€å°å€¼
    public fun min(vec: &vector<u64>): u64 {
        assert!(vector::length(vec) > 0, E_EMPTY_VECTOR);
        // TODO: å®ç°
        0
    }

    /// æœ€å¤§å€¼
    public fun max(vec: &vector<u64>): u64 {
        assert!(vector::length(vec) > 0, E_EMPTY_VECTOR);
        // TODO: å®ç°
        0
    }

    /// æå·®
    public fun range(vec: &vector<u64>): u64 {
        // TODO: å®ç°
        // æç¤ºï¼šmax - min
        0
    }

    /// æ˜¯å¦åŒ…å«æŸä¸ªå€¼
    public fun contains(vec: &vector<u64>, value: u64): bool {
        // TODO: å®ç°
        false
    }

    /// æŸ¥æ‰¾å…ƒç´ çš„ç´¢å¼•
    /// å¦‚æœä¸å­˜åœ¨ï¼Œè¿”å›å‘é‡é•¿åº¦
    public fun index_of(vec: &vector<u64>, value: u64): u64 {
        // TODO: å®ç°
        0
    }

    /// ç»Ÿè®¡æŸä¸ªå€¼å‡ºç°çš„æ¬¡æ•°
    public fun count(vec: &vector<u64>, value: u64): u64 {
        // TODO: å®ç°
        0
    }

    /// åè½¬å‘é‡
    public fun reverse(vec: &vector<u64>): vector<u64> {
        // TODO: å®ç°
        vector::empty()
    }

    /// è¿‡æ»¤å‡ºæ‰€æœ‰å¶æ•°
    public fun filter_even(vec: &vector<u64>): vector<u64> {
        // TODO: å®ç°
        vector::empty()
    }

    /// æ¯ä¸ªå…ƒç´ ä¹˜ä»¥2
    public fun map_double(vec: &vector<u64>): vector<u64> {
        // TODO: å®ç°
        vector::empty()
    }

    /// åˆ‡ç‰‡ï¼šè¿”å›[start, end)èŒƒå›´çš„å…ƒç´ 
    public fun slice(vec: &vector<u64>, start: u64, end: u64): vector<u64> {
        assert!(start <= end, E_INVALID_RANGE);
        assert!(end <= vector::length(vec), E_INDEX_OUT_OF_BOUNDS);
        // TODO: å®ç°
        vector::empty()
    }

    /// åˆ¤æ–­æ˜¯å¦å‡åºæ’åˆ—
    public fun is_sorted(vec: &vector<u64>): bool {
        // TODO: å®ç°
        false
    }

    /// åˆ¤æ–­æ˜¯å¦æ‰€æœ‰å…ƒç´ éƒ½å¤§äº0
    public fun all_positive(vec: &vector<u64>): bool {
        // TODO: å®ç°
        false
    }

    /// åˆ¤æ–­æ˜¯å¦æœ‰å…ƒç´ å¤§äºé˜ˆå€¼
    public fun any_greater_than(vec: &vector<u64>, threshold: u64): bool {
        // TODO: å®ç°
        false
    }

    // ============================================
    // æµ‹è¯•ç”¨ä¾‹
    // ============================================

    #[test]
    fun test_sum() {
        let vec = vector[1, 2, 3, 4, 5];
        assert!(sum(&vec) == 15, 0);
    }

    #[test]
    fun test_average() {
        let vec = vector[10, 20, 30];
        assert!(average(&vec) == 20, 0);
    }

    #[test]
    fun test_min_max() {
        let vec = vector[5, 2, 8, 1, 9];
        assert!(min(&vec) == 1, 0);
        assert!(max(&vec) == 9, 0);
    }

    #[test]
    fun test_contains() {
        let vec = vector[1, 2, 3, 4, 5];
        assert!(contains(&vec, 3), 0);
        assert!(!contains(&vec, 10), 0);
    }

    #[test]
    fun test_reverse() {
        let vec = vector[1, 2, 3];
        let reversed = reverse(&vec);
        assert!(*vector::borrow(&reversed, 0) == 3, 0);
        assert!(*vector::borrow(&reversed, 2) == 1, 0);
    }

    #[test]
    fun test_is_sorted() {
        let sorted = vector[1, 2, 3, 4];
        let unsorted = vector[1, 3, 2, 4];
        assert!(is_sorted(&sorted), 0);
        assert!(!is_sorted(&unsorted), 0);
    }
}
```

### âœ… è¯„åˆ†æ ‡å‡†

- æ‰€æœ‰å‡½æ•°æ­£ç¡®å®ç°ï¼ˆ25åˆ†ï¼‰
- è¾¹ç•Œæƒ…å†µå¤„ç†ï¼ˆ5åˆ†ï¼‰
- ä»£ç è´¨é‡ï¼ˆ5åˆ†ï¼‰

---

## ä»»åŠ¡ 3ï¼šæ¸¸æˆé€»è¾‘å®ç°ï¼ˆ35 åˆ†ï¼‰

### ğŸ“‹ ä»»åŠ¡æè¿°

å®ç°ä¸€ä¸ªç®€å•çš„çŒœæ•°å­—æ¸¸æˆå’Œäº•å­—æ£‹åˆ¤å®šé€»è¾‘ã€‚

### ğŸ¯ åŠŸèƒ½è¦æ±‚

åˆ›å»º `sources/game_logic.move` æ–‡ä»¶ï¼Œå®ç°ï¼š

1. **çŒœæ•°å­—æ¸¸æˆ**
   - `GuessResult` ç»“æ„ä½“ï¼šè®°å½•çŒœæµ‹ç»“æœ
   - `make_guess(secret: u64, guess: u64): GuessResult` - çŒœæµ‹å¹¶è¿”å›æç¤º
   - `calculate_score(attempts: u64): u64` - æ ¹æ®å°è¯•æ¬¡æ•°è®¡ç®—å¾—åˆ†

2. **äº•å­—æ£‹åˆ¤å®š**
   - æ£‹ç›˜ç”¨ `vector<u8>` è¡¨ç¤ºï¼Œ0=ç©ºï¼Œ1=ç©å®¶1ï¼Œ2=ç©å®¶2
   - `check_winner(board: &vector<u8>): u8` - æ£€æŸ¥èƒœè€…ï¼ˆ0=æ— ï¼Œ1=ç©å®¶1ï¼Œ2=ç©å®¶2ï¼Œ3=å¹³å±€ï¼‰
   - `is_valid_move(board: &vector<u8>, position: u64): bool` - æ£€æŸ¥ç§»åŠ¨æ˜¯å¦åˆæ³•
   - `make_move(board: &mut vector<u8>, position: u64, player: u8)` - æ‰§è¡Œç§»åŠ¨

3. **é¢å¤–æŒ‘æˆ˜**
   - `find_winning_move(board: &vector<u8>, player: u8): u64` - æ‰¾åˆ°è·èƒœçš„ä¸€æ­¥ï¼ˆä¸å­˜åœ¨è¿”å›9ï¼‰

### ğŸ“ ä»£ç æ¡†æ¶

```move
module my_addr::game_logic {
    use std::vector;

    // é”™è¯¯ç 
    const E_INVALID_POSITION: u64 = 1;
    const E_POSITION_OCCUPIED: u64 = 2;
    const E_INVALID_PLAYER: u64 = 3;
    const E_GAME_OVER: u64 = 4;

    // æ¸¸æˆå¸¸é‡
    const EMPTY: u8 = 0;
    const PLAYER_ONE: u8 = 1;
    const PLAYER_TWO: u8 = 2;
    const DRAW: u8 = 3;

    // ============================================
    // ç¬¬ä¸€éƒ¨åˆ†ï¼šçŒœæ•°å­—æ¸¸æˆ
    // ============================================

    /// çŒœæµ‹ç»“æœ
    struct GuessResult has drop {
        is_correct: bool,
        hint: u8,  // 0=æ­£ç¡®, 1=å¤ªå°, 2=å¤ªå¤§
        difference: u64,  // ä¸æ­£ç¡®ç­”æ¡ˆçš„å·®è·
    }

    /// è¿›è¡Œä¸€æ¬¡çŒœæµ‹
    public fun make_guess(secret: u64, guess: u64): GuessResult {
        if (guess == secret) {
            GuessResult {
                is_correct: true,
                hint: 0,
                difference: 0,
            }
        } else if (guess < secret) {
            GuessResult {
                is_correct: false,
                hint: 1,
                difference: secret - guess,
            }
        } else {
            GuessResult {
                is_correct: false,
                hint: 2,
                difference: guess - secret,
            }
        }
    }

    /// æ ¹æ®å°è¯•æ¬¡æ•°è®¡ç®—å¾—åˆ†
    /// 1æ¬¡=100åˆ†ï¼Œæ¯å¤šä¸€æ¬¡å‡10åˆ†ï¼Œæœ€ä½10åˆ†
    public fun calculate_score(attempts: u64): u64 {
        // TODO: å®ç°
        0
    }

    /// åˆ¤æ–­çŒœæµ‹æ˜¯å¦æ¥è¿‘ï¼ˆå·®è·<=10ï¼‰
    public fun is_close(result: &GuessResult): bool {
        // TODO: å®ç°
        false
    }

    // ============================================
    // ç¬¬äºŒéƒ¨åˆ†ï¼šäº•å­—æ£‹é€»è¾‘
    // ============================================

    /// åˆ›å»ºç©ºæ£‹ç›˜ï¼ˆ3x3ï¼Œç”¨é•¿åº¦9çš„å‘é‡è¡¨ç¤ºï¼‰
    public fun create_board(): vector<u8> {
        let mut board = vector::empty();
        let mut i = 0;
        while (i < 9) {
            vector::push_back(&mut board, EMPTY);
            i = i + 1;
        };
        board
    }

    /// æ£€æŸ¥ä½ç½®æ˜¯å¦åœ¨æ£‹ç›˜èŒƒå›´å†…
    public fun is_valid_position(position: u64): bool {
        position < 9
    }

    /// æ£€æŸ¥ç§»åŠ¨æ˜¯å¦åˆæ³•
    public fun is_valid_move(board: &vector<u8>, position: u64): bool {
        // TODO: å®ç°
        // æç¤ºï¼šä½ç½®è¦åœ¨èŒƒå›´å†…ä¸”è¯¥ä½ç½®ä¸ºç©º
        false
    }

    /// æ‰§è¡Œç§»åŠ¨
    public fun make_move(board: &mut vector<u8>, position: u64, player: u8) {
        assert!(player == PLAYER_ONE || player == PLAYER_TWO, E_INVALID_PLAYER);
        assert!(is_valid_move(board, position), E_POSITION_OCCUPIED);
        
        // TODO: å®ç°
        // æç¤ºï¼šä½¿ç”¨ vector::borrow_mut
    }

    /// æ£€æŸ¥ä¸€è¡Œæ˜¯å¦è·èƒœ
    fun check_line(board: &vector<u8>, pos1: u64, pos2: u64, pos3: u64): u8 {
        let v1 = *vector::borrow(board, pos1);
        let v2 = *vector::borrow(board, pos2);
        let v3 = *vector::borrow(board, pos3);
        
        if (v1 != EMPTY && v1 == v2 && v2 == v3) {
            v1
        } else {
            EMPTY
        }
    }

    /// æ£€æŸ¥æ˜¯å¦æœ‰è·èƒœè€…
    /// è¿”å›ï¼š0=æ— è·èƒœè€…ï¼Œ1=ç©å®¶1èƒœï¼Œ2=ç©å®¶2èƒœï¼Œ3=å¹³å±€
    public fun check_winner(board: &vector<u8>): u8 {
        // æ£€æŸ¥æ¨ªæ’
        let row1 = check_line(board, 0, 1, 2);
        if (row1 != EMPTY) return row1;
        
        let row2 = check_line(board, 3, 4, 5);
        if (row2 != EMPTY) return row2;
        
        let row3 = check_line(board, 6, 7, 8);
        if (row3 != EMPTY) return row3;
        
        // TODO: æ£€æŸ¥ç«–æ’ï¼ˆåˆ—ï¼‰
        // æç¤ºï¼šcheck_line(board, 0, 3, 6) ...
        
        // TODO: æ£€æŸ¥å¯¹è§’çº¿
        // æç¤ºï¼šcheck_line(board, 0, 4, 8) ...
        
        // TODO: æ£€æŸ¥æ˜¯å¦å¹³å±€ï¼ˆæ£‹ç›˜æ»¡äº†ä½†æ— è·èƒœè€…ï¼‰
        
        EMPTY
    }

    /// æ£€æŸ¥æ£‹ç›˜æ˜¯å¦å·²æ»¡
    public fun is_board_full(board: &vector<u8>): bool {
        // TODO: å®ç°
        false
    }

    /// æ‰¾åˆ°ç©å®¶çš„è·èƒœä¸€æ­¥
    /// è¿”å›ï¼šä½ç½®ç´¢å¼•ï¼ˆ0-8ï¼‰ï¼Œå¦‚æœä¸å­˜åœ¨è¿”å›9
    public fun find_winning_move(board: &vector<u8>, player: u8): u64 {
        let mut i = 0;
        
        while (i < 9) {
            // å¦‚æœè¯¥ä½ç½®ä¸ºç©º
            if (*vector::borrow(board, i) == EMPTY) {
                // å°è¯•åœ¨è¯¥ä½ç½®æ”¾ç½®æ£‹å­
                let mut test_board = *board;
                *vector::borrow_mut(&mut test_board, i) = player;
                
                // æ£€æŸ¥æ˜¯å¦è·èƒœ
                if (check_winner(&test_board) == player) {
                    return i
                };
            };
            i = i + 1;
        };
        
        9  // æ²¡æœ‰è·èƒœçš„ä¸€æ­¥
    }

    // ============================================
    // æµ‹è¯•ç”¨ä¾‹
    // ============================================

    #[test]
    fun test_guess_correct() {
        let result = make_guess(50, 50);
        assert!(result.is_correct, 0);
        assert!(result.hint == 0, 1);
    }

    #[test]
    fun test_guess_too_low() {
        let result = make_guess(50, 30);
        assert!(!result.is_correct, 0);
        assert!(result.hint == 1, 1);
    }

    #[test]
    fun test_create_board() {
        let board = create_board();
        assert!(vector::length(&board) == 9, 0);
        assert!(*vector::borrow(&board, 0) == EMPTY, 1);
    }

    #[test]
    fun test_valid_move() {
        let board = create_board();
        assert!(is_valid_move(&board, 0), 0);
        assert!(!is_valid_move(&board, 9), 1);
    }

    #[test]
    fun test_make_move() {
        let mut board = create_board();
        make_move(&mut board, 0, PLAYER_ONE);
        assert!(*vector::borrow(&board, 0) == PLAYER_ONE, 0);
    }

    #[test]
    fun test_check_winner_row() {
        let mut board = create_board();
        // ç©å®¶1å æ®ç¬¬ä¸€è¡Œ
        make_move(&mut board, 0, PLAYER_ONE);
        make_move(&mut board, 1, PLAYER_ONE);
        make_move(&mut board, 2, PLAYER_ONE);
        
        assert!(check_winner(&board) == PLAYER_ONE, 0);
    }

    #[test]
    #[expected_failure(abort_code = E_POSITION_OCCUPIED)]
    fun test_invalid_move() {
        let mut board = create_board();
        make_move(&mut board, 0, PLAYER_ONE);
        make_move(&mut board, 0, PLAYER_TWO);  // åº”è¯¥å¤±è´¥
    }
}
```

### âœ… è¯„åˆ†æ ‡å‡†

- çŒœæ•°å­—æ¸¸æˆåŠŸèƒ½ï¼ˆ10åˆ†ï¼‰
- äº•å­—æ£‹åŸºç¡€åŠŸèƒ½ï¼ˆ15åˆ†ï¼‰
- AIè·èƒœæ£€æµ‹ï¼ˆ5åˆ†ï¼‰
- æµ‹è¯•è¦†ç›–ç‡ï¼ˆ5åˆ†ï¼‰

---

## æäº¤è¦æ±‚

### ğŸ“¦ é¡¹ç›®ç»“æ„

```
Day_03_å‡½æ•°ä¸æ§åˆ¶æµ/
â”œâ”€â”€ Move.toml
â””â”€â”€ sources/
    â”œâ”€â”€ math_utils.move
    â”œâ”€â”€ vector_ops.move
    â””â”€â”€ game_logic.move
```

### ğŸ“„ Move.toml é…ç½®

```toml
[package]
name = "day03_tasks"
version = "1.0.0"

[addresses]
my_addr = "0x42"

[dependencies]
AptosFramework = { git = "https://github.com/aptos-labs/aptos-core.git", subdir = "aptos-move/framework/aptos-framework", rev = "main" }
```

### âœ… éªŒè¯æ­¥éª¤

1. **ç¼–è¯‘æ£€æŸ¥**
```bash
aptos move compile
```

2. **è¿è¡Œæµ‹è¯•**
```bash
aptos move test
```

3. **ç¡®ä¿æ‰€æœ‰æµ‹è¯•é€šè¿‡**

---

## æç¤ºä¸æŠ€å·§

### ğŸ’¡ ç®—æ³•æç¤º

1. **æœ€å¤§å…¬çº¦æ•°ï¼ˆè¾—è½¬ç›¸é™¤æ³•ï¼‰**
```move
while (b != 0) {
    let temp = b;
    b = a % b;
    a = temp;
}
return a
```

2. **è´¨æ•°åˆ¤æ–­**
```move
// åªéœ€æ£€æŸ¥åˆ°sqrt(n)
let mut i = 2;
while (i * i <= n) {
    if (n % i == 0) return false;
    i = i + 1;
}
```

3. **åè½¬æ•°å­—**
```move
let mut reversed = 0;
while (num > 0) {
    reversed = reversed * 10 + (num % 10);
    num = num / 10;
}
```

### ğŸ¯ ç¼–ç¨‹å»ºè®®

1. **å…ˆå†™æµ‹è¯•ï¼Œå†å®ç°åŠŸèƒ½**
2. **ä½¿ç”¨æœ‰æ„ä¹‰çš„å˜é‡å**
3. **æ·»åŠ å¿…è¦çš„æ–­è¨€æ£€æŸ¥**
4. **æ¯å®Œæˆä¸€ä¸ªå‡½æ•°å°±è¿è¡Œæµ‹è¯•**
5. **ä½¿ç”¨å¾ªç¯ä¸å˜é‡å¸®åŠ©ç†è§£é€»è¾‘**

---

## å¸¸è§é—®é¢˜

### â“ Q1: å¦‚ä½•éå†å‘é‡ï¼Ÿ

```move
let len = vector::length(vec);
let mut i = 0;
while (i < len) {
    let value = *vector::borrow(vec, i);
    // å¤„ç†value
    i = i + 1;
}
```

### â“ Q2: å¦‚ä½•æå‰é€€å‡ºå¾ªç¯ï¼Ÿ

ä½¿ç”¨ `return` æˆ– `break`ï¼š
```move
while (condition) {
    if (found) {
        return result;  // é€€å‡ºå‡½æ•°
    };
    if (skip) {
        break;  // é€€å‡ºå¾ªç¯
    };
}
```

### â“ Q3: å¦‚ä½•å¤„ç†ç©ºå‘é‡ï¼Ÿ

```move
assert!(vector::length(vec) > 0, E_EMPTY_VECTOR);
```

---

## è¯„åˆ†æ€»ç»“

| ä»»åŠ¡ | åˆ†å€¼ | è¯´æ˜ |
|------|------|------|
| ä»»åŠ¡1ï¼šæ•°å­¦å·¥å…·åº“ | 30åˆ† | åŸºç¡€ç®—æ³•å®ç° |
| ä»»åŠ¡2ï¼šå‘é‡æ“ä½œåº“ | 35åˆ† | æ•°æ®å¤„ç†èƒ½åŠ› |
| ä»»åŠ¡3ï¼šæ¸¸æˆé€»è¾‘ | 35åˆ† | ç»¼åˆåº”ç”¨èƒ½åŠ› |
| **æ€»åˆ†** | **100åˆ†** | |

ç¥ä½ ç¼–ç¨‹æ„‰å¿«ï¼ğŸš€

# Move Prover å½¢å¼åŒ–éªŒè¯æ ¸å¿ƒæ¦‚å¿µ

## ç¬¬ä¸€éƒ¨åˆ†ï¼šå½¢å¼åŒ–éªŒè¯åŸºç¡€

### 1.1 ä»€ä¹ˆæ˜¯å½¢å¼åŒ–éªŒè¯ï¼Ÿ

**å½¢å¼åŒ–éªŒè¯**æ˜¯ä½¿ç”¨æ•°å­¦æ–¹æ³•è¯æ˜ç¨‹åºæ»¡è¶³å…¶è§„çº¦ï¼ˆSpecificationï¼‰çš„è¿‡ç¨‹ã€‚

**ç±»æ¯”ï¼šå»ºç­‘ç»“æ„åˆ†æ**
- **ä¼ ç»Ÿæµ‹è¯•**ï¼šåƒå»ºé€ åæµ‹è¯•æ¥¼æˆ¿èƒ½å¦æ‰¿é‡ï¼ˆæŠ½æ ·æ£€éªŒï¼‰
- **å½¢å¼åŒ–éªŒè¯**ï¼šåƒåœ¨å»ºé€ å‰ç”¨åŠ›å­¦å…¬å¼è®¡ç®—ç»“æ„æ˜¯å¦å®‰å…¨ï¼ˆæ•°å­¦è¯æ˜ï¼‰

### 1.2 ä¸ºä»€ä¹ˆéœ€è¦å½¢å¼åŒ–éªŒè¯ï¼Ÿ

**æµ‹è¯•çš„å±€é™æ€§**ï¼š
```move
// æµ‹è¯•èƒ½å‘ç°è¿™ä¸ª bug å—ï¼Ÿ
public fun divide(a: u64, b: u64): u64 {
    a / b  // å½“ b = 0 æ—¶ä¼š panicï¼Œä½†å¯èƒ½æµ‹è¯•æ¼æ‰
}

// å½¢å¼åŒ–éªŒè¯ä¼šå¼ºåˆ¶ä½ è¯æ˜ï¼š
spec divide {
    requires b > 0;  // å‰ç½®æ¡ä»¶ï¼šb å¿…é¡»å¤§äº 0
    ensures result == a / b;  // åç½®æ¡ä»¶
}
```

**çœŸå®æ¡ˆä¾‹**ï¼š
- **The DAO äº‹ä»¶**ï¼ˆ2016ï¼‰ï¼šé‡å…¥æ¼æ´å¯¼è‡´ 5000 ä¸‡ç¾å…ƒæŸå¤±
- **Parity é’±åŒ…**ï¼ˆ2017ï¼‰ï¼šå¤šç­¾é’±åŒ…æ¼æ´å†»ç»“ 3 äº¿ç¾å…ƒ
- è¿™äº›æ¼æ´éƒ½å¯ä»¥é€šè¿‡å½¢å¼åŒ–éªŒè¯é¢„é˜²

### 1.3 Move Prover æ¶æ„

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Move æºä»£ç     â”‚
â”‚  + è§„çº¦(spec)   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Move Compiler  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Move Prover    â”‚
â”‚  (Boogie)       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  SMT Solver     â”‚
â”‚  (Z3)           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â–¼
    âœ… éªŒè¯é€šè¿‡
    âŒ å‘ç°åä¾‹
```

**æ ¸å¿ƒç»„ä»¶**ï¼š
1. **Move Prover**ï¼šå°† Move ä»£ç è½¬æ¢ä¸º Boogie ä¸­é—´è¯­è¨€
2. **Boogie**ï¼šå¾®è½¯å¼€å‘çš„éªŒè¯ä¸­é—´è¯­è¨€
3. **Z3**ï¼šå¼ºå¤§çš„ SMT æ±‚è§£å™¨ï¼ˆSatisfiability Modulo Theoriesï¼‰

---

## ç¬¬äºŒéƒ¨åˆ†ï¼šè§„çº¦è¯­è¨€åŸºç¡€

### 2.1 spec å—è¯­æ³•

**å‡½æ•°çº§è§„çº¦**ï¼š
```move
module my_addr::counter {
    struct Counter has key {
        value: u64
    }
    
    public fun increment(counter: &mut Counter) {
        counter.value = counter.value + 1;
    }
    
    spec increment {
        // è§„çº¦å†™åœ¨è¿™é‡Œ
    }
}
```

**æ¨¡å—çº§è§„çº¦**ï¼š
```move
module my_addr::bank {
    // æ¨¡å—ä»£ç ...
}

spec my_addr::bank {
    // æ¨¡å—çº§è§„çº¦
}
```

### 2.2 å‰ç½®æ¡ä»¶ï¼ˆrequiresï¼‰

**å®šä¹‰**ï¼šå‡½æ•°æ‰§è¡Œå‰å¿…é¡»æ»¡è¶³çš„æ¡ä»¶ã€‚

```move
public fun withdraw(account: &mut Account, amount: u64) {
    account.balance = account.balance - amount;
}

spec withdraw {
    // å‰ç½®æ¡ä»¶ï¼šä½™é¢å¿…é¡»è¶³å¤Ÿ
    requires account.balance >= amount;
    
    // å‰ç½®æ¡ä»¶ï¼šé‡‘é¢å¿…é¡»å¤§äº 0
    requires amount > 0;
}
```

**æ•ˆæœ**ï¼š
- éªŒè¯æ‰€æœ‰è°ƒç”¨ç‚¹æ˜¯å¦æ»¡è¶³å‰ç½®æ¡ä»¶
- å¦‚æœè¿åï¼ŒProver ä¼šæŠ¥é”™

### 2.3 åç½®æ¡ä»¶ï¼ˆensuresï¼‰

**å®šä¹‰**ï¼šå‡½æ•°æ‰§è¡Œåå¿…é¡»æ»¡è¶³çš„æ¡ä»¶ã€‚

```move
public fun add(a: u64, b: u64): u64 {
    a + b
}

spec add {
    // åç½®æ¡ä»¶ï¼šè¿”å›å€¼ç­‰äºä¸¤æ•°ä¹‹å’Œ
    ensures result == a + b;
    
    // åç½®æ¡ä»¶ï¼šç»“æœå¤§äºç­‰äºä»»ä¸€è¾“å…¥
    ensures result >= a;
    ensures result >= b;
}
```

**ç‰¹æ®Šå˜é‡**ï¼š
- `result`ï¼šå‡½æ•°çš„è¿”å›å€¼
- `old(expr)`ï¼šè¡¨è¾¾å¼åœ¨å‡½æ•°æ‰§è¡Œå‰çš„å€¼

```move
public fun increment(counter: &mut Counter) {
    counter.value = counter.value + 1;
}

spec increment {
    ensures counter.value == old(counter.value) + 1;
}
```

### 2.4 ä¸­æ­¢æ¡ä»¶ï¼ˆaborts_ifï¼‰

**å®šä¹‰**ï¼šæŒ‡å®šå‡½æ•°åœ¨ä»€ä¹ˆæ¡ä»¶ä¸‹ä¼š abortã€‚

```move
public fun divide(a: u64, b: u64): u64 {
    assert!(b != 0, ERROR_DIVISION_BY_ZERO);
    a / b
}

spec divide {
    // å½“ b == 0 æ—¶ä¼š abort
    aborts_if b == 0;
    
    // æ­£å¸¸æƒ…å†µä¸‹çš„åç½®æ¡ä»¶
    ensures result == a / b;
}
```

**aborts_if çš„é‡è¦æ€§**ï¼š
- æ˜ç¡®å‡½æ•°çš„å¤±è´¥æ¡ä»¶
- å¸®åŠ©è°ƒç”¨è€…å¤„ç†é”™è¯¯
- ç¡®ä¿é”™è¯¯å¤„ç†çš„å®Œæ•´æ€§

```move
spec divide {
    // å¦‚æœæ²¡æœ‰å…¶ä»– abort æ¡ä»¶ï¼ŒåŠ ä¸Šè¿™ä¸ª
    aborts_if b == 0 with ERROR_DIVISION_BY_ZERO;
}
```

### 2.5 ä¸å˜é‡ï¼ˆinvariantï¼‰

**å®šä¹‰**ï¼šæ•°æ®ç»“æ„åœ¨æ•´ä¸ªç”Ÿå‘½å‘¨æœŸä¸­å¿…é¡»ä¿æŒçš„æ€§è´¨ã€‚

```move
struct Account has key {
    balance: u64,
    credit_limit: u64
}

spec Account {
    // ä¸å˜é‡ï¼šä½™é¢ä¸èƒ½è¶…è¿‡ u64 æœ€å¤§å€¼
    invariant balance <= MAX_U64;
    
    // ä¸å˜é‡ï¼šä¿¡ç”¨é¢åº¦å¿…é¡»åˆç†
    invariant credit_limit <= 1000000;
}
```

**å…¨å±€ä¸å˜é‡**ï¼š
```move
module my_addr::bank {
    struct TotalSupply has key {
        value: u64
    }
    
    struct Account has key {
        balance: u64
    }
}

spec my_addr::bank {
    // å…¨å±€ä¸å˜é‡ï¼šæ‰€æœ‰è´¦æˆ·ä½™é¢ä¹‹å’Œç­‰äºæ€»ä¾›åº”é‡
    invariant forall addr: address where exists<Account>(addr):
        global<TotalSupply>(@my_addr).value >= global<Account>(addr).balance;
}
```

---

## ç¬¬ä¸‰éƒ¨åˆ†ï¼šé«˜çº§è§„çº¦ç‰¹æ€§

### 3.1 é‡è¯ï¼ˆQuantifiersï¼‰

**å…¨ç§°é‡è¯ï¼ˆforallï¼‰**ï¼š
```move
spec {
    // å¯¹æ‰€æœ‰åœ°å€ï¼Œå¦‚æœè´¦æˆ·å­˜åœ¨ï¼Œä½™é¢éè´Ÿ
    invariant forall addr: address where exists<Account>(addr):
        global<Account>(addr).balance >= 0;
}
```

**å­˜åœ¨é‡è¯ï¼ˆexistsï¼‰**ï¼š
```move
spec {
    // å­˜åœ¨è‡³å°‘ä¸€ä¸ªç®¡ç†å‘˜
    invariant exists addr: address:
        vector::contains(&global<AdminList>(@module_addr).admins, &addr);
}
```

### 3.2 old è¡¨è¾¾å¼

**ç”¨é€”**ï¼šå¼•ç”¨å‡½æ•°æ‰§è¡Œå‰çš„å€¼ã€‚

```move
public fun transfer(from: &mut Account, to: &mut Account, amount: u64) {
    from.balance = from.balance - amount;
    to.balance = to.balance + amount;
}

spec transfer {
    requires from.balance >= amount;
    
    // å‘é€æ–¹ä½™é¢å‡å°‘
    ensures from.balance == old(from.balance) - amount;
    
    // æ¥æ”¶æ–¹ä½™é¢å¢åŠ 
    ensures to.balance == old(to.balance) + amount;
    
    // æ€»é‡å®ˆæ’
    ensures from.balance + to.balance == old(from.balance) + old(to.balance);
}
```

### 3.3 global è®¿é—®

**è®¿é—®å…¨å±€å­˜å‚¨**ï¼š
```move
spec {
    // è®¿é—®åœ°å€ addr çš„èµ„æº
    let account = global<Account>(addr);
    
    // æ£€æŸ¥èµ„æºæ˜¯å¦å­˜åœ¨
    requires exists<Account>(addr);
    
    // åç½®æ¡ä»¶ä¸­ä½¿ç”¨
    ensures global<Account>(addr).balance == 100;
}
```

### 3.4 è¾…åŠ©å‡½æ•°ï¼ˆspec funï¼‰

**å®šä¹‰å¯é‡ç”¨çš„è§„çº¦å‡½æ•°**ï¼š
```move
spec module {
    // å®šä¹‰è¾…åŠ©å‡½æ•°ï¼šè®¡ç®—æ‰€æœ‰è´¦æˆ·ä½™é¢æ€»å’Œ
    fun sum_of_balances(): u64 {
        // è¿™æ˜¯è§„çº¦çº§åˆ«çš„å‡½æ•°ï¼Œä¸ä¼šè¢«ç¼–è¯‘
        // ç”¨äºåœ¨è§„çº¦ä¸­è¡¨è¾¾å¤æ‚é€»è¾‘
    }
}

spec transfer {
    // ä½¿ç”¨è¾…åŠ©å‡½æ•°
    ensures sum_of_balances() == old(sum_of_balances());
}
```

---

## ç¬¬å››éƒ¨åˆ†ï¼šå®æˆ˜æ¨¡å¼

### 4.1 æ¨¡å¼ 1ï¼šç®€å•å‡½æ•°éªŒè¯

```move
module my_addr::math {
    /// è®¡ç®—ä¸¤æ•°ä¹‹å’Œ
    public fun add(a: u64, b: u64): u64 {
        a + b
    }
    
    spec add {
        // å‰ç½®æ¡ä»¶ï¼šé˜²æ­¢æº¢å‡º
        requires a + b <= MAX_U64;
        
        // åç½®æ¡ä»¶ï¼šç»“æœæ­£ç¡®
        ensures result == a + b;
        
        // ç»“æœå¤§äºç­‰äºä»»ä¸€è¾“å…¥
        ensures result >= a && result >= b;
        
        // äº¤æ¢å¾‹
        ensures result == b + a;
        
        // ä¸ä¼š abortï¼ˆåœ¨å‰ç½®æ¡ä»¶æ»¡è¶³æ—¶ï¼‰
        aborts_if a + b > MAX_U64;
    }
    
    /// å®‰å…¨çš„åŠ æ³•ï¼ˆæ£€æŸ¥æº¢å‡ºï¼‰
    public fun safe_add(a: u64, b: u64): u64 {
        assert!(MAX_U64 - a >= b, ERROR_OVERFLOW);
        a + b
    }
    
    spec safe_add {
        // å½“æº¢å‡ºæ—¶ abort
        aborts_if a > MAX_U64 - b with ERROR_OVERFLOW;
        
        // ä¸æº¢å‡ºæ—¶è¿”å›æ­£ç¡®ç»“æœ
        ensures result == a + b;
    }
}
```

### 4.2 æ¨¡å¼ 2ï¼šèµ„æºæ“ä½œéªŒè¯

```move
module my_addr::simple_bank {
    use std::signer;
    
    struct Account has key {
        balance: u64
    }
    
    /// åˆ›å»ºè´¦æˆ·
    public fun create_account(account: &signer) {
        let addr = signer::address_of(account);
        assert!(!exists<Account>(addr), ERROR_ACCOUNT_EXISTS);
        
        move_to(account, Account { balance: 0 });
    }
    
    spec create_account {
        let addr = signer::address_of(account);
        
        // å‰ç½®æ¡ä»¶ï¼šè´¦æˆ·ä¸å­˜åœ¨
        requires !exists<Account>(addr);
        
        // åç½®æ¡ä»¶ï¼šè´¦æˆ·å·²åˆ›å»º
        ensures exists<Account>(addr);
        
        // åç½®æ¡ä»¶ï¼šåˆå§‹ä½™é¢ä¸º 0
        ensures global<Account>(addr).balance == 0;
        
        // ä¸­æ­¢æ¡ä»¶
        aborts_if exists<Account>(addr) with ERROR_ACCOUNT_EXISTS;
    }
    
    /// å­˜æ¬¾
    public fun deposit(addr: address, amount: u64) acquires Account {
        assert!(exists<Account>(addr), ERROR_ACCOUNT_NOT_FOUND);
        assert!(amount > 0, ERROR_INVALID_AMOUNT);
        
        let account = borrow_global_mut<Account>(addr);
        assert!(MAX_U64 - account.balance >= amount, ERROR_OVERFLOW);
        account.balance = account.balance + amount;
    }
    
    spec deposit {
        // å‰ç½®æ¡ä»¶
        requires exists<Account>(addr);
        requires amount > 0;
        requires global<Account>(addr).balance + amount <= MAX_U64;
        
        // åç½®æ¡ä»¶ï¼šä½™é¢å¢åŠ 
        ensures global<Account>(addr).balance == 
                old(global<Account>(addr).balance) + amount;
        
        // ä¸­æ­¢æ¡ä»¶
        aborts_if !exists<Account>(addr);
        aborts_if amount == 0;
        aborts_if global<Account>(addr).balance + amount > MAX_U64;
    }
}
```

### 4.3 æ¨¡å¼ 3ï¼šä»£å¸æ€»é‡ä¸å˜æ€§

```move
module my_addr::simple_token {
    struct TokenInfo has key {
        total_supply: u64
    }
    
    struct Balance has key {
        value: u64
    }
    
    // é“¸é€ ä»£å¸
    public fun mint(to: address, amount: u64) acquires TokenInfo, Balance {
        let info = borrow_global_mut<TokenInfo>(@my_addr);
        assert!(MAX_U64 - info.total_supply >= amount, ERROR_OVERFLOW);
        info.total_supply = info.total_supply + amount;
        
        if (!exists<Balance>(to)) {
            move_to_sender(Balance { value: amount });
        } else {
            let balance = borrow_global_mut<Balance>(to);
            balance.value = balance.value + amount;
        };
    }
    
    spec module {
        // å…¨å±€ä¸å˜é‡ï¼šæ€»ä¾›åº”é‡ç­‰äºæ‰€æœ‰ä½™é¢ä¹‹å’Œ
        invariant forall addr: address where exists<Balance>(addr):
            global<TokenInfo>(@my_addr).total_supply >= 
            global<Balance>(addr).value;
    }
    
    spec mint {
        // æ€»ä¾›åº”é‡å¢åŠ 
        ensures global<TokenInfo>(@my_addr).total_supply == 
                old(global<TokenInfo>(@my_addr).total_supply) + amount;
        
        // æ¥æ”¶æ–¹ä½™é¢å¢åŠ 
        ensures global<Balance>(to).value >= amount;
        
        // ä¸ä¼šæº¢å‡º
        aborts_if global<TokenInfo>(@my_addr).total_supply + amount > MAX_U64;
    }
}
```

### 4.4 æ¨¡å¼ 4ï¼šæƒé™éªŒè¯

```move
module my_addr::admin_module {
    struct AdminCap has key, store { }
    
    struct Resource has key {
        value: u64
    }
    
    /// éœ€è¦ç®¡ç†å‘˜æƒé™çš„æ“ä½œ
    public fun admin_operation(_admin: &AdminCap, new_value: u64) 
        acquires Resource 
    {
        let resource = borrow_global_mut<Resource>(@my_addr);
        resource.value = new_value;
    }
    
    spec admin_operation {
        // å‰ç½®æ¡ä»¶ï¼šç¡®ä¿èµ„æºå­˜åœ¨
        requires exists<Resource>(@my_addr);
        
        // åç½®æ¡ä»¶ï¼šå€¼å·²æ›´æ–°
        ensures global<Resource>(@my_addr).value == new_value;
        
        // éšå¼æƒé™æ£€æŸ¥ï¼šå¿…é¡»æŒæœ‰ AdminCap
        // Move Prover ä¼šéªŒè¯è°ƒç”¨è€…ç¡®å®ä¼ å…¥äº† AdminCap
    }
}
```

---

## ç¬¬äº”éƒ¨åˆ†ï¼šå¸¸è§æ¨¡å¼å’Œæœ€ä½³å®è·µ

### 5.1 ä¸å˜é‡è®¾è®¡åŸåˆ™

**åŸåˆ™ 1ï¼šæ˜ç¡®çš„æ•°æ®çº¦æŸ**
```move
struct Account has key {
    balance: u64,
    frozen: bool
}

spec Account {
    // å†»ç»“çš„è´¦æˆ·ä½™é¢ä¸èƒ½ä¸ºè´Ÿï¼ˆè™½ç„¶ u64 ä¸ä¼šè´Ÿï¼Œä½†è¿™æ˜¯ç¤ºä¾‹ï¼‰
    invariant frozen ==> balance == old(balance);
}
```

**åŸåˆ™ 2ï¼šå®ˆæ’å®šå¾‹**
```move
spec module {
    // ä»£å¸å®ˆæ’ï¼šæ€»ä¾›åº” = æ‰€æœ‰è´¦æˆ·ä½™é¢ä¹‹å’Œ
    invariant total_supply() == sum_of_all_balances();
}
```

**åŸåˆ™ 3ï¼šå•è°ƒæ€§**
```move
spec {
    // æ—¶é—´æˆ³å•è°ƒé€’å¢
    invariant old(timestamp()) <= timestamp();
}
```

### 5.2 å®Œæ•´çš„è½¬è´¦éªŒè¯

```move
public fun transfer(
    from: &signer,
    to: address,
    amount: u64
) acquires Account {
    let from_addr = signer::address_of(from);
    
    // å‰ç½®æ¡ä»¶æ£€æŸ¥
    assert!(exists<Account>(from_addr), ERROR_ACCOUNT_NOT_FOUND);
    assert!(exists<Account>(to), ERROR_ACCOUNT_NOT_FOUND);
    assert!(from_addr != to, ERROR_SELF_TRANSFER);
    assert!(amount > 0, ERROR_INVALID_AMOUNT);
    
    // æ‰§è¡Œè½¬è´¦
    let from_account = borrow_global_mut<Account>(from_addr);
    assert!(from_account.balance >= amount, ERROR_INSUFFICIENT_BALANCE);
    from_account.balance = from_account.balance - amount;
    
    let to_account = borrow_global_mut<Account>(to);
    assert!(MAX_U64 - to_account.balance >= amount, ERROR_OVERFLOW);
    to_account.balance = to_account.balance + amount;
}

spec transfer {
    let from_addr = signer::address_of(from);
    
    // === å‰ç½®æ¡ä»¶ ===
    requires exists<Account>(from_addr);
    requires exists<Account>(to);
    requires from_addr != to;
    requires amount > 0;
    requires global<Account>(from_addr).balance >= amount;
    requires global<Account>(to).balance + amount <= MAX_U64;
    
    // === åç½®æ¡ä»¶ ===
    // å‘é€æ–¹ä½™é¢å‡å°‘
    ensures global<Account>(from_addr).balance == 
            old(global<Account>(from_addr).balance) - amount;
    
    // æ¥æ”¶æ–¹ä½™é¢å¢åŠ 
    ensures global<Account>(to).balance == 
            old(global<Account>(to).balance) + amount;
    
    // æ€»é‡å®ˆæ’
    ensures global<Account>(from_addr).balance + global<Account>(to).balance ==
            old(global<Account>(from_addr).balance + global<Account>(to).balance);
    
    // === ä¸­æ­¢æ¡ä»¶ ===
    aborts_if !exists<Account>(from_addr);
    aborts_if !exists<Account>(to);
    aborts_if from_addr == to;
    aborts_if amount == 0;
    aborts_if global<Account>(from_addr).balance < amount;
    aborts_if global<Account>(to).balance + amount > MAX_U64;
}
```

### 5.3 ä½¿ç”¨ pragma æ§åˆ¶éªŒè¯

```move
spec module {
    // è·³è¿‡æŸäº›éªŒè¯ï¼ˆä¸´æ—¶è°ƒè¯•ç”¨ï¼‰
    pragma verify = false;
}

spec function_name {
    // åªéªŒè¯è¿™ä¸ªå‡½æ•°
    pragma verify = true;
    
    // è®¾ç½®è¶…æ—¶æ—¶é—´ï¼ˆç§’ï¼‰
    pragma timeout = 60;
}
```

---

## ç¬¬å…­éƒ¨åˆ†ï¼šè°ƒè¯•å’Œä¼˜åŒ–

### 6.1 ç†è§£éªŒè¯å¤±è´¥

**ç¤ºä¾‹ï¼šéªŒè¯å¤±è´¥çš„ä¿¡æ¯**
```
error: post-condition does not hold
   â”Œâ”€ example.move:15:9
   â”‚
15 â”‚         ensures result == a + b;
   â”‚         ^^^^^^^^^^^^^^^^^^^^^^^^
   â”‚
   = at example.move:10: add
   = a = 18446744073709551615
   = b = 1
   = result = 0 (overflow occurred)
```

**åˆ†æ**ï¼š
- Prover æ‰¾åˆ°äº†åä¾‹ï¼ša = MAX_U64, b = 1
- å‘ç”Ÿäº†æº¢å‡ºï¼Œresult = 0
- éœ€è¦æ·»åŠ å‰ç½®æ¡ä»¶é˜²æ­¢æº¢å‡º

### 6.2 ä¼˜åŒ–éªŒè¯æ€§èƒ½

**æŠ€å·§ 1ï¼šé™åˆ¶é‡è¯èŒƒå›´**
```move
// âŒ æ…¢ï¼šéå†æ‰€æœ‰åœ°å€
invariant forall addr: address:
    exists<Account>(addr) ==> global<Account>(addr).balance >= 0;

// âœ… å¿«ï¼šåªéå†çœŸæ­£å­˜åœ¨è´¦æˆ·çš„åœ°å€
invariant forall addr: address where exists<Account>(addr):
    global<Account>(addr).balance >= 0;
```

**æŠ€å·§ 2ï¼šåˆ†è§£å¤æ‚è§„çº¦**
```move
// âŒ å¤æ‚çš„å•ä¸€è§„çº¦
spec complex_function {
    ensures condition1 && condition2 && condition3 && condition4;
}

// âœ… åˆ†è§£ä¸ºå¤šä¸ªç®€å•è§„çº¦
spec complex_function {
    ensures condition1;
    ensures condition2;
    ensures condition3;
    ensures condition4;
}
```

**æŠ€å·§ 3ï¼šä½¿ç”¨è¾…åŠ©å‡½æ•°**
```move
spec module {
    fun is_valid_account(addr: address): bool {
        exists<Account>(addr) && global<Account>(addr).balance >= 0
    }
}

spec transfer {
    ensures is_valid_account(from);
    ensures is_valid_account(to);
}
```

### 6.3 å¸¸è§é”™è¯¯å’Œè§£å†³æ–¹æ¡ˆ

| é”™è¯¯ç±»å‹ | åŸå›  | è§£å†³æ–¹æ¡ˆ |
|---------|------|---------|
| Timeout | éªŒè¯å¤ªå¤æ‚ | ç®€åŒ–è§„çº¦ã€å¢åŠ  timeout |
| Inconsistent Assumption | å‰ç½®æ¡ä»¶çŸ›ç›¾ | æ£€æŸ¥ requires æ˜¯å¦å†²çª |
| Postcondition Violated | åç½®æ¡ä»¶ä¸æˆç«‹ | æ£€æŸ¥ä»£ç é€»è¾‘æˆ–ä¿®æ”¹ ensures |
| Invariant Violated | ä¸å˜é‡è¢«ç ´å | æ£€æŸ¥æ‰€æœ‰ä¿®æ”¹è¯¥èµ„æºçš„å‡½æ•° |

---

## ğŸ’¡ å…³é”®è¦ç‚¹æ€»ç»“

1. **å½¢å¼åŒ–éªŒè¯ = æ•°å­¦è¯æ˜**ï¼šæ¯”æµ‹è¯•æ›´å¼ºçš„ä¿è¯
2. **è§„çº¦è¯­è¨€æ ¸å¿ƒ**ï¼š
   - `requires`ï¼šå‰ç½®æ¡ä»¶
   - `ensures`ï¼šåç½®æ¡ä»¶
   - `aborts_if`ï¼šä¸­æ­¢æ¡ä»¶
   - `invariant`ï¼šä¸å˜é‡
3. **å¸¸ç”¨æ¨¡å¼**ï¼š
   - ç®€å•å‡½æ•°ï¼šåŸºæœ¬çš„å‰åç½®æ¡ä»¶
   - èµ„æºæ“ä½œï¼šå­˜åœ¨æ€§å’ŒçŠ¶æ€å˜åŒ–
   - å®ˆæ’å®šå¾‹ï¼šæ€»é‡ä¸å˜
   - æƒé™æ£€æŸ¥ï¼šèƒ½åŠ›å’Œæ‰€æœ‰æƒ
4. **æœ€ä½³å®è·µ**ï¼š
   - ä»ç®€å•å¼€å§‹ï¼Œé€æ­¥æ·»åŠ è§„çº¦
   - ä¸ºå…³é”®å‡½æ•°ç¼–å†™å®Œæ•´è§„çº¦
   - å®šä¹‰æ¸…æ™°çš„æ•°æ®ä¸å˜é‡
   - æµ‹è¯•è§„çº¦çš„æ­£ç¡®æ€§

---

## ğŸ¯ æ€è€ƒé¢˜

1. å½¢å¼åŒ–éªŒè¯èƒ½å®Œå…¨æ›¿ä»£æµ‹è¯•å—ï¼Ÿä¸ºä»€ä¹ˆï¼Ÿ
2. ä»€ä¹ˆæ ·çš„é¡¹ç›®æœ€é€‚åˆä½¿ç”¨å½¢å¼åŒ–éªŒè¯ï¼Ÿ
3. å¦‚ä½•å¹³è¡¡éªŒè¯çš„å®Œæ•´æ€§å’Œå¼€å‘æ•ˆç‡ï¼Ÿ
4. Move Prover ç›¸æ¯”ä¼ ç»Ÿæµ‹è¯•çš„ä¼˜åŠ¿å’ŒåŠ£åŠ¿æ˜¯ä»€ä¹ˆï¼Ÿ

---

## ğŸ“š æ‰©å±•é˜…è¯»

- [Move Prover ç”¨æˆ·æŒ‡å—](https://github.com/move-language/move/blob/main/language/move-prover/doc/user/prover-guide.md)
- [Diem çš„å½¢å¼åŒ–éªŒè¯å®è·µ](https://www.diem.com/en-us/white-paper/)
- [Z3 Solver ç®€ä»‹](https://github.com/Z3Prover/z3)

---

**ä¸‹ä¸€æ­¥**ï¼šå­¦ä¹ ä»£ç ç¤ºä¾‹ï¼Œç„¶åå®Œæˆå®è·µä»»åŠ¡ï¼ğŸš€

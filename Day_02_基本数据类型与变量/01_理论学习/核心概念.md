# Move语言基本数据类型与变量核心概念

## 第一部分：Move的类型系统概述

### 1.1 为什么类型系统重要？

Move是一门**静态类型语言**，这意味着：
- 所有变量的类型在编译时就确定
- 编译器可以提前发现类型错误
- 不存在运行时类型转换的开销
- 类型安全是资源安全的基础

### 1.2 Move的类型特点

1. **强类型**：不允许隐式类型转换
2. **线性类型**：某些值只能被使用一次（Move语义）
3. **无空值**：没有null或undefined
4. **所有权明确**：每个值都有明确的所有者

---

## 第二部分：基本数据类型

### 2.1 整数类型

Move提供了四种无符号整数类型（**没有有符号整数**）：

| 类型 | 位数 | 取值范围 | 用途 |
|------|------|----------|------|
| `u8` | 8位 | 0 ~ 255 | 小数值、状态码、年龄等 |
| `u64` | 64位 | 0 ~ 18,446,744,073,709,551,615 | 代币数量、余额、计数器 |
| `u128` | 128位 | 0 ~ 2^128 - 1 | 大额资产、精确计算 |
| `u256` | 256位 | 0 ~ 2^256 - 1 | 加密哈希、超大数值 |

#### 为什么没有有符号整数？

```move
// ❌ 这可能导致安全问题
let balance: i64 = 1000;
balance = balance - 2000;  // 变成 -1000，但余额不应该为负！

// ✅ Move的做法：使用无符号整数，减法会在下溢时中止
let balance: u64 = 1000;
balance = balance - 2000;  // 程序会abort，防止错误状态
```

#### 整数字面量

```move
// 十进制
let a: u8 = 10;
let b: u64 = 1000000;

// 十六进制
let c: u8 = 0xFF;      // 255
let d: u64 = 0x1000;   // 4096

// 使用下划线提高可读性
let million: u64 = 1_000_000;
let billion: u128 = 1_000_000_000;

// 类型后缀（可选）
let x = 100u8;    // u8类型
let y = 1000u64;  // u64类型
let z = 1000u128; // u128类型
```

#### 整数运算

```move
// 基本运算
let sum = 5 + 3;        // 8
let diff = 10 - 4;      // 6
let product = 4 * 7;    // 28
let quotient = 20 / 3;  // 6 (整数除法)
let remainder = 20 % 3; // 2

// ⚠️ 注意溢出和下溢
let max: u8 = 255;
// max = max + 1;  // ❌ 运行时会abort（溢出）

let min: u8 = 0;
// min = min - 1;  // ❌ 运行时会abort（下溢）

// 位运算
let a = 0b1010;  // 10
let b = 0b1100;  // 12
let and = a & b;   // 0b1000 = 8
let or = a | b;    // 0b1110 = 14
let xor = a ^ b;   // 0b0110 = 6
let shift_left = a << 1;   // 0b10100 = 20
let shift_right = a >> 1;  // 0b0101 = 5
```

### 2.2 布尔类型

```move
// 布尔类型只有两个值
let is_active: bool = true;
let is_paused: bool = false;

// 逻辑运算
let a = true;
let b = false;

let and = a && b;  // false
let or = a || b;   // true
let not = !a;      // false

// 比较运算返回布尔值
let x = 10;
let y = 20;

let equal = (x == y);        // false
let not_equal = (x != y);    // true
let less = (x < y);          // true
let less_equal = (x <= y);   // true
let greater = (x > y);       // false
let greater_equal = (x >= y); // false
```

#### 短路求值

```move
// && 和 || 是短路运算符
let result = false && expensive_function();  // expensive_function不会被调用

// 这在条件检查中很有用
if (vector::length(&v) > 0 && *vector::borrow(&v, 0) == 1) {
    // 只有当向量非空时，才会访问第一个元素
}
```

### 2.3 地址类型

地址是Move中表示账户或资源位置的特殊类型。

```move
// 地址字面量
let addr1: address = @0x1;                  // 标准库地址
let addr2: address = @0x42;                 // 十六进制地址
let addr3: address = @my_module;            // 命名地址
let addr4: address = @0x1234567890ABCDEF;   // 完整地址

// Aptos地址是32字节（256位）
let aptos_addr: address = @0x1a2b3c4d5e6f7890a1b2c3d4e5f6789012345678901234567890123456789012;

// 地址比较
let is_same = (addr1 == addr2);  // false
let is_different = (addr1 != addr2);  // true

// 地址不支持算术运算
// let wrong = addr1 + 1;  // ❌ 编译错误
```

#### 地址的用途

```move
module my_addr::example {
    use std::signer;
    
    // 1. 资源存储位置
    public fun store_data(account: &signer) {
        let addr = signer::address_of(account);  // 获取账户地址
        // 资源存储在该地址下...
    }
    
    // 2. 访问控制
    public fun only_admin(account: &signer) {
        let addr = signer::address_of(account);
        assert!(addr == @admin_address, 1);  // 只有admin可以调用
    }
    
    // 3. 资源查询
    public fun check_balance(addr: address): bool {
        exists<Balance>(addr)  // 检查该地址是否有Balance资源
    }
}
```

---

## 第三部分：变量声明与绑定

### 3.1 变量声明

Move使用`let`关键字声明变量：

```move
// 基本语法
let variable_name: type = value;

// 示例
let x: u64 = 10;
let is_valid: bool = true;
let addr: address = @0x1;

// 类型推导
let x = 10;          // 编译器推导为 u64
let is_valid = true; // 编译器推导为 bool
```

### 3.2 不可变变量（默认）

**Move中的变量默认是不可变的**：

```move
let x = 10;
// x = 20;  // ❌ 编译错误：变量x是不可变的

// 为什么默认不可变？
// 1. 防止意外修改
// 2. 更容易推理代码行为
// 3. 符合函数式编程思想
```

### 3.3 可变变量

使用`mut`关键字声明可变变量：

```move
let mut x = 10;
x = 20;  // ✅ 正确
x = x + 5;  // ✅ 正确

// 可变引用
let mut y = 100;
let ref_y = &mut y;
*ref_y = 200;  // 通过可变引用修改值
```

#### 可变性规则

```move
// 1. 不能将可变变量赋值给不可变变量
let mut x = 10;
// let y = &x;  // ❌ 如果x可变，不能创建不可变引用（当存在可变引用时）

// 2. 可变引用是独占的
let mut x = 10;
let ref1 = &mut x;
// let ref2 = &mut x;  // ❌ 不能同时有两个可变引用
// let ref3 = &x;      // ❌ 不能在可变引用存在时创建不可变引用

// 3. 不可变引用可以共存
let x = 10;
let ref1 = &x;
let ref2 = &x;  // ✅ 可以有多个不可变引用
```

### 3.4 变量遮蔽（Shadowing）

Move允许在同一作用域内重新声明同名变量：

```move
let x = 5;
let x = x + 1;  // 创建新变量x，遮蔽了旧的x
let x = x * 2;  // 再次遮蔽

// 可以改变类型
let x = 5;
let x = "hello";  // ✅ 新的x是不同类型

// 与可变变量的区别
let mut y = 5;
y = y + 1;  // 修改同一个变量
// y = "hello";  // ❌ 不能改变类型
```

### 3.5 变量作用域

```move
{
    let x = 10;
    {
        let y = 20;
        let sum = x + y;  // 可以访问外层的x
    }
    // y在这里不可见
}
// x在这里不可见
```

---

## 第四部分：常量

### 4.1 常量定义

常量在编译时确定，必须是字面量或常量表达式：

```move
module my_addr::constants {
    // 常量命名通常使用大写和下划线
    const MAX_SUPPLY: u64 = 1_000_000;
    const MIN_BALANCE: u64 = 100;
    const PLATFORM_FEE_PERCENT: u64 = 5;
    const ADMIN_ADDRESS: address = @0x1;
    const IS_ENABLED: bool = true;
    
    // 常量表达式
    const MAX_U64: u64 = 18446744073709551615;
    const HALF_MAX: u64 = MAX_U64 / 2;
    
    // 错误码常量
    const E_INSUFFICIENT_BALANCE: u64 = 1;
    const E_INVALID_AMOUNT: u64 = 2;
    const E_NOT_AUTHORIZED: u64 = 3;
    
    public fun get_max_supply(): u64 {
        MAX_SUPPLY
    }
    
    public fun calculate_fee(amount: u64): u64 {
        amount * PLATFORM_FEE_PERCENT / 100
    }
}
```

### 4.2 常量 vs 变量

| 特性 | 常量 | 变量 |
|------|------|------|
| 关键字 | `const` | `let` |
| 可变性 | 永不可变 | 可选（`mut`） |
| 作用域 | 模块级别 | 函数/代码块 |
| 初始化 | 必须是字面量/常量表达式 | 可以是任何表达式 |
| 命名规范 | UPPER_CASE | snake_case |

---

## 第五部分：Move语义（所有权与移动）

### 5.1 什么是Move语义？

Move语言的核心特性：**某些值在赋值或传递时会被"移动"，而不是复制**。

```move
struct Box {
    value: u64
}

let box1 = Box { value: 100 };
let box2 = box1;  // box1的所有权移动到box2

// box1现在不能再使用
// let x = box1.value;  // ❌ 编译错误：box1已被移动
```

### 5.2 复制（Copy）vs 移动（Move）

Move中的类型分为两类：

#### 有Copy能力的类型（会复制）

```move
// 基本类型都有Copy能力
let x: u64 = 10;
let y = x;  // x被复制给y
let z = x;  // x仍然可用，再次复制

// 基本类型包括：
// - 整数：u8, u64, u128, u256
// - 布尔：bool
// - 地址：address
```

#### 无Copy能力的类型（会移动）

```move
// 默认情况下，结构体没有Copy能力
struct Resource {
    value: u64
}

let r1 = Resource { value: 100 };
let r2 = r1;  // r1被移动到r2
// let r3 = r1;  // ❌ 编译错误：r1已被移动

// 如果想要Copy，必须显式声明
struct CopyableData has copy {
    value: u64
}

let d1 = CopyableData { value: 100 };
let d2 = d1;  // d1被复制
let d3 = d1;  // ✅ d1仍然可用
```

### 5.3 能力（Abilities）系统

Move使用abilities来控制类型的行为：

```move
// copy: 可以复制
struct Data has copy {
    value: u64
}

// drop: 可以被丢弃/销毁
struct Droppable has drop {
    value: u64
}

// key: 可以作为全局存储的键
struct StorableData has key {
    value: u64
}

// store: 可以存储在其他结构体中
struct Storable has store {
    value: u64
}

// 组合能力
struct FlexibleData has copy, drop, store {
    value: u64
}

// 资源类型（只有key，无copy和drop）
struct Resource has key {
    value: u64
    // 不能复制，不能随意丢弃，只能通过特定API管理
}
```

### 5.4 引用与借用

当不想转移所有权时，使用引用：

```move
struct Data has drop {
    value: u64
}

// 不可变引用
let data = Data { value: 100 };
let ref_data = &data;  // 借用不可变引用
let value = ref_data.value;  // 读取值
// data仍然可用

// 可变引用
let mut data = Data { value: 100 };
let ref_data = &mut data;  // 借用可变引用
ref_data.value = 200;  // 修改值
// data仍然可用，但值已改变

// 解引用
let mut x = 10;
let ref_x = &mut x;
*ref_x = 20;  // 解引用并赋值
```

#### 借用规则

```move
// 规则1：不可变引用可以有多个
let x = 10;
let r1 = &x;
let r2 = &x;
let r3 = &x;  // ✅ OK

// 规则2：可变引用同时只能有一个
let mut x = 10;
let r1 = &mut x;
// let r2 = &mut x;  // ❌ 错误：已有可变引用

// 规则3：可变引用和不可变引用不能同时存在
let mut x = 10;
let r1 = &mut x;
// let r2 = &x;  // ❌ 错误：已有可变引用
```

---

## 第六部分：类型转换

### 6.1 整数类型转换

Move不支持隐式类型转换，必须显式转换：

```move
// 小类型转大类型（安全）
let x: u8 = 255;
let y: u64 = (x as u64);      // 255u64
let z: u128 = (y as u128);    // 255u128

// 大类型转小类型（可能截断）
let a: u64 = 1000;
let b: u8 = (a as u8);  // 232 (1000 % 256)，会截断！

// ⚠️ 转换时要小心截断
let large: u64 = 300;
let small: u8 = (large as u8);  // 44，而不是300！
```

### 6.2 转换最佳实践

```move
// ✅ 好的做法：转换前检查范围
const MAX_U8: u64 = 255;

public fun safe_convert(value: u64): u8 {
    assert!(value <= MAX_U8, 1);  // 确保不会截断
    (value as u8)
}

// ❌ 不好的做法：直接转换大值
public fun unsafe_convert(value: u64): u8 {
    (value as u8)  // 可能导致意外结果
}
```

---

## 第七部分：元组（Tuples）

### 7.1 元组基础

元组是固定大小的多个值的集合：

```move
// 创建元组
let pair: (u64, bool) = (100, true);
let triple: (u8, address, bool) = (10, @0x1, false);

// 空元组（unit类型）
let unit: () = ();
```

### 7.2 元组解构

```move
// 解构元组
let pair = (100, true);
let (x, y) = pair;
// 现在 x = 100, y = true

// 部分解构
let triple = (10, @0x1, false);
let (a, _, c) = triple;  // 忽略中间值
// a = 10, c = false

// 函数返回多个值
public fun swap(x: u64, y: u64): (u64, u64) {
    (y, x)
}

let (a, b) = swap(1, 2);  // a = 2, b = 1
```

### 7.3 元组的应用

```move
// 返回多个值
public fun get_user_info(): (u64, bool, address) {
    (25, true, @0x123)  // 年龄、验证状态、地址
}

let (age, verified, addr) = get_user_info();

// 原子交换
public fun atomic_swap(x: &mut u64, y: &mut u64) {
    let temp_x = *x;
    let temp_y = *y;
    *x = temp_y;
    *y = temp_x;
}

// 或使用元组
public fun atomic_swap_v2(x: &mut u64, y: &mut u64) {
    (*x, *y) = (*y, *x);
}
```

---

## 第八部分：实践建议

### 8.1 类型选择原则

1. **整数类型选择**
   - 计数器、数组索引：`u64`
   - 百分比、状态码：`u8`
   - 代币数量、余额：`u64`或`u128`（根据精度需求）
   - 哈希值、加密相关：`u256`

2. **变量可变性**
   - 默认使用不可变变量
   - 只在必要时使用`mut`
   - 循环计数器可以使用`mut`

3. **常量使用**
   - 错误码定义为常量
   - 配置参数定义为常量
   - 魔法数字定义为命名常量

### 8.2 常见错误避免

```move
// ❌ 错误1：整数溢出
let x: u8 = 255;
// x = x + 1;  // 运行时panic

// ✅ 正确：检查溢出
let x: u8 = 255;
assert!(x < 255, 1);
x = x + 1;

// ❌ 错误2：忘记可变性
let x = 10;
// x = 20;  // 编译错误

// ✅ 正确：声明为可变
let mut x = 10;
x = 20;

// ❌ 错误3：类型转换截断
let large: u64 = 1000;
let small: u8 = (large as u8);  // 意外截断

// ✅ 正确：转换前检查
assert!(large <= 255, 1);
let small: u8 = (large as u8);
```

### 8.3 性能优化提示

1. **使用合适的整数大小**
   ```move
   // ❌ 过度使用u256
   let age: u256 = 25;  // 浪费空间
   
   // ✅ 使用合适的大小
   let age: u8 = 25;
   ```

2. **减少不必要的复制**
   ```move
   // ❌ 复制大结构体
   public fun process(data: LargeStruct) { }  // 如果LargeStruct有copy
   
   // ✅ 使用引用
   public fun process(data: &LargeStruct) { }
   ```

3. **使用常量而非变量**
   ```move
   // ❌ 重复计算
   public fun calculate(): u64 {
       let fee_percent = 5;
       amount * fee_percent / 100
   }
   
   // ✅ 使用常量
   const FEE_PERCENT: u64 = 5;
   public fun calculate(): u64 {
       amount * FEE_PERCENT / 100
   }
   ```

---

## 总结

### 关键要点

1. ✅ Move是强类型静态语言，类型安全是核心
2. ✅ 只有无符号整数，防止负数余额等错误
3. ✅ 变量默认不可变，体现函数式编程思想
4. ✅ Move语义确保资源不会被意外复制
5. ✅ 能力系统精确控制类型行为
6. ✅ 引用借用规则保证内存安全

### 下一步

掌握了基本数据类型和变量后，你可以：
- 实现复杂的数据结构
- 理解资源管理机制
- 编写类型安全的智能合约
- 深入学习泛型和能力系统

**记住**：Move的设计哲学是"安全第一"，所有的类型规则都是为了防止资产丢失和状态错误！

# Day 32 æ¯æ—¥è€ƒè¯• - ç­”æ¡ˆè§£æ

## ğŸ“š ç¼–ç¨‹é¢˜ç­”æ¡ˆä¸è¯¦ç»†è§£æ

---

## ç¼–ç¨‹é¢˜ 1: MEVæ£€æµ‹å™¨ - å‚è€ƒç­”æ¡ˆ

### å®Œæ•´å®ç°

```move
module exam::mev_detector {
    use std::signer;
    use std::vector;
    use aptos_framework::event::{Self, EventHandle};
    use aptos_framework::timestamp;
    use aptos_std::table::{Self, Table};

    /// äº¤æ˜“è®°å½•
    struct Transaction has store, copy, drop {
        sender: address,
        amount: u64,
        timestamp: u64,
    }

    /// MEVæ£€æµ‹å™¨
    struct Detector has key {
        transactions: vector<Transaction>,
        suspicious_addresses: Table<address, u64>,
        alert_events: EventHandle<SandwichAlert>,
    }

    /// Sandwichæ”»å‡»å‘Šè­¦
    struct SandwichAlert has drop, store {
        attacker: address,
        victim: address,
        front_amount: u64,
        back_amount: u64,
        timestamp: u64,
    }

    const MAX_HISTORY: u64 = 50;
    const ERROR_NOT_INITIALIZED: u64 = 1;

    /// åˆå§‹åŒ–æ£€æµ‹å™¨
    public fun initialize(admin: &signer) {
        move_to(admin, Detector {
            transactions: vector::empty(),
            suspicious_addresses: table::new(),
            alert_events: event::new_event_handle<SandwichAlert>(admin),
        });
    }

    /// è®°å½•äº¤æ˜“å¹¶æ£€æµ‹
    public fun record_transaction(
        detector_addr: address,
        sender: address,
        amount: u64,
    ) acquires Detector {
        let detector = borrow_global_mut<Detector>(detector_addr);
        
        // åˆ›å»ºäº¤æ˜“è®°å½•
        let tx = Transaction {
            sender,
            amount,
            timestamp: timestamp::now_seconds(),
        };
        
        // æ·»åŠ åˆ°å†å²
        vector::push_back(&mut detector.transactions, tx);
        
        // ä¿æŒçª—å£å¤§å°
        if (vector::length(&detector.transactions) > MAX_HISTORY) {
            vector::remove(&mut detector.transactions, 0);
        };
        
        // æ£€æµ‹sandwichæ”»å‡»
        if (detect_sandwich(&detector.transactions)) {
            let len = vector::length(&detector.transactions);
            let t1 = *vector::borrow(&detector.transactions, len - 3);
            let t2 = *vector::borrow(&detector.transactions, len - 2);
            let t3 = *vector::borrow(&detector.transactions, len - 1);
            
            // å‘å‡ºå‘Šè­¦
            event::emit_event(&mut detector.alert_events, SandwichAlert {
                attacker: t1.sender,
                victim: t2.sender,
                front_amount: t1.amount,
                back_amount: t3.amount,
                timestamp: timestamp::now_seconds(),
            });
            
            // æ›´æ–°æ”»å‡»è®¡æ•°
            if (!table::contains(&detector.suspicious_addresses, t1.sender)) {
                table::add(&mut detector.suspicious_addresses, t1.sender, 1);
            } else {
                let count = table::borrow_mut(&mut detector.suspicious_addresses, t1.sender);
                *count = *count + 1;
            };
        };
    }

    /// æ£€æµ‹sandwichæ”»å‡»
    fun detect_sandwich(transactions: &vector<Transaction>): bool {
        let len = vector::length(transactions);
        if (len < 3) return false;
        
        let t1 = vector::borrow(transactions, len - 3);
        let t2 = vector::borrow(transactions, len - 2);
        let t3 = vector::borrow(transactions, len - 1);
        
        // æ¡ä»¶1: å‰åäº¤æ˜“æ¥è‡ªåŒä¸€åœ°å€
        if (t1.sender != t3.sender) return false;
        
        // æ¡ä»¶2: ä¸­é—´äº¤æ˜“æ¥è‡ªä¸åŒåœ°å€
        if (t1.sender == t2.sender) return false;
        
        // æ¡ä»¶3: é‡‘é¢ç›¸ä¼¼ï¼ˆÂ±10%ï¼‰
        if (!amounts_similar(t1.amount, t3.amount)) return false;
        
        // æ¡ä»¶4: æ—¶é—´æ¥è¿‘ï¼ˆ5ç§’å†…ï¼‰
        if (t3.timestamp - t1.timestamp > 5) return false;
        
        true
    }

    /// åˆ¤æ–­é‡‘é¢æ˜¯å¦ç›¸ä¼¼
    fun amounts_similar(a: u64, b: u64): bool {
        let diff = if (a > b) { a - b } else { b - a };
        let threshold = a / 10; // 10%
        diff <= threshold
    }

    /// æŸ¥è¯¢æ”»å‡»æ¬¡æ•°
    public fun get_attack_count(
        detector_addr: address,
        addr: address,
    ): u64 acquires Detector {
        let detector = borrow_global<Detector>(detector_addr);
        if (table::contains(&detector.suspicious_addresses, addr)) {
            *table::borrow(&detector.suspicious_addresses, addr)
        } else {
            0
        }
    }

    #[test_only]
    public fun get_transaction_count(detector_addr: address): u64 acquires Detector {
        let detector = borrow_global<Detector>(detector_addr);
        vector::length(&detector.transactions)
    }
}

// ===== æµ‹è¯•æ¨¡å— =====

#[test_only]
module exam::mev_detector_test {
    use exam::mev_detector;
    use aptos_framework::timestamp;
    use std::signer;
    
    #[test(admin = @0x123, framework = @0x1)]
    public fun test_initialization(admin: &signer, framework: &signer) {
        timestamp::set_time_has_started_for_testing(framework);
        mev_detector::initialize(admin);
    }
    
    #[test(admin = @0x123, attacker = @0x456, victim = @0x789, framework = @0x1)]
    public fun test_sandwich_detection(
        admin: &signer,
        attacker: &signer,
        victim: &signer,
        framework: &signer
    ) {
        timestamp::set_time_has_started_for_testing(framework);
        mev_detector::initialize(admin);
        
        let detector_addr = signer::address_of(admin);
        let attacker_addr = signer::address_of(attacker);
        let victim_addr = signer::address_of(victim);
        
        // æ¨¡æ‹Ÿsandwichæ”»å‡»
        
        // T1: æ”»å‡»è€…ä¹°å…¥
        mev_detector::record_transaction(detector_addr, attacker_addr, 10000);
        timestamp::fast_forward_seconds(1);
        
        // T2: å—å®³è€…äº¤æ˜“
        mev_detector::record_transaction(detector_addr, victim_addr, 50000);
        timestamp::fast_forward_seconds(1);
        
        // T3: æ”»å‡»è€…å–å‡º
        mev_detector::record_transaction(detector_addr, attacker_addr, 10000);
        
        // éªŒè¯æ£€æµ‹åˆ°æ”»å‡»
        let attack_count = mev_detector::get_attack_count(detector_addr, attacker_addr);
        assert!(attack_count == 1, 0);
    }
    
    #[test(admin = @0x123, user1 = @0x456, user2 = @0x789, framework = @0x1)]
    public fun test_normal_transactions(
        admin: &signer,
        user1: &signer,
        user2: &signer,
        framework: &signer
    ) {
        timestamp::set_time_has_started_for_testing(framework);
        mev_detector::initialize(admin);
        
        let detector_addr = signer::address_of(admin);
        let user1_addr = signer::address_of(user1);
        let user2_addr = signer::address_of(user2);
        
        // æ­£å¸¸äº¤æ˜“ï¼šä¸åŒç”¨æˆ·ï¼Œä¸åŒé‡‘é¢
        mev_detector::record_transaction(detector_addr, user1_addr, 5000);
        timestamp::fast_forward_seconds(1);
        
        mev_detector::record_transaction(detector_addr, user2_addr, 8000);
        timestamp::fast_forward_seconds(1);
        
        mev_detector::record_transaction(detector_addr, user1_addr, 3000);
        
        // ä¸åº”è¯¥æ£€æµ‹åˆ°æ”»å‡»
        let attack_count = mev_detector::get_attack_count(detector_addr, user1_addr);
        assert!(attack_count == 0, 1);
    }
}
```

### å…³é”®ç‚¹è§£æ

1. **æ•°æ®ç»“æ„è®¾è®¡**
   - ä½¿ç”¨vectorå­˜å‚¨æ»‘åŠ¨çª—å£
   - ä½¿ç”¨Tableè®°å½•å¯ç–‘åœ°å€
   - ä½¿ç”¨EventHandleå‘å‡ºå‘Šè­¦

2. **æ£€æµ‹é€»è¾‘**
   - æ£€æŸ¥æœ€è¿‘3ç¬”äº¤æ˜“
   - å››ä¸ªæ¡ä»¶å¿…é¡»å…¨éƒ¨æ»¡è¶³
   - æ—¶é—´æˆ³ç¡®ä¿å®æ—¶æ€§

3. **ä¼˜åŒ–ç‚¹**
   - é™åˆ¶å†å²è®°å½•æ•°é‡ï¼ˆèŠ‚çœå­˜å‚¨ï¼‰
   - åªåœ¨æ·»åŠ æ–°äº¤æ˜“æ—¶æ£€æµ‹ï¼ˆæ•ˆç‡ï¼‰

---

## ç¼–ç¨‹é¢˜ 2: æ»‘ç‚¹ä¿æŠ¤çš„Swap - å‚è€ƒç­”æ¡ˆ

### å®Œæ•´å®ç°

```move
module exam::protected_swap {
    use std::signer;
    use aptos_framework::coin::{Self, Coin};
    use aptos_framework::timestamp;
    use std::vector;

    /// æµåŠ¨æ€§æ± 
    struct LiquidityPool<phantom CoinA, phantom CoinB> has key {
        reserve_a: u64,
        reserve_b: u64,
        total_supply: u64,
    }

    /// TWAPé¢„è¨€æœº
    struct TWAPOracle has key {
        cumulative_price: u128,
        last_price: u64,
        last_update: u64,
        observations: vector<PriceObservation>,
    }

    struct PriceObservation has store, copy, drop {
        timestamp: u64,
        price: u64,
        cumulative: u128,
    }

    const ERROR_SLIPPAGE_TOO_HIGH: u64 = 1;
    const ERROR_INSUFFICIENT_LIQUIDITY: u64 = 2;
    const ERROR_ZERO_AMOUNT: u64 = 3;

    const MAX_OBSERVATIONS: u64 = 100;

    // ===== æµåŠ¨æ€§æ± å‡½æ•° =====

    /// åˆå§‹åŒ–æµåŠ¨æ€§æ± 
    public fun initialize_pool<CoinA, CoinB>(
        admin: &signer,
        initial_a: u64,
        initial_b: u64,
    ) {
        move_to(admin, LiquidityPool<CoinA, CoinB> {
            reserve_a: initial_a,
            reserve_b: initial_b,
            total_supply: 0,
        });
    }

    /// å¸¦æ»‘ç‚¹ä¿æŠ¤çš„swap
    public fun swap_a_to_b<CoinA, CoinB>(
        user: &signer,
        pool_addr: address,
        amount_in: u64,
        min_amount_out: u64,
    ): u64 acquires LiquidityPool {
        assert!(amount_in > 0, ERROR_ZERO_AMOUNT);
        
        let pool = borrow_global_mut<LiquidityPool<CoinA, CoinB>>(pool_addr);
        
        // è®¡ç®—è¾“å‡º
        let amount_out = calculate_output_amount(
            amount_in,
            pool.reserve_a,
            pool.reserve_b
        );
        
        // æ»‘ç‚¹æ£€æŸ¥
        assert!(amount_out >= min_amount_out, ERROR_SLIPPAGE_TOO_HIGH);
        
        // æ›´æ–°å‚¨å¤‡
        pool.reserve_a = pool.reserve_a + amount_in;
        pool.reserve_b = pool.reserve_b - amount_out;
        
        amount_out
    }

    /// è®¡ç®—è¾“å‡ºé‡‘é¢ï¼ˆæ’å®šä¹˜ç§¯å…¬å¼ï¼‰
    public fun calculate_output_amount(
        amount_in: u64,
        reserve_in: u64,
        reserve_out: u64,
    ): u64 {
        assert!(amount_in > 0, ERROR_ZERO_AMOUNT);
        assert!(reserve_in > 0 && reserve_out > 0, ERROR_INSUFFICIENT_LIQUIDITY);
        
        // amount_out = (reserve_out * amount_in) / (reserve_in + amount_in)
        let numerator = (reserve_out as u128) * (amount_in as u128);
        let denominator = (reserve_in as u128) + (amount_in as u128);
        ((numerator / denominator) as u64)
    }

    /// è®¡ç®—ä»·æ ¼å½±å“ï¼ˆåŸºç‚¹ï¼‰
    public fun calculate_price_impact(
        amount_in: u64,
        reserve_in: u64,
    ): u64 {
        // price_impact = (amount_in / (reserve_in + amount_in)) * 10000
        let numerator = (amount_in as u128) * 10000;
        let denominator = (reserve_in as u128) + (amount_in as u128);
        ((numerator / denominator) as u64)
    }

    /// æ¨èæ»‘ç‚¹
    public fun recommend_slippage(
        amount_in: u64,
        reserve_in: u64,
    ): u64 {
        let impact = calculate_price_impact(amount_in, reserve_in);
        
        if (impact < 10) {          // < 0.1%
            50                       // 0.5%
        } else if (impact < 100) {  // < 1%
            100                      // 1%
        } else if (impact < 500) {  // < 5%
            300                      // 3%
        } else {
            500                      // 5%
        }
    }

    // ===== TWAPé¢„è¨€æœº =====

    /// åˆå§‹åŒ–TWAP
    public fun initialize_oracle(admin: &signer, initial_price: u64) {
        move_to(admin, TWAPOracle {
            cumulative_price: 0,
            last_price: initial_price,
            last_update: timestamp::now_seconds(),
            observations: vector::empty(),
        });
    }

    /// æ›´æ–°ä»·æ ¼
    public fun update_price(
        oracle_addr: address,
        new_price: u64,
    ) acquires TWAPOracle {
        let oracle = borrow_global_mut<TWAPOracle>(oracle_addr);
        let now = timestamp::now_seconds();
        let elapsed = now - oracle.last_update;
        
        // ç´¯åŠ ä»·æ ¼
        oracle.cumulative_price = oracle.cumulative_price + 
            (oracle.last_price as u128) * (elapsed as u128);
        
        // è®°å½•è§‚å¯Ÿç‚¹
        let observation = PriceObservation {
            timestamp: now,
            price: new_price,
            cumulative: oracle.cumulative_price,
        };
        vector::push_back(&mut oracle.observations, observation);
        
        // ä¿æŒè§‚å¯Ÿç‚¹æ•°é‡
        if (vector::length(&oracle.observations) > MAX_OBSERVATIONS) {
            vector::remove(&mut oracle.observations, 0);
        };
        
        // æ›´æ–°çŠ¶æ€
        oracle.last_price = new_price;
        oracle.last_update = now;
    }

    /// è·å–TWAP
    public fun get_twap(
        oracle_addr: address,
        period_seconds: u64,
    ): u64 acquires TWAPOracle {
        let oracle = borrow_global<TWAPOracle>(oracle_addr);
        let now = timestamp::now_seconds();
        let target_time = now - period_seconds;
        
        // æ‰¾åˆ°ç›®æ ‡æ—¶é—´çš„è§‚å¯Ÿç‚¹
        let obs = &oracle.observations;
        let len = vector::length(obs);
        assert!(len > 0, 100);
        
        let i = 0;
        let old_observation = vector::borrow(obs, 0);
        
        while (i < len) {
            let current = vector::borrow(obs, i);
            if (current.timestamp >= target_time) {
                break
            };
            old_observation = current;
            i = i + 1;
        };
        
        // è®¡ç®—TWAP
        let time_elapsed = now - old_observation.timestamp;
        if (time_elapsed == 0) return oracle.last_price;
        
        let price_delta = oracle.cumulative_price - old_observation.cumulative;
        ((price_delta / (time_elapsed as u128)) as u64)
    }

    // ===== è¾…åŠ©å‡½æ•° =====

    #[test_only]
    public fun get_reserves<CoinA, CoinB>(pool_addr: address): (u64, u64) acquires LiquidityPool {
        let pool = borrow_global<LiquidityPool<CoinA, CoinB>>(pool_addr);
        (pool.reserve_a, pool.reserve_b)
    }
}

// ===== æµ‹è¯• =====

#[test_only]
module exam::protected_swap_test {
    use exam::protected_swap;
    use aptos_framework::timestamp;
    use std::signer;
    
    struct CoinA {}
    struct CoinB {}
    
    #[test(framework = @0x1)]
    fun test_output_calculation(framework: &signer) {
        timestamp::set_time_has_started_for_testing(framework);
        
        // reserve_in=10000, reserve_out=100000, amount_in=100
        let amount_out = protected_swap::calculate_output_amount(100, 10000, 100000);
        
        // æœŸæœ›: 100000 * 100 / (10000 + 100) = 990
        assert!(amount_out == 990, 0);
    }
    
    #[test(admin = @0x123, framework = @0x1)]
    #[expected_failure(abort_code = 1)]
    fun test_slippage_protection(admin: &signer, framework: &signer) {
        timestamp::set_time_has_started_for_testing(framework);
        
        protected_swap::initialize_pool<CoinA, CoinB>(admin, 10000, 100000);
        
        // å°è¯•swapï¼Œä½†è®¾ç½®è¿‡é«˜çš„min_amount_out
        let _ = protected_swap::swap_a_to_b<CoinA, CoinB>(
            admin,
            signer::address_of(admin),
            100,
            1000, // è¦æ±‚1000ï¼Œä½†å®é™…åªèƒ½å¾—åˆ°990
        );
    }
    
    #[test(admin = @0x123, framework = @0x1)]
    fun test_twap_calculation(admin: &signer, framework: &signer) {
        timestamp::set_time_has_started_for_testing(framework);
        
        let admin_addr = signer::address_of(admin);
        protected_swap::initialize_oracle(admin, 1000);
        
        // ç­‰å¾…10ç§’
        timestamp::fast_forward_seconds(10);
        protected_swap::update_price(admin_addr, 1100);
        
        // ç­‰å¾…10ç§’
        timestamp::fast_forward_seconds(10);
        protected_swap::update_price(admin_addr, 1200);
        
        // è·å–20ç§’TWAP
        let twap = protected_swap::get_twap(admin_addr, 20);
        
        // åº”è¯¥æ¥è¿‘å¹³å‡å€¼ (1000*10 + 1100*10) / 20 = 1050
        assert!(twap >= 1040 && twap <= 1060, 0);
    }
}
```

### å…³é”®ç‚¹è§£æ

1. **æ’å®šä¹˜ç§¯å…¬å¼**
   ```
   x * y = k (constant)
   amount_out = (y * Î”x) / (x + Î”x)
   ```

2. **TWAPè®¡ç®—**
   - ç´¯ç§¯ä»·æ ¼ = Î£(price Ã— time)
   - TWAP = Î”cumulative / Î”time

3. **æ»‘ç‚¹ä¿æŠ¤**
   - ç”¨æˆ·è®¾ç½®æœ€å°æ¥å—å€¼
   - äº¤æ˜“å‰éªŒè¯

---

## ç¼–ç¨‹é¢˜ 3: å¥—åˆ©æœºä¼šè¯„ä¼°å™¨ - å‚è€ƒç­”æ¡ˆ

### å®Œæ•´å®ç°

```move
module exam::arbitrage_evaluator {
    use std::vector;

    struct DEXInfo has copy, drop {
        dex_address: address,
        price: u64,
        liquidity: u64,
    }

    struct ArbitrageOpportunity has copy, drop {
        buy_dex: address,
        sell_dex: address,
        buy_price: u64,
        sell_price: u64,
        optimal_amount: u64,
        expected_profit: u64,
        net_profit: u64,
        risk_score: u8,
    }

    const MIN_PROFIT_BPS: u64 = 30; // 0.3%

    /// æ‰«æå¥—åˆ©æœºä¼š
    public fun scan_opportunities(
        dexes: vector<DEXInfo>,
        gas_cost: u64,
    ): vector<ArbitrageOpportunity> {
        let opportunities = vector::empty();
        let len = vector::length(&dexes);
        
        let i = 0;
        while (i < len) {
            let j = i + 1;
            while (j < len) {
                let dex_a = *vector::borrow(&dexes, i);
                let dex_b = *vector::borrow(&dexes, j);
                
                // æ£€æŸ¥ä»·æ ¼å·®å¼‚
                if (dex_b.price > dex_a.price) {
                    let profit_bps = ((dex_b.price - dex_a.price) * 10000) / dex_a.price;
                    
                    if (profit_bps > MIN_PROFIT_BPS) {
                        // è®¡ç®—æœ€ä¼˜é‡‘é¢
                        let optimal_amount = calculate_optimal_amount(
                            dex_b.price - dex_a.price,
                            dex_a.liquidity,
                            dex_b.liquidity
                        );
                        
                        // è®¡ç®—åˆ©æ¶¦
                        let (expected_profit, net_profit) = calculate_profit(
                            dex_a.price,
                            dex_b.price,
                            optimal_amount,
                            gas_cost
                        );
                        
                        // è¯„ä¼°é£é™©
                        let min_liquidity = if (dex_a.liquidity < dex_b.liquidity) {
                            dex_a.liquidity
                        } else {
                            dex_b.liquidity
                        };
                        let risk = assess_risk(
                            dex_b.price - dex_a.price,
                            min_liquidity,
                            optimal_amount
                        );
                        
                        if (net_profit > 0) {
                            vector::push_back(&mut opportunities, ArbitrageOpportunity {
                                buy_dex: dex_a.dex_address,
                                sell_dex: dex_b.dex_address,
                                buy_price: dex_a.price,
                                sell_price: dex_b.price,
                                optimal_amount,
                                expected_profit,
                                net_profit,
                                risk_score: risk,
                            });
                        };
                    };
                };
                
                j = j + 1;
            };
            i = i + 1;
        };
        
        opportunities
    }

    /// è®¡ç®—å¥—åˆ©åˆ©æ¶¦
    public fun calculate_profit(
        buy_price: u64,
        sell_price: u64,
        amount: u64,
        gas_cost: u64,
    ): (u64, u64) {
        let gross_profit = if (sell_price > buy_price) {
            (sell_price - buy_price) * amount / 10000
        } else {
            0
        };
        
        let net_profit = if (gross_profit > gas_cost) {
            gross_profit - gas_cost
        } else {
            0
        };
        
        (gross_profit, net_profit)
    }

    /// è®¡ç®—æœ€ä¼˜äº¤æ˜“é‡‘é¢
    public fun calculate_optimal_amount(
        price_diff: u64,
        liquidity_a: u64,
        liquidity_b: u64,
    ): u64 {
        // ç®€åŒ–ç‰ˆæœ¬ï¼šå–è¾ƒå°æµåŠ¨æ€§çš„10%
        let min_liquidity = if (liquidity_a < liquidity_b) {
            liquidity_a
        } else {
            liquidity_b
        };
        
        min_liquidity / 10
    }

    /// è¯„ä¼°æ‰§è¡Œé£é™©
    public fun assess_risk(
        price_diff: u64,
        liquidity: u64,
        optimal_amount: u64,
    ): u8 {
        // è®¡ç®—äº¤æ˜“é‡å æµåŠ¨æ€§çš„æ¯”ä¾‹
        let size_ratio = (optimal_amount * 100) / liquidity;
        
        // åŸºäºè§„æ¨¡è¯„åˆ†
        let size_risk = if (size_ratio < 5) {
            10  // ä½é£é™©
        } else if (size_ratio < 20) {
            50  // ä¸­é£é™©
        } else {
            90  // é«˜é£é™©
        };
        
        // åŸºäºä»·æ ¼å·®è¯„åˆ†ï¼ˆå·®ä»·è¶Šå¤§ï¼Œé£é™©è¶Šé«˜ - å¯èƒ½æ˜¯é¢„è¨€æœºå»¶è¿Ÿï¼‰
        let price_risk = if (price_diff < 100) {
            0
        } else if (price_diff < 500) {
            20
        } else {
            40
        };
        
        // ç»¼åˆé£é™©
        let total_risk = size_risk + price_risk;
        if (total_risk > 100) {
            100
        } else {
            (total_risk as u8)
        }
    }

    /// æ¯”è¾ƒä¸¤ä¸ªæœºä¼š
    public fun compare_opportunities(
        opp1: &ArbitrageOpportunity,
        opp2: &ArbitrageOpportunity,
    ): bool {
        // è®¡ç®—é£é™©è°ƒæ•´åæ”¶ç›Š
        let score1 = (opp1.net_profit * (100 - (opp1.risk_score as u64))) / 100;
        let score2 = (opp2.net_profit * (100 - (opp2.risk_score as u64))) / 100;
        
        score1 > score2
    }
}

// ===== æµ‹è¯• =====

#[test_only]
module exam::arbitrage_evaluator_test {
    use exam::arbitrage_evaluator::{Self, DEXInfo};
    use std::vector;
    
    #[test]
    fun test_opportunity_detection() {
        let dexes = vector::empty();
        
        // DEX A: ä»·æ ¼10.0, æµåŠ¨æ€§100000
        vector::push_back(&mut dexes, DEXInfo {
            dex_address: @0x1,
            price: 10000,
            liquidity: 100000,
        });
        
        // DEX B: ä»·æ ¼10.5, æµåŠ¨æ€§50000
        vector::push_back(&mut dexes, DEXInfo {
            dex_address: @0x2,
            price: 10500,
            liquidity: 50000,
        });
        
        let opportunities = arbitrage_evaluator::scan_opportunities(dexes, 50);
        
        // åº”è¯¥æ£€æµ‹åˆ°1ä¸ªæœºä¼š
        assert!(vector::length(&opportunities) >= 1, 0);
    }
    
    #[test]
    fun test_profit_calculation() {
        // ä¹°å…¥ä»·10.0, å–å‡ºä»·10.5, æ•°é‡1000, gas=50
        let (gross, net) = arbitrage_evaluator::calculate_profit(
            10000,
            10500,
            10000,
            50
        );
        
        // gross = (10500 - 10000) * 10000 / 10000 = 500
        assert!(gross == 500, 1);
        // net = 500 - 50 = 450
        assert!(net == 450, 2);
    }
    
    #[test]
    fun test_risk_assessment() {
        // é«˜æµåŠ¨æ€§ï¼Œå°äº¤æ˜“é‡ = ä½é£é™©
        let risk = arbitrage_evaluator::assess_risk(
            500,
            100000,
            1000,
        );
        
        // 1000 / 100000 = 1% < 5%, åº”è¯¥æ˜¯ä½é£é™©
        assert!(risk < 30, 3);
    }
    
    #[test]
    fun test_optimal_amount() {
        let amount = arbitrage_evaluator::calculate_optimal_amount(
            500,
            100000,
            50000,
        );
        
        // åº”è¯¥æ˜¯è¾ƒå°æµåŠ¨æ€§çš„10%: 50000 / 10 = 5000
        assert!(amount == 5000, 4);
    }
}
```

### å…³é”®ç‚¹è§£æ

1. **æœºä¼šæ‰«æ**
   - åŒé‡å¾ªç¯æ¯”è¾ƒæ‰€æœ‰DEXå¯¹
   - åªä¿ç•™åˆ©æ¶¦ > é˜ˆå€¼çš„æœºä¼š

2. **åˆ©æ¶¦è®¡ç®—**
   - æ¯›åˆ©æ¶¦ = ä»·å·® Ã— æ•°é‡
   - å‡€åˆ©æ¶¦ = æ¯›åˆ©æ¶¦ - gasæˆæœ¬

3. **é£é™©è¯„ä¼°**
   - è€ƒè™‘äº¤æ˜“è§„æ¨¡å æµåŠ¨æ€§æ¯”ä¾‹
   - è€ƒè™‘ä»·æ ¼å·®å¼‚å¤§å°
   - ç»¼åˆè¯„åˆ†0-100

4. **ä¼˜åŒ–ç­–ç•¥**
   - é£é™©è°ƒæ•´åæ”¶ç›Š = åˆ©æ¶¦ Ã— (1 - é£é™©%)
   - é€‰æ‹©æœ€ä¼˜æœºä¼š

---

## ğŸ“Š å­¦ä¹ æ€»ç»“

### å…³é”®æ”¶è·

1. **MEVæ£€æµ‹**
   - æ¨¡å¼è¯†åˆ«å¾ˆé‡è¦
   - éœ€è¦ç»¼åˆå¤šä¸ªæŒ‡æ ‡
   - é¿å…è¯¯æŠ¥

2. **é˜²æŠ¤æœºåˆ¶**
   - æ»‘ç‚¹ä¿æŠ¤æ˜¯åŸºç¡€
   - TWAPé˜²æ­¢ä»·æ ¼æ“çºµ
   - å¤šå±‚é˜²æŠ¤æ›´å®‰å…¨

3. **å¥—åˆ©ç­–ç•¥**
   - æœºä¼šè¯†åˆ«
   - é£é™©è¯„ä¼°
   - åˆ©æ¶¦æœ€å¤§åŒ–

### å¸¸è§é”™è¯¯

1. **æ•´æ•°æº¢å‡º**
   - ä½¿ç”¨u128è¿›è¡Œå¤§æ•°è®¡ç®—
   - åŠæ—¶è½¬æ¢å›u64

2. **é™¤é›¶é”™è¯¯**
   - æ£€æŸ¥åˆ†æ¯ä¸ä¸º0
   - æ£€æŸ¥å‚¨å¤‡é‡å……è¶³

3. **é€»è¾‘é”™è¯¯**
   - è¾¹ç•Œæ¡ä»¶å¤„ç†
   - æ—¶é—´æˆ³æ¯”è¾ƒ

---

**æ­å–œå®ŒæˆDay 32çš„å­¦ä¹ ï¼ç»§ç»­ä¿æŒï¼** ğŸ‰

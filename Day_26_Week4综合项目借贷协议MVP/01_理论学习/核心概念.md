# å€Ÿè´·åè®® MVP - æ ¸å¿ƒæ¦‚å¿µä¸æ¶æ„è®¾è®¡

## ğŸ“š ç›®å½•

1. [é¡¹ç›®æ¦‚è¿°](#é¡¹ç›®æ¦‚è¿°)
2. [ç³»ç»Ÿæ¶æ„](#ç³»ç»Ÿæ¶æ„)
3. [æ ¸å¿ƒæ¨¡å—è®¾è®¡](#æ ¸å¿ƒæ¨¡å—è®¾è®¡)
4. [å…³é”®ç®—æ³•](#å…³é”®ç®—æ³•)
5. [å®‰å…¨è€ƒè™‘](#å®‰å…¨è€ƒè™‘)
6. [æœ€ä½³å®è·µ](#æœ€ä½³å®è·µ)

---

## é¡¹ç›®æ¦‚è¿°

### ä»€ä¹ˆæ˜¯å€Ÿè´·åè®®ï¼Ÿ

å€Ÿè´·åè®®æ˜¯ DeFi ç”Ÿæ€ä¸­æœ€æ ¸å¿ƒçš„ç»„ä»¶ä¹‹ä¸€ï¼Œå®ƒå…è®¸ç”¨æˆ·ï¼š
- **å­˜æ¬¾**ï¼šå°†é—²ç½®èµ„äº§å­˜å…¥åè®®èµšå–åˆ©æ¯
- **å€Ÿæ¬¾**ï¼šä½¿ç”¨æŠµæŠ¼å“å€Ÿå‡ºå…¶ä»–èµ„äº§
- **æ¸…ç®—**ï¼šå½“æŠµæŠ¼å“ä»·å€¼ä¸è¶³æ—¶ï¼Œåè®®è‡ªåŠ¨æ¸…ç®—

### AptosLend MVP ç‰¹æ€§

æˆ‘ä»¬çš„ MVPï¼ˆæœ€å°å¯è¡Œäº§å“ï¼‰å°†å®ç°ï¼š

âœ… **æ ¸å¿ƒåŠŸèƒ½**
- å­˜æ¬¾å’Œå–æ¬¾
- æŠµæŠ¼å€Ÿæ¬¾
- åˆ©æ¯è®¡ç®—
- è¿˜æ¬¾åŠŸèƒ½
- è‡ªåŠ¨æ¸…ç®—

âœ… **æ”¯æŒçš„èµ„äº§**
- APTï¼ˆåŸç”Ÿä»£å¸ï¼‰
- USDCï¼ˆç¨³å®šå¸æ¨¡æ‹Ÿï¼‰
- ä¸€ä¸ª NFT Collectionï¼ˆé«˜çº§æŠµæŠ¼å“ï¼‰

âœ… **é£é™©ç®¡ç†**
- åŠ¨æ€åˆ©ç‡æ¨¡å‹
- å¥åº·å› å­ç›‘æ§
- æ¸…ç®—æ¿€åŠ±æœºåˆ¶

---

## ç³»ç»Ÿæ¶æ„

### æ•´ä½“æ¶æ„å›¾

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                         ç”¨æˆ·å±‚                              â”‚
â”‚  (å­˜æ¬¾äººã€å€Ÿæ¬¾äººã€æ¸…ç®—äºº)                                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                     â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    æ ¸å¿ƒå€Ÿè´·æ±                                â”‚
â”‚                  (lending_pool.move)                        â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”            â”‚
â”‚  â”‚ å­˜æ¬¾ç®¡ç†     â”‚ å€Ÿæ¬¾ç®¡ç†     â”‚ æ¸…ç®—ç®¡ç†     â”‚            â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜            â”‚
â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
     â”‚        â”‚        â”‚        â”‚        â”‚        â”‚
â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â” â”Œâ–¼â”€â”€â”€â”€â”€â” â”Œâ–¼â”€â”€â”€â”€â”€â”€â” â”Œâ–¼â”€â”€â”€â”€â”€â”€â” â”Œâ–¼â”€â”€â”€â”€â”€â” â”Œâ–¼â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ aToken  â”‚ â”‚ åˆ©ç‡ â”‚ â”‚ æŠµæŠ¼å“â”‚ â”‚ å¥åº·  â”‚ â”‚ ä»·æ ¼ â”‚ â”‚ äº‹ä»¶   â”‚
â”‚ æ¨¡å—    â”‚ â”‚ æ¨¡å‹ â”‚ â”‚ ç®¡ç†  â”‚ â”‚ å› å­  â”‚ â”‚ é¢„è¨€ â”‚ â”‚ ç³»ç»Ÿ   â”‚
â”‚         â”‚ â”‚      â”‚ â”‚       â”‚ â”‚       â”‚ â”‚ æœº   â”‚ â”‚        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### æ¨¡å—èŒè´£

#### 1. **lending_pool.move** - æ ¸å¿ƒå€Ÿè´·æ± 
- ç®¡ç†æ‰€æœ‰èµ„äº§çš„å­˜æ¬¾å’Œå€Ÿæ¬¾
- åè°ƒå„ä¸ªå­æ¨¡å—
- å¤„ç†ç”¨æˆ·äº¤äº’

#### 2. **atoken.move** - è®¡æ¯å‡­è¯
- ä»£è¡¨ç”¨æˆ·çš„å­˜æ¬¾ä»½é¢
- è‡ªåŠ¨ç´¯ç§¯åˆ©æ¯
- å¯è½¬è®©å’Œèµå›

#### 3. **interest_rate_model.move** - åˆ©ç‡æ¨¡å‹
- æ ¹æ®èµ„é‡‘ä½¿ç”¨ç‡è®¡ç®—åˆ©ç‡
- æ”¯æŒçº¿æ€§å’Œéçº¿æ€§æ¨¡å‹
- åŠ¨æ€è°ƒæ•´

#### 4. **collateral_manager.move** - æŠµæŠ¼å“ç®¡ç†
- ç®¡ç†ç”¨æˆ·çš„æŠµæŠ¼å“
- æ”¯æŒå¤šç§èµ„äº§ç±»å‹
- è®¡ç®—æŠµæŠ¼å“ä»·å€¼

#### 5. **health_factor.move** - å¥åº·å› å­
- è®¡ç®—è´¦æˆ·å¥åº·åº¦
- ç›‘æ§æ¸…ç®—æ¡ä»¶
- é£é™©è¯„ä¼°

#### 6. **liquidation_logic.move** - æ¸…ç®—é€»è¾‘
- æ‰§è¡Œæ¸…ç®—æ“ä½œ
- è®¡ç®—æ¸…ç®—å¥–åŠ±
- åˆ†é…æ¸…ç®—æ”¶ç›Š

#### 7. **price_oracle.move** - ä»·æ ¼é¢„è¨€æœº
- æä¾›èµ„äº§ä»·æ ¼
- ä»·æ ¼èšåˆ
- å¼‚å¸¸å¤„ç†

---

## æ ¸å¿ƒæ¨¡å—è®¾è®¡

### 1. å€Ÿè´·æ± ï¼ˆLending Poolï¼‰

#### æ•°æ®ç»“æ„

```move
struct LendingPool has key {
    // å‚¨å¤‡é‡‘æ˜ å°„ï¼šèµ„äº§ç±»å‹ -> å‚¨å¤‡é‡‘ä¿¡æ¯
    reserves: Table<String, Reserve>,
    // ç”¨æˆ·æ•°æ®ï¼šåœ°å€ -> ç”¨æˆ·ä¿¡æ¯
    user_data: Table<address, UserAccount>,
    // æ”¯æŒçš„èµ„äº§åˆ—è¡¨
    supported_assets: vector<String>,
    // ç®¡ç†å‘˜åœ°å€
    admin: address,
}

struct Reserve has store {
    // èµ„äº§ç¬¦å·ï¼ˆå¦‚ "APT", "USDC"ï¼‰
    symbol: String,
    // æ€»å­˜æ¬¾é‡
    total_deposits: u64,
    // æ€»å€Ÿæ¬¾é‡
    total_borrows: u64,
    // å¯ç”¨æµåŠ¨æ€§
    available_liquidity: u64,
    // aToken åœ°å€
    atoken_address: address,
    // åˆ©ç‡æ¨¡å‹å‚æ•°
    interest_rate_config: InterestRateConfig,
    // æŠµæŠ¼ç‡ï¼ˆLoan-to-Valueï¼‰
    ltv: u64,  // ä»¥åŸºç‚¹è¡¨ç¤ºï¼Œ10000 = 100%
    // æ¸…ç®—é˜ˆå€¼
    liquidation_threshold: u64,
    // æ¸…ç®—å¥–åŠ±
    liquidation_bonus: u64,
    // å‚¨å¤‡é‡‘å› å­ï¼ˆåè®®æ”¶ç›Šï¼‰
    reserve_factor: u64,
    // æœ€åæ›´æ–°æ—¶é—´æˆ³
    last_update_timestamp: u64,
    // ç´¯ç§¯çš„æµåŠ¨æ€§æŒ‡æ•°
    liquidity_index: u128,
    // ç´¯ç§¯çš„å€Ÿæ¬¾æŒ‡æ•°
    borrow_index: u128,
}

struct UserAccount has store {
    // ç”¨æˆ·æŠµæŠ¼å“ï¼šèµ„äº§ç±»å‹ -> æ•°é‡
    collateral: SimpleMap<String, u64>,
    // ç”¨æˆ·å€Ÿæ¬¾ï¼šèµ„äº§ç±»å‹ -> å€Ÿæ¬¾ä¿¡æ¯
    borrows: SimpleMap<String, BorrowInfo>,
    // å¥åº·å› å­
    health_factor: u128,
}

struct BorrowInfo has store, copy, drop {
    // å€Ÿæ¬¾æœ¬é‡‘
    principal: u64,
    // å€Ÿæ¬¾æ—¶çš„æŒ‡æ•°
    borrow_index: u128,
    // å€Ÿæ¬¾æ—¶é—´æˆ³
    timestamp: u64,
}
```

#### æ ¸å¿ƒå‡½æ•°

```move
// å­˜æ¬¾
public entry fun deposit<CoinType>(
    user: &signer,
    amount: u64
) acquires LendingPool

// å–æ¬¾
public entry fun withdraw<CoinType>(
    user: &signer,
    amount: u64
) acquires LendingPool

// å€Ÿæ¬¾
public entry fun borrow<CoinType>(
    user: &signer,
    amount: u64
) acquires LendingPool

// è¿˜æ¬¾
public entry fun repay<CoinType>(
    user: &signer,
    amount: u64
) acquires LendingPool

// æ¸…ç®—
public entry fun liquidate(
    liquidator: &signer,
    borrower: address,
    debt_asset: String,
    collateral_asset: String,
    debt_to_cover: u64
) acquires LendingPool
```

### 2. aTokenï¼ˆè®¡æ¯å‡­è¯ï¼‰

#### è®¾è®¡ç†å¿µ

aToken æ˜¯ç”¨æˆ·å­˜æ¬¾çš„å‡­è¯ï¼Œå®ƒçš„ä»·å€¼éšæ—¶é—´å¢é•¿ï¼ˆé€šè¿‡åˆ©æ¯ç´¯ç§¯ï¼‰ã€‚

**å…³é”®ç‰¹æ€§**ï¼š
- 1:1 é“¸é€ ï¼ˆå­˜å…¥ 1 APT è·å¾— 1 aAPTï¼‰
- ä»·å€¼å¢é•¿é€šè¿‡ç´¢å¼•ï¼ˆindexï¼‰å®ç°
- å¯è½¬è®©
- èµå›æ—¶æŒ‰ç´¢å¼•è®¡ç®—å®é™…ä»·å€¼

#### æ•°æ®ç»“æ„

```move
struct AToken<phantom CoinType> has key {
    // æ€»ä¾›åº”é‡
    total_supply: u64,
    // ç”¨æˆ·ä½™é¢ï¼šåœ°å€ -> ä»½é¢
    balances: Table<address, u64>,
    // åº•å±‚èµ„äº§ç±»å‹
    underlying_asset: String,
    // å€Ÿè´·æ± åœ°å€
    pool_address: address,
}
```

#### ä»·å€¼è®¡ç®—

```move
// ç”¨æˆ·å®é™…ä½™é¢ = ç”¨æˆ·ä»½é¢ Ã— å½“å‰ç´¢å¼• / åˆå§‹ç´¢å¼•
actual_balance = (user_shares * current_liquidity_index) / RAY

// RAY = 10^27ï¼ˆé«˜ç²¾åº¦å¸¸é‡ï¼‰
```

### 3. åˆ©ç‡æ¨¡å‹

#### çº¿æ€§åˆ©ç‡æ¨¡å‹

```
å‚æ•°ï¼š
- base_rate: åŸºç¡€åˆ©ç‡ï¼ˆå¦‚ 0%ï¼‰
- slope1: ç¬¬ä¸€æ®µæ–œç‡ï¼ˆU â‰¤ U_optimalï¼‰
- slope2: ç¬¬äºŒæ®µæ–œç‡ï¼ˆU > U_optimalï¼‰
- optimal_utilization: æœ€ä¼˜ä½¿ç”¨ç‡ï¼ˆå¦‚ 80%ï¼‰

è®¡ç®—å…¬å¼ï¼š
å½“ U â‰¤ U_optimal:
  Borrow_Rate = base_rate + (U / U_optimal) Ã— slope1

å½“ U > U_optimal:
  Borrow_Rate = base_rate + slope1 + 
                ((U - U_optimal) / (1 - U_optimal)) Ã— slope2

Supply_Rate = Borrow_Rate Ã— U Ã— (1 - reserve_factor)

å…¶ä¸­ï¼š
U = Utilization_Rate = Total_Borrows / Total_Liquidity
```

#### ç¤ºä¾‹å‚æ•°

```move
// APT åˆ©ç‡é…ç½®
base_rate: 0%
slope1: 4%
slope2: 75%
optimal_utilization: 80%

// ç¤ºä¾‹è®¡ç®—ï¼š
U = 50% â†’ Borrow_Rate = 0% + (0.5/0.8) Ã— 4% = 2.5%
U = 90% â†’ Borrow_Rate = 0% + 4% + (0.1/0.2) Ã— 75% = 41.5%
```

#### æ•°æ®ç»“æ„

```move
struct InterestRateConfig has store, copy, drop {
    // åŸºç¡€åˆ©ç‡ï¼ˆåŸºç‚¹ï¼‰
    base_rate: u64,
    // ç¬¬ä¸€æ®µæ–œç‡
    slope1: u64,
    // ç¬¬äºŒæ®µæ–œç‡
    slope2: u64,
    // æœ€ä¼˜ä½¿ç”¨ç‡
    optimal_utilization: u64,
}
```

### 4. å¥åº·å› å­

#### å®šä¹‰

å¥åº·å› å­è¡¡é‡å€Ÿæ¬¾è´¦æˆ·çš„å¥åº·ç¨‹åº¦ï¼š

```
Health_Factor = (Total_Collateral_Value Ã— Liquidation_Threshold) / Total_Borrowed_Value

å…¶ä¸­ï¼š
- Total_Collateral_Value: æ‰€æœ‰æŠµæŠ¼å“çš„æ€»ä»·å€¼
- Liquidation_Threshold: æ¸…ç®—é˜ˆå€¼ï¼ˆå¦‚ 85%ï¼‰
- Total_Borrowed_Value: æ‰€æœ‰å€Ÿæ¬¾çš„æ€»ä»·å€¼
```

#### çŠ¶æ€åˆ¤æ–­

```
HF > 1.5  â†’ éå¸¸å®‰å…¨ï¼ˆç»¿è‰²ï¼‰
1.2 < HF â‰¤ 1.5 â†’ å®‰å…¨ï¼ˆé»„è‰²ï¼‰
1.0 < HF â‰¤ 1.2 â†’ é£é™©ï¼ˆæ©™è‰²ï¼‰
HF â‰¤ 1.0  â†’ å¯æ¸…ç®—ï¼ˆçº¢è‰²ï¼‰
```

#### è®¡ç®—ç¤ºä¾‹

```
ç”¨æˆ·æŠµæŠ¼å“ï¼š
- 10 APT Ã— $10 = $100
- Liquidation Threshold = 85%

ç”¨æˆ·å€Ÿæ¬¾ï¼š
- 70 USDC Ã— $1 = $70

Health Factor = ($100 Ã— 0.85) / $70 = $85 / $70 = 1.214

çŠ¶æ€ï¼šå®‰å…¨ï¼ˆå¯ä»¥ç»§ç»­å€Ÿæ¬¾ï¼‰
```

#### å®ç°

```move
public fun calculate_health_factor(
    user_address: address
): u128 acquires LendingPool {
    let pool = borrow_global<LendingPool>(@lending_protocol);
    let user = simple_map::borrow(&pool.user_data, &user_address);
    
    let total_collateral_value = 0u128;
    let total_borrow_value = 0u128;
    
    // è®¡ç®—æŠµæŠ¼å“æ€»ä»·å€¼ï¼ˆåŠ æƒï¼‰
    let collateral_iter = simple_map::keys(&user.collateral);
    vector::for_each_ref(&collateral_iter, |asset| {
        let amount = *simple_map::borrow(&user.collateral, asset);
        let price = get_asset_price(asset);
        let reserve = table::borrow(&pool.reserves, asset);
        
        total_collateral_value = total_collateral_value + 
            (amount as u128) * (price as u128) * 
            (reserve.liquidation_threshold as u128) / 10000;
    });
    
    // è®¡ç®—å€Ÿæ¬¾æ€»ä»·å€¼
    let borrow_iter = simple_map::keys(&user.borrows);
    vector::for_each_ref(&borrow_iter, |asset| {
        let borrow_info = simple_map::borrow(&user.borrows, asset);
        let current_debt = calculate_current_debt(borrow_info, asset);
        let price = get_asset_price(asset);
        
        total_borrow_value = total_borrow_value + 
            (current_debt as u128) * (price as u128);
    });
    
    // å¦‚æœæ²¡æœ‰å€Ÿæ¬¾ï¼Œè¿”å›æœ€å¤§å€¼
    if (total_borrow_value == 0) {
        return MAX_HEALTH_FACTOR;
    };
    
    // è®¡ç®—å¥åº·å› å­ï¼ˆä½¿ç”¨é«˜ç²¾åº¦ï¼‰
    (total_collateral_value * HEALTH_FACTOR_PRECISION) / total_borrow_value
}
```

### 5. æ¸…ç®—æœºåˆ¶

#### æ¸…ç®—æ¡ä»¶

```
æ¸…ç®—æ¡ä»¶ï¼šHealth_Factor < 1.0
```

#### æ¸…ç®—æµç¨‹

```
1. æ¸…ç®—äººå‘èµ·æ¸…ç®—
   â†“
2. éªŒè¯å¥åº·å› å­ < 1.0
   â†“
3. è®¡ç®—å¯æ¸…ç®—çš„å€ºåŠ¡ï¼ˆé€šå¸¸æœ€å¤š 50%ï¼‰
   â†“
4. æ¸…ç®—äººå¿è¿˜å€ºåŠ¡
   â†“
5. æ¸…ç®—äººè·å¾—æŠµæŠ¼å“ + æ¸…ç®—å¥–åŠ±
   â†“
6. æ›´æ–°å€Ÿæ¬¾äººè´¦æˆ·
   â†“
7. å‘å°„æ¸…ç®—äº‹ä»¶
```

#### æ¸…ç®—å¥–åŠ±è®¡ç®—

```
æ¸…ç®—äººå¿è¿˜ï¼š100 USDC å€ºåŠ¡
æ¸…ç®—å¥–åŠ±ï¼š5%
æŠµæŠ¼å“ä»·æ ¼ï¼š10 APT = $100

æ¸…ç®—äººè·å¾—çš„æŠµæŠ¼å“ä»·å€¼ = $100 Ã— (1 + 5%) = $105
æ¸…ç®—äººè·å¾—çš„ APT = $105 / $10 = 10.5 APT

æ”¶ç›Šï¼š10.5 APT - 10 APT = 0.5 APT ($5)
```

#### å®ç°

```move
public entry fun liquidate(
    liquidator: &signer,
    borrower: address,
    debt_asset: String,
    collateral_asset: String,
    debt_to_cover: u64
) acquires LendingPool {
    let pool = borrow_global_mut<LendingPool>(@lending_protocol);
    
    // 1. éªŒè¯å¥åº·å› å­
    let health_factor = calculate_health_factor(borrower);
    assert!(health_factor < HEALTH_FACTOR_LIQUIDATION_THRESHOLD, E_HEALTH_FACTOR_OK);
    
    // 2. è®¡ç®—æœ€å¤§å¯æ¸…ç®—å€ºåŠ¡
    let user = simple_map::borrow_mut(&mut pool.user_data, &borrower);
    let borrow_info = simple_map::borrow(&user.borrows, &debt_asset);
    let total_debt = calculate_current_debt(borrow_info, &debt_asset);
    let max_liquidatable = total_debt / 2; // æœ€å¤šæ¸…ç®— 50%
    
    assert!(debt_to_cover <= max_liquidatable, E_LIQUIDATION_TOO_MUCH);
    
    // 3. è®¡ç®—éœ€è¦çš„æŠµæŠ¼å“
    let debt_price = get_asset_price(&debt_asset);
    let collateral_price = get_asset_price(&collateral_asset);
    let reserve = table::borrow(&pool.reserves, &collateral_asset);
    
    let collateral_needed = (debt_to_cover as u128) * 
                           (debt_price as u128) * 
                           (10000 + reserve.liquidation_bonus) / 
                           (collateral_price as u128) / 10000;
    
    // 4. è½¬ç§»å€ºåŠ¡èµ„äº§ï¼ˆä»æ¸…ç®—äººåˆ°åè®®ï¼‰
    let debt_coin = coin::withdraw<DebtCoinType>(liquidator, debt_to_cover);
    coin::merge(&mut pool.reserves[debt_asset].liquidity, debt_coin);
    
    // 5. è½¬ç§»æŠµæŠ¼å“ï¼ˆä»å€Ÿæ¬¾äººåˆ°æ¸…ç®—äººï¼‰
    let user_collateral = simple_map::borrow_mut(&mut user.collateral, &collateral_asset);
    assert!(*user_collateral >= (collateral_needed as u64), E_INSUFFICIENT_COLLATERAL);
    
    *user_collateral = *user_collateral - (collateral_needed as u64);
    let collateral_coin = coin::extract(&mut pool.reserves[collateral_asset].liquidity, 
                                       (collateral_needed as u64));
    coin::deposit(signer::address_of(liquidator), collateral_coin);
    
    // 6. æ›´æ–°å€Ÿæ¬¾
    let borrow_info_mut = simple_map::borrow_mut(&mut user.borrows, &debt_asset);
    borrow_info_mut.principal = borrow_info_mut.principal - debt_to_cover;
    
    // 7. é‡æ–°è®¡ç®—å¥åº·å› å­
    user.health_factor = calculate_health_factor(borrower);
    
    // 8. å‘å°„äº‹ä»¶
    event::emit(LiquidationEvent {
        liquidator: signer::address_of(liquidator),
        borrower,
        debt_asset,
        debt_covered: debt_to_cover,
        collateral_asset,
        collateral_liquidated: (collateral_needed as u64),
        timestamp: timestamp::now_seconds(),
    });
}
```

---

## å…³é”®ç®—æ³•

### 1. åˆ©æ¯ç´¯ç§¯ç®—æ³•

#### çº¿æ€§ç´¯ç§¯

```move
// è®¡ç®—ç´¯ç§¯ç´¢å¼•
public fun calculate_linear_index(
    current_index: u128,
    rate: u64,
    time_delta: u64
): u128 {
    // index_new = index_old Ã— (1 + rate Ã— time)
    let rate_per_second = (rate as u128) / SECONDS_PER_YEAR;
    let accumulation = RAY + rate_per_second * (time_delta as u128);
    (current_index * accumulation) / RAY
}
```

#### å¤åˆ©ç´¯ç§¯

```move
// ä½¿ç”¨æ³°å‹’çº§æ•°è¿‘ä¼¼ e^(rt)
public fun calculate_compound_index(
    current_index: u128,
    rate: u64,
    time_delta: u64
): u128 {
    let rate_per_second = (rate as u128) / SECONDS_PER_YEAR;
    let exponent = rate_per_second * (time_delta as u128);
    
    // e^x â‰ˆ 1 + x + xÂ²/2 + xÂ³/6 + ...
    let term1 = RAY;
    let term2 = exponent;
    let term3 = (exponent * exponent) / (2 * RAY);
    let term4 = (exponent * exponent * exponent) / (6 * RAY * RAY);
    
    let exp_value = term1 + term2 + term3 + term4;
    (current_index * exp_value) / RAY
}
```

### 2. èµ„é‡‘ä½¿ç”¨ç‡è®¡ç®—

```move
public fun calculate_utilization_rate(
    total_borrows: u64,
    available_liquidity: u64
): u64 {
    let total_liquidity = total_borrows + available_liquidity;
    
    if (total_liquidity == 0) {
        return 0;
    };
    
    // U = Total_Borrows / Total_Liquidity
    ((total_borrows as u128) * 10000 / (total_liquidity as u128)) as u64
}
```

### 3. å€Ÿæ¬¾èƒ½åŠ›è®¡ç®—

```move
public fun calculate_borrowing_power(
    user_address: address
): u64 acquires LendingPool {
    let pool = borrow_global<LendingPool>(@lending_protocol);
    let user = simple_map::borrow(&pool.user_data, &user_address);
    
    let total_collateral_value = 0u128;
    
    // è®¡ç®—åŠ æƒæŠµæŠ¼å“ä»·å€¼
    let collateral_iter = simple_map::keys(&user.collateral);
    vector::for_each_ref(&collateral_iter, |asset| {
        let amount = *simple_map::borrow(&user.collateral, asset);
        let price = get_asset_price(asset);
        let reserve = table::borrow(&pool.reserves, asset);
        
        total_collateral_value = total_collateral_value + 
            (amount as u128) * (price as u128) * (reserve.ltv as u128) / 10000;
    });
    
    // å‡å»å·²å€Ÿæ¬¾ä»·å€¼
    let total_borrow_value = 0u128;
    let borrow_iter = simple_map::keys(&user.borrows);
    vector::for_each_ref(&borrow_iter, |asset| {
        let borrow_info = simple_map::borrow(&user.borrows, asset);
        let current_debt = calculate_current_debt(borrow_info, asset);
        let price = get_asset_price(asset);
        
        total_borrow_value = total_borrow_value + 
            (current_debt as u128) * (price as u128);
    });
    
    if (total_collateral_value > total_borrow_value) {
        ((total_collateral_value - total_borrow_value) as u64)
    } else {
        0
    }
}
```

---

## å®‰å…¨è€ƒè™‘

### 1. é‡å…¥æ”»å‡»é˜²æŠ¤

```move
// ä½¿ç”¨ Check-Effects-Interactions æ¨¡å¼

// âŒ é”™è¯¯ï¼šå…ˆè½¬è´¦ï¼Œåæ›´æ–°çŠ¶æ€
public entry fun withdraw_bad(user: &signer, amount: u64) {
    coin::transfer<APT>(user, signer::address_of(user), amount);
    update_user_balance(user, amount); // çŠ¶æ€æ›´æ–°åœ¨è½¬è´¦å
}

// âœ… æ­£ç¡®ï¼šå…ˆæ›´æ–°çŠ¶æ€ï¼Œåè½¬è´¦
public entry fun withdraw_good(user: &signer, amount: u64) {
    update_user_balance(user, amount); // çŠ¶æ€æ›´æ–°åœ¨è½¬è´¦å‰
    coin::transfer<APT>(user, signer::address_of(user), amount);
}
```

### 2. æº¢å‡ºä¿æŠ¤

```move
// ä½¿ç”¨å®‰å…¨çš„æ•°å­¦è¿ç®—

// âœ… æ£€æŸ¥æº¢å‡º
public fun safe_add(a: u64, b: u64): u64 {
    let result = (a as u128) + (b as u128);
    assert!(result <= (MAX_U64 as u128), E_OVERFLOW);
    (result as u64)
}

public fun safe_mul(a: u64, b: u64): u64 {
    let result = (a as u128) * (b as u128);
    assert!(result <= (MAX_U64 as u128), E_OVERFLOW);
    (result as u64)
}
```

### 3. ä»·æ ¼æ“çºµé˜²æŠ¤

```move
// ä½¿ç”¨ TWAPï¼ˆæ—¶é—´åŠ æƒå¹³å‡ä»·æ ¼ï¼‰

struct PriceData has store {
    price: u64,
    timestamp: u64,
    cumulative_price: u128,
}

public fun get_twap(
    asset: String,
    period: u64
): u64 {
    let current_price_data = get_price_data(&asset);
    let historical_price_data = get_historical_price_data(&asset, period);
    
    let price_diff = current_price_data.cumulative_price - 
                     historical_price_data.cumulative_price;
    let time_diff = current_price_data.timestamp - 
                    historical_price_data.timestamp;
    
    ((price_diff / (time_diff as u128)) as u64)
}
```

### 4. æƒé™æ§åˆ¶

```move
// ä¸¥æ ¼çš„è®¿é—®æ§åˆ¶

public entry fun set_reserve_factor(
    admin: &signer,
    asset: String,
    new_factor: u64
) acquires LendingPool {
    let pool = borrow_global_mut<LendingPool>(@lending_protocol);
    
    // éªŒè¯ç®¡ç†å‘˜æƒé™
    assert!(signer::address_of(admin) == pool.admin, E_NOT_AUTHORIZED);
    
    // éªŒè¯å‚æ•°èŒƒå›´
    assert!(new_factor <= 10000, E_INVALID_PARAMETER);
    
    let reserve = table::borrow_mut(&mut pool.reserves, &asset);
    reserve.reserve_factor = new_factor;
}
```

### 5. é—ªç”µè´·é˜²æŠ¤

```move
// é˜²æ­¢é—ªç”µè´·æ”»å‡»

struct FlashLoanGuard has key {
    // è®°å½•å½“å‰å—çš„å€Ÿæ¬¾
    current_block_borrows: Table<address, u64>,
    last_block_height: u64,
}

public fun check_flash_loan_protection(
    user: address,
    amount: u64
) acquires FlashLoanGuard {
    let guard = borrow_global_mut<FlashLoanGuard>(@lending_protocol);
    let current_block = block::get_current_block_height();
    
    // æ–°åŒºå—ï¼Œé‡ç½®è®¡æ•°
    if (current_block > guard.last_block_height) {
        table::clear(&mut guard.current_block_borrows);
        guard.last_block_height = current_block;
    };
    
    // æ£€æŸ¥å•ä¸ªå—å†…çš„å€Ÿæ¬¾é™åˆ¶
    let current_borrow = if (table::contains(&guard.current_block_borrows, &user)) {
        *table::borrow(&guard.current_block_borrows, &user)
    } else {
        0
    };
    
    let new_borrow = current_borrow + amount;
    assert!(new_borrow <= MAX_SINGLE_BLOCK_BORROW, E_FLASH_LOAN_DETECTED);
    
    table::upsert(&mut guard.current_block_borrows, user, new_borrow);
}
```

---

## æœ€ä½³å®è·µ

### 1. ä»£ç ç»„ç»‡

```move
// æ¸…æ™°çš„æ¨¡å—åˆ†ç¦»

module lending_protocol::lending_pool {
    // å…¬å…±æ¥å£
    public entry fun deposit() { }
    public entry fun withdraw() { }
    public entry fun borrow() { }
    public entry fun repay() { }
    
    // å†…éƒ¨å‡½æ•°
    fun update_interest_rates() { }
    fun update_user_balance() { }
    
    // è§†å›¾å‡½æ•°
    public fun get_user_deposits(): u64 { }
    public fun get_user_borrows(): u64 { }
}

module lending_protocol::interest_rate {
    // ä¸“æ³¨äºåˆ©ç‡è®¡ç®—
    public fun calculate_borrow_rate() { }
    public fun calculate_supply_rate() { }
}
```

### 2. äº‹ä»¶è®¾è®¡

```move
// è¯¦ç»†çš„äº‹ä»¶è®°å½•

struct DepositEvent has drop, store {
    user: address,
    asset: String,
    amount: u64,
    atoken_minted: u64,
    timestamp: u64,
}

struct BorrowEvent has drop, store {
    user: address,
    asset: String,
    amount: u64,
    borrow_rate: u64,
    health_factor_before: u128,
    health_factor_after: u128,
    timestamp: u64,
}

struct LiquidationEvent has drop, store {
    liquidator: address,
    borrower: address,
    debt_asset: String,
    debt_covered: u64,
    collateral_asset: String,
    collateral_liquidated: u64,
    liquidation_bonus: u64,
    timestamp: u64,
}
```

### 3. é”™è¯¯å¤„ç†

```move
// æ¸…æ™°çš„é”™è¯¯å®šä¹‰

const E_NOT_AUTHORIZED: u64 = 1;
const E_INSUFFICIENT_BALANCE: u64 = 2;
const E_INSUFFICIENT_COLLATERAL: u64 = 3;
const E_HEALTH_FACTOR_TOO_LOW: u64 = 4;
const E_HEALTH_FACTOR_OK: u64 = 5;
const E_ASSET_NOT_SUPPORTED: u64 = 6;
const E_AMOUNT_ZERO: u64 = 7;
const E_POOL_NOT_INITIALIZED: u64 = 8;
const E_LIQUIDATION_TOO_MUCH: u64 = 9;
const E_INVALID_PARAMETER: u64 = 10;

// ä½¿ç”¨æ¸…æ™°çš„é”™è¯¯æ¶ˆæ¯
assert!(amount > 0, E_AMOUNT_ZERO);
assert!(health_factor >= HEALTH_FACTOR_LIQUIDATION_THRESHOLD, E_HEALTH_FACTOR_TOO_LOW);
```

### 4. æµ‹è¯•è¦†ç›–

```move
#[test]
fun test_deposit_and_withdraw() {
    // æµ‹è¯•æ­£å¸¸å­˜å–æ¬¾æµç¨‹
}

#[test]
fun test_borrow_and_repay() {
    // æµ‹è¯•æ­£å¸¸å€Ÿè¿˜æ¬¾æµç¨‹
}

#[test]
#[expected_failure(abort_code = E_HEALTH_FACTOR_TOO_LOW)]
fun test_borrow_exceeds_limit() {
    // æµ‹è¯•è¶…é¢å€Ÿæ¬¾å¤±è´¥
}

#[test]
fun test_liquidation() {
    // æµ‹è¯•æ¸…ç®—æµç¨‹
}

#[test]
fun test_interest_accrual() {
    // æµ‹è¯•åˆ©æ¯ç´¯ç§¯
}
```

### 5. Gas ä¼˜åŒ–

```move
// æ‰¹é‡æ“ä½œä¼˜åŒ–

// âŒ ä½æ•ˆï¼šå¤šæ¬¡è°ƒç”¨
public entry fun deposit_multiple_bad(
    user: &signer,
    assets: vector<String>,
    amounts: vector<u64>
) {
    let i = 0;
    while (i < vector::length(&assets)) {
        deposit(user, *vector::borrow(&assets, i), *vector::borrow(&amounts, i));
        i = i + 1;
    };
}

// âœ… é«˜æ•ˆï¼šæ‰¹é‡å¤„ç†
public entry fun deposit_multiple_good(
    user: &signer,
    assets: vector<String>,
    amounts: vector<u64>
) acquires LendingPool {
    let pool = borrow_global_mut<LendingPool>(@lending_protocol);
    
    // ä¸€æ¬¡æ€§æ›´æ–°æ‰€æœ‰èµ„äº§
    let i = 0;
    while (i < vector::length(&assets)) {
        let asset = vector::borrow(&assets, i);
        let amount = *vector::borrow(&amounts, i);
        
        // å†…éƒ¨æ›´æ–°ï¼Œä¸å‘èµ·å¤šæ¬¡äº¤æ˜“
        internal_deposit(pool, user, asset, amount);
        i = i + 1;
    };
    
    // ç»Ÿä¸€å‘å°„äº‹ä»¶
    event::emit(BatchDepositEvent { ... });
}
```

---

## æ€»ç»“

æœ¬é¡¹ç›®æ¶µç›–äº†å€Ÿè´·åè®®çš„æ ¸å¿ƒæ¦‚å¿µå’Œå®ç°ï¼š

âœ… **å®Œæ•´çš„ç³»ç»Ÿæ¶æ„**
- æ¨¡å—åŒ–è®¾è®¡
- æ¸…æ™°çš„èŒè´£åˆ†ç¦»
- å¯æ‰©å±•çš„ç»“æ„

âœ… **æ ¸å¿ƒåŠŸèƒ½å®ç°**
- å­˜æ¬¾å’Œå€Ÿæ¬¾
- åˆ©æ¯è®¡ç®—
- å¥åº·å› å­ç›‘æ§
- è‡ªåŠ¨æ¸…ç®—

âœ… **å®‰å…¨ä¿éšœ**
- é‡å…¥ä¿æŠ¤
- æº¢å‡ºæ£€æŸ¥
- æƒé™æ§åˆ¶
- ä»·æ ¼æ“çºµé˜²æŠ¤

âœ… **æœ€ä½³å®è·µ**
- æ¸…æ™°çš„ä»£ç ç»„ç»‡
- å®Œå–„çš„äº‹ä»¶ç³»ç»Ÿ
- è¯¦ç»†çš„é”™è¯¯å¤„ç†
- å……åˆ†çš„æµ‹è¯•è¦†ç›–

é€šè¿‡è¿™ä¸ªé¡¹ç›®ï¼Œä½ å°†æŒæ¡æ„å»ºç”Ÿäº§çº§ DeFi åè®®çš„å®Œæ•´æŠ€èƒ½ï¼

---

## ä¸‹ä¸€æ­¥

1. é˜…è¯» `ä»£ç ç¤ºä¾‹.move` æŸ¥çœ‹å®Œæ•´å®ç°
2. å®Œæˆ `02_å®è·µä»»åŠ¡` ä¸­çš„ç¼–ç ä»»åŠ¡
3. è¿è¡Œæµ‹è¯•éªŒè¯åŠŸèƒ½
4. éƒ¨ç½²åˆ°æµ‹è¯•ç½‘
5. å‚åŠ æ¯æ—¥è€ƒè¯•å·©å›ºçŸ¥è¯†

**å¼€å§‹åŠ¨æ‰‹å®ç°å§ï¼ğŸ’ª**

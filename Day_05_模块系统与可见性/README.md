# Day 05: 模块系统与可见性

> 掌握 Move 语言的模块组织和访问控制机制

---

## 📚 学习概览

### 本日目标
- 理解 Move 模块系统的设计理念
- 掌握四种可见性级别的使用场景
- 学会使用友元机制进行权限控制
- 能够设计多模块协作的项目架构
- 理解模块不可变性及应对策略

### 学习时长
- 理论学习：1.5 小时
- 实践任务：2-3 小时
- 每日考试：1.5 小时
- **总计：5-6 小时**

---

## 📂 目录结构

```
Day_05_模块系统与可见性/
├── README.md                    # 本文件
├── Move.toml                    # 项目配置
├── 01_理论学习/
│   ├── 核心概念.md              # 详细理论知识
│   └── 代码示例.move            # 完整代码示例
├── 02_实践任务/
│   └── 任务说明.md              # 4 个实践任务
├── 03_每日考试/
│   ├── 选择题.md                # 20 道选择题
│   ├── 编程题.md                # 3 道编程题
│   └── 答案解析.md              # 详细答案和解析
└── sources/                     # 你的代码目录
    └── (在此编写实践代码)
```

---

## 🎯 学习路线图

### Step 1: 理论学习（90 分钟）

**必读内容**：
1. 阅读 `01_理论学习/核心概念.md`（60 分钟）
   - 模块系统概述
   - 四种可见性级别
   - 模块导入和依赖
   - 友元机制
   - 结构体可见性

2. 研究 `01_理论学习/代码示例.move`（30 分钟）
   - 8 个完整示例
   - 从基础到高级
   - 实际应用场景

**学习检查**：
- [ ] 能够正确定义模块
- [ ] 理解 public、entry、public(friend) 的区别
- [ ] 知道如何声明和使用友元
- [ ] 了解模块不可变性的影响

---

### Step 2: 实践任务（2-3 小时）

阅读 `02_实践任务/任务说明.md`，依次完成：

#### 任务 1：图书馆管理系统（30 分钟）⭐⭐
**目标**：掌握基本的模块定义和可见性控制

**关键点**：
- 两个模块的协作
- public 和 entry 的使用
- 资源的存储和访问

#### 任务 2：权限管理系统（45 分钟）⭐⭐⭐
**目标**：深入理解友元机制

**关键点**：
- 友元声明和使用
- 权限验证逻辑
- 角色管理

#### 任务 3：多层架构 DeFi 项目（60-90 分钟）⭐⭐⭐⭐
**目标**：设计复杂的分层架构

**关键点**：
- 模块职责分离
- 友元控制内部访问
- API 层设计
- 6 个模块的协作

#### 任务 4：模块升级策略（60 分钟）⭐⭐⭐⭐⭐
**目标**：应对模块不可变性的挑战

**关键点**：
- 代理模式
- 版本管理
- 动态调度

**实践建议**：
- 按顺序完成任务
- 先实现核心功能，再优化
- 遇到困难查阅理论文档
- 完成后查看答案解析中的参考实现

---

### Step 3: 每日考试（80 分钟）

#### 选择题测试（20 分钟）
- 20 道单选题，涵盖所有知识点
- 测试理论理解深度
- 及格线：60 分

#### 编程题挑战（60 分钟）
- 3 道实战编程题
- 考察综合应用能力
- 完成任意 2 题及格

**考试流程**：
1. 独立完成选择题（不查资料）
2. 独立编写编程题代码
3. 对照答案解析检查
4. 理解错题，记录笔记

---

## 🔑 核心知识点

### 1. 可见性级别对比

| 修饰符 | 可见范围 | 返回值 | 使用场景 |
|--------|----------|--------|----------|
| **无修饰符** | 仅模块内 | 允许 | 私有辅助函数 |
| **public** | 所有模块 | 允许 | 公共 API |
| **public(friend)** | 友元模块 | 允许 | 受限共享 |
| **entry** | 交易入口 | 不允许 | 用户直接调用 |
| **public entry** | 所有+交易 | 不允许 | 通用入口 |

### 2. 模块导入方式

```move
// 方式 1：导入模块
use std::vector;

// 方式 2：使用别名
use std::vector as vec;

// 方式 3：导入成员
use std::vector::{push_back, pop_back};

// 方式 4：导入模块和成员
use std::vector::{Self, push_back};
```

### 3. 友元机制

```move
module 0x1::core {
    friend 0x1::admin;  // 声明友元
    
    public(friend) fun privileged() { }  // 友元函数
}

module 0x1::admin {
    use 0x1::core;
    
    public fun do_work() {
        core::privileged();  // ✅ 可以调用
    }
}
```

### 4. 分层架构模式

```
┌─────────────────┐
│   API Layer     │  ← entry 函数，用户交互
├─────────────────┤
│  Logic Layer    │  ← 业务逻辑，friend 函数
├─────────────────┤
│   Core Layer    │  ← 数据结构，public 类型
└─────────────────┘
```

---

## 💻 开发环境

### 编译项目

```bash
cd Day_05_模块系统与可见性
aptos move compile
```

### 运行测试

```bash
aptos move test
```

### 检查错误

```bash
aptos move compile --verbose
```

---

## ✅ 学习检查清单

完成本日学习后，你应该能够：

**基础能力**：
- [ ] 正确定义和命名模块
- [ ] 使用四种可见性修饰符
- [ ] 导入和使用其他模块
- [ ] 编写 entry 函数供用户调用

**进阶能力**：
- [ ] 声明和使用友元模块
- [ ] 设计合理的模块架构
- [ ] 控制结构体字段访问
- [ ] 处理模块依赖关系

**高级能力**：
- [ ] 设计分层架构
- [ ] 实现权限控制系统
- [ ] 理解模块升级策略
- [ ] 编写可维护的代码

---

## 📖 参考资源

### 官方文档
- [Move Book - Modules and Scripts](https://move-language.github.io/move/modules-and-scripts.html)
- [Aptos Move Framework](https://github.com/aptos-labs/aptos-core/tree/main/aptos-move/framework)

### 进阶阅读
- [Move Design Patterns](https://www.move-patterns.com/)
- [Aptos Developer Docs](https://aptos.dev/move/move-on-aptos)

### 社区资源
- [Move Discord](https://discord.gg/move)
- [Aptos Forum](https://forum.aptoslabs.com/)

---

## 🎓 常见问题

### Q1: entry 函数和 public 函数有什么区别？
**A**: 
- `entry`：可以被交易直接调用，但不能有返回值
- `public`：可以被其他模块调用，可以有返回值
- `public entry`：两者都可以，但仍不能有返回值

### Q2: 什么时候使用友元机制？
**A**: 
- 需要在模块间共享内部函数
- 不希望完全公开（public）
- 典型场景：权限管理、测试辅助函数

### Q3: 如何处理模块的不可变性？
**A**:
- **版本化**：部署新版本模块
- **代理模式**：通过代理转发到不同实现
- **可配置参数**：通过配置而非代码调整行为

### Q4: 模块依赖可以循环吗？
**A**: 不可以。Move 不允许循环依赖，需要重构架构或引入中间层。

---

## 🚀 下一步

完成 Day 05 后，你已经掌握了：
✅ Move 的模块系统
✅ 可见性控制机制
✅ 多模块项目架构

**接下来学习**：
- **Day 06**: 泛型编程与能力系统
- 学习如何编写可复用的泛型代码
- 深入理解 Move 的类型系统

---

## 💡 学习建议

1. **理论先行**：先理解概念，再看代码
2. **动手实践**：必须自己写代码，不能只看
3. **循序渐进**：按难度顺序完成任务
4. **总结反思**：完成后写学习笔记
5. **查漏补缺**：通过考试发现薄弱环节

---

## 📝 学习笔记模板

```markdown
# Day 05 学习笔记

## 今日收获
- 

## 重点难点
- 

## 实践心得
- 

## 待解决问题
- 

## 明日计划
- 
```

---

**祝你学习愉快！有问题随时查阅文档或寻求帮助！** 🎉

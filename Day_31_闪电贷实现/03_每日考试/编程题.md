# Day 31 æ¯æ—¥è€ƒè¯• - ç¼–ç¨‹é¢˜

## ğŸ“ è€ƒè¯•è¯´æ˜

- **é¢˜ç›®æ•°é‡**ï¼š3 é“ç¼–ç¨‹é¢˜
- **è€ƒè¯•æ—¶é—´**ï¼š30 åˆ†é’Ÿ
- **æ€»åˆ†**ï¼š30 åˆ†

**ç­”é¢˜è¦æ±‚**ï¼š
- ç¼–å†™å®Œæ•´çš„ Move ä»£ç 
- ä»£ç å¿…é¡»èƒ½å¤Ÿç¼–è¯‘é€šè¿‡
- è€ƒè™‘è¾¹ç•Œæƒ…å†µå’Œé”™è¯¯å¤„ç†
- å®ŒæˆåæŸ¥çœ‹ `ç­”æ¡ˆè§£æ.md` å¯¹ç…§æ ‡å‡†ç­”æ¡ˆ

---

## ğŸ’» ç¼–ç¨‹é¢˜ 1ï¼šå®ç°é—ªç”µè´·çš„ Hot Potatoï¼ˆ10åˆ†ï¼‰

### é¢˜ç›®æè¿°

å®ç°ä¸€ä¸ªç®€åŒ–ç‰ˆçš„é—ªç”µè´·åè®®ï¼Œé‡ç‚¹æ˜¯æ­£ç¡®ä½¿ç”¨ Hot Potato æ¨¡å¼ã€‚

### è¦æ±‚

å®ç°ä»¥ä¸‹æ¨¡å—ï¼š

```move
module flash_loan::simple {
    use std::signer;
    use aptos_framework::coin::{Self, Coin};
    
    /// ç®€åŒ–çš„èµ„äº§æ± 
    struct SimplePool<phantom CoinType> has key {
        reserves: Coin<CoinType>,
        fee_rate: u64,  // åŸºç‚¹ï¼Œå¦‚ 30 = 0.3%
    }
    
    /// Hot Potato - é—ªç”µè´·å‡­è¯
    struct FlashLoan {
        amount: u64,
        fee: u64,
    }
    
    // é”™è¯¯ç 
    const E_INSUFFICIENT_LIQUIDITY: u64 = 1;
    const E_INSUFFICIENT_REPAYMENT: u64 = 2;
    
    const FEE_DENOMINATOR: u64 = 10000;
    
    /// TODO: å®ç°åˆå§‹åŒ–å‡½æ•°
    public fun initialize<CoinType>(
        admin: &signer,
        initial_liquidity: Coin<CoinType>,
        fee_rate: u64
    ) {
        // ä½ çš„ä»£ç 
    }
    
    /// TODO: å®ç°é—ªç”µè´·å€Ÿæ¬¾å‡½æ•°
    /// è¿”å›ï¼š(å€Ÿå…¥çš„å¸, FlashLoan Hot Potato)
    public fun borrow<CoinType>(
        pool_addr: address,
        amount: u64
    ): (Coin<CoinType>, FlashLoan) acquires SimplePool {
        // ä½ çš„ä»£ç 
    }
    
    /// TODO: å®ç°è¿˜æ¬¾å‡½æ•°
    /// æ¶ˆè´¹ FlashLoan Hot Potato
    public fun repay<CoinType>(
        pool_addr: address,
        coins: Coin<CoinType>,
        flash_loan: FlashLoan
    ) acquires SimplePool {
        // ä½ çš„ä»£ç 
    }
    
    /// TODO: å®ç°æ‰‹ç»­è´¹è®¡ç®—å‡½æ•°
    fun calculate_fee(amount: u64, fee_rate: u64): u64 {
        // ä½ çš„ä»£ç 
    }
}
```

### è¯„åˆ†ç‚¹ï¼ˆ10åˆ†ï¼‰

- [ ] initialize å‡½æ•°æ­£ç¡®å®ç°ï¼ˆ2åˆ†ï¼‰
- [ ] borrow å‡½æ•°æ­£ç¡®åˆ›å»º Hot Potatoï¼ˆ3åˆ†ï¼‰
- [ ] repay å‡½æ•°æ­£ç¡®æ¶ˆè´¹ Hot Potatoï¼ˆ3åˆ†ï¼‰
- [ ] åŒ…å«å¿…è¦çš„å®‰å…¨æ£€æŸ¥ï¼ˆ1åˆ†ï¼‰
- [ ] calculate_fee è®¡ç®—æ­£ç¡®ï¼ˆ1åˆ†ï¼‰

### æç¤º

1. Hot Potato ä¸åº”è¯¥æœ‰ä»»ä½•èƒ½åŠ›
2. borrow å¿…é¡»è¿”å› FlashLoan
3. repay å¿…é¡»è§£æ„ FlashLoan
4. æ£€æŸ¥æµåŠ¨æ€§å’Œå½’è¿˜é‡‘é¢

---

## ğŸ’» ç¼–ç¨‹é¢˜ 2ï¼šå®ç°å¥—åˆ©åˆ©æ¶¦è®¡ç®—å™¨ï¼ˆ10åˆ†ï¼‰

### é¢˜ç›®æè¿°

å®ç°ä¸€ä¸ªå‡½æ•°ï¼Œè®¡ç®— DEX å¥—åˆ©çš„é¢„æœŸåˆ©æ¶¦ã€‚è€ƒè™‘æ‰€æœ‰æ‰‹ç»­è´¹å’Œæ»‘ç‚¹ã€‚

### è¦æ±‚

```move
module flash_loan::arbitrage_calculator {
    
    /// å¥—åˆ©è®¡ç®—ç»“æœ
    struct ArbitrageResult has drop {
        is_profitable: bool,    // æ˜¯å¦æœ‰åˆ©å¯å›¾
        gross_profit: u64,      // æ¯›åˆ©æ¶¦
        total_fees: u64,        // æ€»æ‰‹ç»­è´¹
        net_profit: u64,        // å‡€åˆ©æ¶¦
    }
    
    /// TODO: å®ç° AMM è¾“å‡ºè®¡ç®—
    /// ä½¿ç”¨æ’å®šä¹˜ç§¯å…¬å¼ï¼šx * y = k
    /// è€ƒè™‘ 0.3% çš„äº¤æ˜“æ‰‹ç»­è´¹
    /// 
    /// å‚æ•°ï¼š
    /// - amount_in: è¾“å…¥é‡‘é¢
    /// - reserve_in: è¾“å…¥ä»£å¸å‚¨å¤‡
    /// - reserve_out: è¾“å‡ºä»£å¸å‚¨å¤‡
    /// 
    /// è¿”å›ï¼šè¾“å‡ºé‡‘é¢
    public fun calculate_amm_output(
        amount_in: u64,
        reserve_in: u64,
        reserve_out: u64
    ): u64 {
        // ä½ çš„ä»£ç 
        // æç¤ºï¼šoutput = (reserve_out * amount_in * 997) / (reserve_in * 1000 + amount_in * 997)
    }
    
    /// TODO: å®ç°å¥—åˆ©åˆ©æ¶¦è®¡ç®—
    /// 
    /// åœºæ™¯ï¼š
    /// 1. ç”¨é—ªç”µè´·å€Ÿå…¥ amount ä¸ª TokenX
    /// 2. åœ¨ DEX A ç”¨ TokenX ä¹° TokenY
    /// 3. åœ¨ DEX B ç”¨ TokenY å–å› TokenX
    /// 4. å½’è¿˜é—ªç”µè´·
    /// 
    /// å‚æ•°ï¼š
    /// - borrow_amount: é—ªç”µè´·é‡‘é¢
    /// - flash_fee_rate: é—ªç”µè´·æ‰‹ç»­è´¹ç‡ï¼ˆåŸºç‚¹ï¼Œå¦‚ 30 = 0.3%ï¼‰
    /// - dex_a_reserve_x: DEX A çš„ TokenX å‚¨å¤‡
    /// - dex_a_reserve_y: DEX A çš„ TokenY å‚¨å¤‡
    /// - dex_b_reserve_y: DEX B çš„ TokenY å‚¨å¤‡
    /// - dex_b_reserve_x: DEX B çš„ TokenX å‚¨å¤‡
    /// 
    /// è¿”å›ï¼šArbitrageResult
    public fun calculate_arbitrage_profit(
        borrow_amount: u64,
        flash_fee_rate: u64,
        dex_a_reserve_x: u64,
        dex_a_reserve_y: u64,
        dex_b_reserve_y: u64,
        dex_b_reserve_x: u64
    ): ArbitrageResult {
        // ä½ çš„ä»£ç 
    }
}
```

### æµ‹è¯•ç”¨ä¾‹

ä½ çš„å®ç°åº”è¯¥é€šè¿‡ä»¥ä¸‹æµ‹è¯•ï¼š

```move
#[test]
fun test_profitable_arbitrage() {
    // åœºæ™¯ï¼šDEX A ä»·æ ¼ä½ï¼ŒDEX B ä»·æ ¼é«˜
    let result = calculate_arbitrage_profit(
        10000,      // å€Ÿ 10,000 USDC
        30,         // 0.3% é—ªç”µè´·è´¹
        100000,     // DEX A: 100,000 USDC
        10000,      // DEX A: 10,000 APT (1 APT = 10 USDC)
        10000,      // DEX B: 10,000 APT
        110000      // DEX B: 110,000 USDC (1 APT = 11 USDC)
    );
    
    assert!(result.is_profitable, 0);
    // åº”è¯¥æœ‰åˆ©æ¶¦
}

#[test]
fun test_unprofitable_arbitrage() {
    // åœºæ™¯ï¼šä»·å·®å¤ªå°ï¼Œä¸è¶³ä»¥è¦†ç›–æ‰‹ç»­è´¹
    let result = calculate_arbitrage_profit(
        10000,
        30,
        100000,
        10000,
        10000,
        100500      // ä»… 0.5% ä»·å·®
    );
    
    assert!(!result.is_profitable, 0);
}
```

### è¯„åˆ†ç‚¹ï¼ˆ10åˆ†ï¼‰

- [ ] calculate_amm_output å®ç°æ­£ç¡®ï¼ˆ4åˆ†ï¼‰
- [ ] calculate_arbitrage_profit é€»è¾‘æ­£ç¡®ï¼ˆ4åˆ†ï¼‰
- [ ] æ­£ç¡®è®¡ç®—æ‰€æœ‰æ‰‹ç»­è´¹ï¼ˆ1åˆ†ï¼‰
- [ ] æµ‹è¯•ç”¨ä¾‹é€šè¿‡ï¼ˆ1åˆ†ï¼‰

---

## ğŸ’» ç¼–ç¨‹é¢˜ 3ï¼šå®ç°é—ªç”µè´·èšåˆå™¨é€‰æ‹©é€»è¾‘ï¼ˆ10åˆ†ï¼‰

### é¢˜ç›®æè¿°

å®ç°ä¸€ä¸ªèšåˆå™¨ï¼Œèƒ½å¤Ÿä»å¤šä¸ªé—ªç”µè´·æ± ä¸­é€‰æ‹©æ‰‹ç»­è´¹æœ€ä½çš„æ± å­ã€‚

### è¦æ±‚

```move
module flash_loan::aggregator {
    use std::vector;
    
    /// æ± å­ä¿¡æ¯
    struct PoolInfo has store, drop, copy {
        pool_address: address,
        fee_rate: u64,           // æ‰‹ç»­è´¹ç‡ï¼ˆåŸºç‚¹ï¼‰
        available_liquidity: u64, // å¯ç”¨æµåŠ¨æ€§
    }
    
    /// èšåˆå™¨
    struct Aggregator has key {
        pools: vector<PoolInfo>,
    }
    
    const E_NO_SUITABLE_POOL: u64 = 1;
    const FEE_DENOMINATOR: u64 = 10000;
    
    /// TODO: å®ç°æŸ¥æ‰¾æœ€ä¼˜æ± å­
    /// 
    /// è¦æ±‚ï¼š
    /// 1. æµåŠ¨æ€§å¿…é¡» >= amount
    /// 2. åœ¨æ»¡è¶³æ¡ä»¶çš„æ± å­ä¸­ï¼Œé€‰æ‹©æ‰‹ç»­è´¹æœ€ä½çš„
    /// 3. å¦‚æœæœ‰å¤šä¸ªæ± å­æ‰‹ç»­è´¹ç›¸åŒï¼Œé€‰æ‹©æµåŠ¨æ€§æœ€å¤§çš„
    /// 
    /// å‚æ•°ï¼š
    /// - pools: æ± å­åˆ—è¡¨
    /// - amount: éœ€è¦å€Ÿå…¥çš„é‡‘é¢
    /// 
    /// è¿”å›ï¼š(æœ€ä¼˜æ± å­åœ°å€, é¢„æœŸæ‰‹ç»­è´¹)
    /// å¦‚æœæ²¡æœ‰åˆé€‚çš„æ± å­ï¼Œabort with E_NO_SUITABLE_POOL
    public fun find_best_pool(
        pools: &vector<PoolInfo>,
        amount: u64
    ): (address, u64) {
        // ä½ çš„ä»£ç 
    }
    
    /// TODO: å®ç°åˆ†æ‹†å€Ÿæ¬¾ç­–ç•¥
    /// 
    /// å½“å•ä¸ªæ± å­æµåŠ¨æ€§ä¸è¶³æ—¶ï¼Œä»å¤šä¸ªæ± å­åˆ†æ‹†å€Ÿæ¬¾
    /// 
    /// è¦æ±‚ï¼š
    /// 1. æ€»å€Ÿæ¬¾é‡‘é¢ = amount
    /// 2. æœ€å°åŒ–æ€»æ‰‹ç»­è´¹
    /// 3. è¿”å›å€Ÿæ¬¾æ–¹æ¡ˆï¼š[(æ± å­åœ°å€, å€Ÿæ¬¾é‡‘é¢, æ‰‹ç»­è´¹)]
    /// 
    /// ç®€åŒ–ç‰ˆï¼šæŒ‰æ‰‹ç»­è´¹ä»ä½åˆ°é«˜æ’åºæ± å­ï¼Œä¾æ¬¡å€Ÿæ»¡
    public fun split_borrow_plan(
        pools: &vector<PoolInfo>,
        amount: u64
    ): vector<(address, u64, u64)> {
        // ä½ çš„ä»£ç 
    }
}
```

### æµ‹è¯•ç”¨ä¾‹

```move
#[test]
fun test_find_best_pool() {
    let pools = vector[
        PoolInfo {
            pool_address: @0x1,
            fee_rate: 30,        // 0.3%
            available_liquidity: 100000,
        },
        PoolInfo {
            pool_address: @0x2,
            fee_rate: 25,        // 0.25% - æœ€ä½
            available_liquidity: 50000,
        },
        PoolInfo {
            pool_address: @0x3,
            fee_rate: 35,        // 0.35%
            available_liquidity: 200000,
        },
    ];
    
    // å€Ÿ 40,000ï¼Œåº”è¯¥é€‰æ‹© @0x2ï¼ˆæ‰‹ç»­è´¹æœ€ä½ä¸”æµåŠ¨æ€§è¶³å¤Ÿï¼‰
    let (best_pool, fee) = find_best_pool(&pools, 40000);
    assert!(best_pool == @0x2, 0);
    assert!(fee == 10, 1);  // 40000 * 25 / 10000 = 100... ç­‰ç­‰ï¼Œåº”è¯¥æ˜¯ 10
}

#[test]
fun test_split_borrow() {
    let pools = vector[
        PoolInfo {
            pool_address: @0x1,
            fee_rate: 25,
            available_liquidity: 30000,
        },
        PoolInfo {
            pool_address: @0x2,
            fee_rate: 30,
            available_liquidity: 40000,
        },
    ];
    
    // éœ€è¦ 50,000ï¼Œéœ€è¦åˆ†æ‹†
    let plan = split_borrow_plan(&pools, 50000);
    
    // åº”è¯¥ï¼š
    // - ä» @0x1 å€Ÿ 30,000ï¼ˆæ‰‹ç»­è´¹æ›´ä½ï¼Œå€Ÿæ»¡ï¼‰
    // - ä» @0x2 å€Ÿ 20,000ï¼ˆè¡¥è¶³å‰©ä½™ï¼‰
    assert!(vector::length(&plan) == 2, 0);
}
```

### è¯„åˆ†ç‚¹ï¼ˆ10åˆ†ï¼‰

- [ ] find_best_pool é€»è¾‘æ­£ç¡®ï¼ˆ5åˆ†ï¼‰
  - æ­£ç¡®è¿‡æ»¤æµåŠ¨æ€§ä¸è¶³çš„æ± å­ï¼ˆ2åˆ†ï¼‰
  - æ­£ç¡®é€‰æ‹©æ‰‹ç»­è´¹æœ€ä½çš„æ± å­ï¼ˆ2åˆ†ï¼‰
  - æ‰‹ç»­è´¹ç›¸åŒæ—¶é€‰æ‹©æµåŠ¨æ€§å¤§çš„ï¼ˆ1åˆ†ï¼‰
- [ ] split_borrow_plan å®ç°æ­£ç¡®ï¼ˆ4åˆ†ï¼‰
  - æ­£ç¡®è®¡ç®—åˆ†æ‹†æ–¹æ¡ˆï¼ˆ3åˆ†ï¼‰
  - ä¼˜åŒ–æ‰‹ç»­è´¹ï¼ˆ1åˆ†ï¼‰
- [ ] æµ‹è¯•ç”¨ä¾‹é€šè¿‡ï¼ˆ1åˆ†ï¼‰

---

## ğŸ“Š æ€»åˆ†ç»Ÿè®¡

| é¢˜ç›® | åˆ†å€¼ | å¾—åˆ† |
|------|------|------|
| ç¼–ç¨‹é¢˜ 1 | 10åˆ† | ___ |
| ç¼–ç¨‹é¢˜ 2 | 10åˆ† | ___ |
| ç¼–ç¨‹é¢˜ 3 | 10åˆ† | ___ |
| **æ€»è®¡** | **30åˆ†** | ___ |

---

## ğŸ’¡ ç¼–ç¨‹æç¤º

### Hot Potato æ¨¡å¼

```move
// âœ… æ­£ç¡®ï¼šå¿…é¡»è¢«æ¶ˆè´¹
struct HotPotato {
    value: u64,
}

public fun create(): HotPotato {
    HotPotato { value: 100 }
}

public fun consume(hp: HotPotato) {
    let HotPotato { value } = hp;  // è§£æ„
    // ä½¿ç”¨ value
}
```

### æ’å®šä¹˜ç§¯å…¬å¼

```move
// x * y = k
// è¾“å…¥ Î”xï¼Œè¾“å‡º Î”y
// (x + Î”x) * (y - Î”y) = k = x * y
// Î”y = (y * Î”x) / (x + Î”x)

// è€ƒè™‘ 0.3% æ‰‹ç»­è´¹ï¼š
// Î”y = (y * Î”x * 0.997) / (x + Î”x * 0.997)
// ä½¿ç”¨æ•´æ•°ï¼š
// Î”y = (y * Î”x * 997) / (x * 1000 + Î”x * 997)
```

### Vector æ“ä½œ

```move
use std::vector;

// éå†
let i = 0;
while (i < vector::length(&pools)) {
    let pool = vector::borrow(&pools, i);
    // å¤„ç† pool
    i = i + 1;
}

// æ·»åŠ å…ƒç´ 
vector::push_back(&mut result, item);

// æ’åºï¼ˆéœ€è¦è‡ªå·±å®ç°æˆ–ä½¿ç”¨åº“ï¼‰
```

---

## âœ… æäº¤è¦æ±‚

### æ–‡ä»¶ç»„ç»‡

```
sources/
â”œâ”€â”€ simple.move           # ç¼–ç¨‹é¢˜ 1
â”œâ”€â”€ arbitrage_calculator.move  # ç¼–ç¨‹é¢˜ 2
â””â”€â”€ aggregator.move       # ç¼–ç¨‹é¢˜ 3

tests/
â”œâ”€â”€ simple_tests.move
â”œâ”€â”€ calculator_tests.move
â””â”€â”€ aggregator_tests.move
```

### éªŒè¯å‘½ä»¤

```bash
# ç¼–è¯‘
aptos move compile

# æµ‹è¯•
aptos move test --filter simple
aptos move test --filter calculator
aptos move test --filter aggregator
```

---

**å®Œæˆåï¼ŒæŸ¥çœ‹ `ç­”æ¡ˆè§£æ.md` å¯¹ç…§æ ‡å‡†ç­”æ¡ˆï¼**

# Day 28 æ¯æ—¥è€ƒè¯• - ç­”æ¡ˆè§£æ

## ğŸ“Š é€‰æ‹©é¢˜ç­”æ¡ˆï¼ˆ40åˆ†ï¼‰

### ç¬¬ä¸€éƒ¨åˆ†ï¼šIndexer æ¶æ„

**1. B** - å°†åŒºå—é“¾æ•°æ®è½¬æ¢ä¸ºæ˜“æŸ¥è¯¢çš„ç»“æ„åŒ–æ ¼å¼  
**è§£æ**: Indexer çš„æ ¸å¿ƒä½œç”¨æ˜¯å°†åŸå§‹çš„åŒºå—é“¾æ•°æ®å¤„ç†æˆç»“æ„åŒ–ã€æ˜“æŸ¥è¯¢çš„æ ¼å¼ï¼Œé€šè¿‡ GraphQL API æä¾›ç»™åº”ç”¨ä½¿ç”¨ã€‚

**2. C** - Fullnode â†’ Transaction Stream â†’ Processor â†’ Database â†’ GraphQL  
**è§£æ**: è¿™æ˜¯æ­£ç¡®çš„æ•°æ®æµå‘ã€‚Fullnode äº§ç”Ÿæ•°æ®ï¼ŒTSS æ¥æ”¶å¹¶æ¨é€ï¼ŒProcessor å¤„ç†ï¼Œå­˜å…¥ Databaseï¼Œæœ€åé€šè¿‡ GraphQL æä¾›æŸ¥è¯¢æ¥å£ã€‚

**3. B** - Transaction Stream Service (TSS)  
**è§£æ**: TSS è´Ÿè´£ç›‘å¬ Fullnode çš„æ–°äº¤æ˜“å¹¶æ¨é€ç»™è®¢é˜…çš„ Processorã€‚

**4. B** - ä»£å¸ä½™é¢å’Œè½¬è´¦  
**è§£æ**: Coin Processor ä¸“é—¨å¤„ç†ä»£å¸ç›¸å…³çš„æ•°æ®ï¼ŒåŒ…æ‹¬ä½™é¢è®¡ç®—å’Œè½¬è´¦è®°å½•ã€‚

**5. C** - 400-500ms  
**è§£æ**: Indexer çš„æ­£å¸¸å»¶è¿Ÿåœ¨ 400-500msï¼Œå³°å€¼å¯èƒ½è¾¾åˆ° 1-2 ç§’ã€‚

**6. B** - æœ€ç»ˆä¸€è‡´æ€§  
**è§£æ**: Indexer æä¾›æœ€ç»ˆä¸€è‡´æ€§ä¿è¯ï¼Œæ•°æ®æœ€ç»ˆä¼šè¢«ç´¢å¼•ï¼Œä½†å¯èƒ½æœ‰çŸ­æš‚å»¶è¿Ÿã€‚

**7. C** - åŸºäºæ•°æ®åº“ Schema è‡ªåŠ¨ç”Ÿæˆ GraphQL API  
**è§£æ**: Hasura æ˜¯ä¸€ä¸ª GraphQL å¼•æ“ï¼Œè‡ªåŠ¨æ ¹æ® PostgreSQL çš„ Schema ç”Ÿæˆ GraphQL APIã€‚

**8. A** - å¯ä»¥ï¼Œå®ƒä»¬ç‹¬ç«‹å¤„ç†ä¸åŒç±»å‹çš„æ•°æ®  
**è§£æ**: å¤šä¸ª Processorï¼ˆCoinã€Tokenã€Event ç­‰ï¼‰å¯ä»¥å¹¶è¡Œå·¥ä½œï¼Œå„è‡ªå¤„ç†ä¸åŒç±»å‹çš„æ•°æ®ã€‚

### ç¬¬äºŒéƒ¨åˆ†ï¼šGraphQL è¯­æ³•

**9. B** - Query, Mutation, Subscription  
**è§£æ**: GraphQL çš„ä¸‰ç§ä¸»è¦æ“ä½œç±»å‹ï¼šQueryï¼ˆè¯»ï¼‰ã€Mutationï¼ˆå†™ï¼‰ã€Subscriptionï¼ˆè®¢é˜…ï¼‰ã€‚

**10. C** - Query å’Œ Subscription  
**è§£æ**: Aptos Indexer æ˜¯åªè¯»çš„ï¼Œæ”¯æŒ Query å’Œ Subscriptionï¼Œä¸æ”¯æŒ Mutationã€‚

**11. C** - `query GetTransactions($limit: Int!) { ... }`  
**è§£æ**: å˜é‡å®šä¹‰æ ¼å¼ä¸º `$å˜é‡å: ç±»å‹!`ï¼ˆ!è¡¨ç¤ºå¿…éœ€ï¼‰ã€‚

**12. B** - å¤ç”¨æŸ¥è¯¢å­—æ®µç»“æ„  
**è§£æ**: Fragment å…è®¸å®šä¹‰å¯å¤ç”¨çš„å­—æ®µé›†åˆï¼Œé¿å…é‡å¤ç¼–å†™ç›¸åŒçš„å­—æ®µåˆ—è¡¨ã€‚

**13. B** - `{field: {_gt: value}}`  
**è§£æ**: Hasura ä½¿ç”¨ `_gt`ï¼ˆgreater thanï¼‰è¡¨ç¤ºå¤§äºæ¡ä»¶ã€‚

**14. B** - `order_by: {version: desc}`  
**è§£æ**: desc è¡¨ç¤ºé™åºï¼Œä¼šè¿”å›æœ€æ–°çš„äº¤æ˜“ï¼ˆversion æœ€å¤§çš„ï¼‰ã€‚

**15. B** - `recent: transactions { ... }`  
**è§£æ**: GraphQL åˆ«åè¯­æ³•æ˜¯ `åˆ«å: å­—æ®µ { ... }`ã€‚

**16. B** - `{field: {_like: "%pattern%"}}`  
**è§£æ**: `_like` æ“ä½œç¬¦æ”¯æŒ SQL é£æ ¼çš„æ¨¡ç³ŠåŒ¹é…ï¼Œ% æ˜¯é€šé…ç¬¦ã€‚

### ç¬¬ä¸‰éƒ¨åˆ†ï¼šæ•°æ®æ¨¡å‹

**17. C** - version  
**è§£æ**: transaction version æ˜¯å…¨å±€å”¯ä¸€é€’å¢çš„äº¤æ˜“ç‰ˆæœ¬å·ï¼Œç”¨ä½œä¸»é”®ã€‚

**18. C** - transaction_version å’Œ event_index çš„ç»„åˆ  
**è§£æ**: ä¸€ä¸ªäº¤æ˜“å¯ä»¥æœ‰å¤šä¸ªäº‹ä»¶ï¼Œå› æ­¤éœ€è¦ç»„åˆé”®ã€‚

**19. B** - å½“å‰æœ€æ–°çš„ä½™é¢  
**è§£æ**: current_coin_balances å­˜å‚¨æ¯ä¸ªè´¦æˆ·æ¯ç§ä»£å¸çš„å½“å‰ä½™é¢ï¼ˆæœ€æ–°çŠ¶æ€ï¼‰ã€‚

**20. C** - current_token_ownerships_v2  
**è§£æ**: v2 ç‰ˆæœ¬çš„ Token Standard ä½¿ç”¨ current_token_ownerships_v2 è¡¨å­˜å‚¨å½“å‰æ‰€æœ‰æƒã€‚

---

## ğŸ’» ç¼–ç¨‹é¢˜ç­”æ¡ˆï¼ˆ60åˆ†ï¼‰

### ç¼–ç¨‹é¢˜ 1ï¼šå®ç° GraphQL æŸ¥è¯¢å‡½æ•°ï¼ˆ20åˆ†ï¼‰

```typescript
import axios from 'axios';

interface Transaction {
  version: string;
  hash: string;
  sender: string;
  success: boolean;
  gasUsed: number;
  timestamp: string;
  functionCalled?: string;
}

async function getAccountTransactions(
  endpoint: string,
  accountAddress: string,
  limit: number = 10,
  offset: number = 0
): Promise<Transaction[]> {
  // GraphQL æŸ¥è¯¢
  const query = `
    query GetAccountTransactions(
      $address: String!,
      $limit: Int!,
      $offset: Int!
    ) {
      account_transactions(
        where: {account_address: {_eq: $address}}
        limit: $limit
        offset: $offset
        order_by: {transaction_version: desc}
      ) {
        transaction_version
        user_transaction {
          hash
          sender
          success
          gas_used
          timestamp
          entry_function_id_str
        }
      }
    }
  `;

  try {
    // å‘é€ GraphQL è¯·æ±‚
    const response = await axios.post(
      endpoint,
      {
        query,
        variables: {
          address: accountAddress,
          limit,
          offset
        }
      },
      {
        headers: {
          'Content-Type': 'application/json'
        },
        timeout: 10000  // 10ç§’è¶…æ—¶
      }
    );

    // æ£€æŸ¥ GraphQL é”™è¯¯
    if (response.data.errors) {
      throw new Error(
        `GraphQL errors: ${JSON.stringify(response.data.errors)}`
      );
    }

    // æ ¼å¼åŒ–æ•°æ®
    const transactions: Transaction[] = response.data.data.account_transactions
      .map((item: any) => {
        const tx = item.user_transaction;
        if (!tx) return null;

        return {
          version: item.transaction_version,
          hash: tx.hash,
          sender: tx.sender,
          success: tx.success,
          gasUsed: parseInt(tx.gas_used),
          timestamp: tx.timestamp,
          functionCalled: tx.entry_function_id_str || undefined
        };
      })
      .filter((tx: any) => tx !== null);

    return transactions;

  } catch (error: any) {
    // é”™è¯¯å¤„ç†
    if (error.response) {
      throw new Error(
        `HTTP error: ${error.response.status} - ${error.response.statusText}`
      );
    } else if (error.request) {
      throw new Error('Network error: No response received');
    } else {
      throw new Error(`Error: ${error.message}`);
    }
  }
}

// æµ‹è¯•
async function test() {
  try {
    const transactions = await getAccountTransactions(
      'https://indexer.testnet.aptoslabs.com/v1/graphql',
      '0x1',
      5,
      0
    );

    console.log('æŸ¥è¯¢åˆ°çš„äº¤æ˜“:');
    transactions.forEach((tx, i) => {
      console.log(`${i + 1}. Version: ${tx.version}`);
      console.log(`   Hash: ${tx.hash}`);
      console.log(`   Success: ${tx.success}`);
      console.log(`   Gas: ${tx.gasUsed}`);
      console.log(`   Function: ${tx.functionCalled || 'N/A'}`);
      console.log('');
    });
  } catch (error) {
    console.error('æŸ¥è¯¢å¤±è´¥:', error);
  }
}
```

**è¯„åˆ†ç‚¹**:
- âœ… GraphQL æŸ¥è¯¢è¯­æ³•æ­£ç¡®ï¼ˆ8åˆ†ï¼‰
- âœ… æ•°æ®æ ¼å¼åŒ–æ­£ç¡®ï¼ˆ4åˆ†ï¼‰
- âœ… å®Œæ•´çš„é”™è¯¯å¤„ç†ï¼ˆ4åˆ†ï¼‰
- âœ… ä»£ç ç»“æ„æ¸…æ™°ï¼ˆ4åˆ†ï¼‰

---

### ç¼–ç¨‹é¢˜ 2ï¼šå®ç°äº‹ä»¶è¿‡æ»¤å™¨ï¼ˆ20åˆ†ï¼‰

```typescript
import { ApolloClient, InMemoryCache, gql } from '@apollo/client';
import { WebSocketLink } from '@apollo/client/link/ws';
import { SubscriptionClient } from 'subscriptions-transport-ws';
import ws from 'ws';

interface Event {
  transaction_version: string;
  type: string;
  data: any;
  sequence_number: string;
}

interface FilterOptions {
  eventTypes: string[];
  minAmount?: number;
  maxAmount?: number;
}

class EventFilter {
  private client: ApolloClient<any>;
  private subscriptionClient: SubscriptionClient;
  private subscription: any;
  private reconnectAttempts: number = 0;
  private maxReconnectAttempts: number = 5;

  constructor(
    private wsEndpoint: string,
    private options: FilterOptions
  ) {
    // åˆ›å»º WebSocket è¿æ¥
    this.subscriptionClient = new SubscriptionClient(
      wsEndpoint,
      {
        reconnect: true,
        reconnectionAttempts: this.maxReconnectAttempts,
        connectionCallback: (error) => {
          if (error) {
            console.error('WebSocket connection error:', error);
            this.handleReconnect();
          } else {
            console.log('WebSocket connected');
            this.reconnectAttempts = 0;
          }
        }
      },
      ws
    );

    // åˆ›å»º Apollo Client
    const wsLink = new WebSocketLink(this.subscriptionClient);
    
    this.client = new ApolloClient({
      link: wsLink,
      cache: new InMemoryCache()
    });
  }

  start(callback: (event: Event) => void): void {
    // æ„å»ºè®¢é˜…æŸ¥è¯¢
    const subscription = gql`
      subscription {
        events(
          limit: 10
          order_by: {transaction_version: desc}
        ) {
          transaction_version
          type
          data
          sequence_number
        }
      }
    `;

    // å¼€å§‹è®¢é˜…
    this.subscription = this.client.subscribe({
      query: subscription
    }).subscribe({
      next: (result) => {
        const events = result.data.events;
        
        // è¿‡æ»¤å¹¶å¤„ç†äº‹ä»¶
        events.forEach((event: Event) => {
          if (this.matches(event)) {
            callback(event);
          }
        });
      },
      error: (error) => {
        console.error('Subscription error:', error);
        this.handleReconnect();
      },
      complete: () => {
        console.log('Subscription completed');
      }
    });
  }

  stop(): void {
    if (this.subscription) {
      this.subscription.unsubscribe();
    }
    if (this.subscriptionClient) {
      this.subscriptionClient.close();
    }
  }

  private matches(event: Event): boolean {
    // æ£€æŸ¥äº‹ä»¶ç±»å‹
    if (!this.options.eventTypes.includes(event.type)) {
      return false;
    }

    // æ£€æŸ¥é‡‘é¢èŒƒå›´ï¼ˆå¦‚æœæŒ‡å®šï¼‰
    if (this.options.minAmount !== undefined || 
        this.options.maxAmount !== undefined) {
      
      const amount = event.data.amount;
      
      if (typeof amount !== 'number') {
        return false;
      }

      if (this.options.minAmount !== undefined && 
          amount < this.options.minAmount) {
        return false;
      }

      if (this.options.maxAmount !== undefined && 
          amount > this.options.maxAmount) {
        return false;
      }
    }

    return true;
  }

  private handleReconnect(): void {
    if (this.reconnectAttempts < this.maxReconnectAttempts) {
      this.reconnectAttempts++;
      const delay = Math.min(1000 * Math.pow(2, this.reconnectAttempts), 30000);
      
      console.log(
        `Reconnecting in ${delay}ms (attempt ${this.reconnectAttempts})...`
      );
      
      setTimeout(() => {
        // WebSocket å®¢æˆ·ç«¯ä¼šè‡ªåŠ¨é‡è¿
      }, delay);
    } else {
      console.error('Max reconnection attempts reached');
    }
  }
}

// æµ‹è¯•
const filter = new EventFilter(
  'wss://indexer.testnet.aptoslabs.com/v1/graphql',
  {
    eventTypes: ['0x1::coin::WithdrawEvent'],
    minAmount: 1000000
  }
);

filter.start((event) => {
  console.log('æ£€æµ‹åˆ°å¤§é¢ææ¬¾:');
  console.log('  Type:', event.type);
  console.log('  Amount:', event.data.amount);
  console.log('  Version:', event.transaction_version);
});

// 5åˆ†é’Ÿååœæ­¢
setTimeout(() => {
  filter.stop();
  console.log('å·²åœæ­¢ç›‘å¬');
}, 5 * 60 * 1000);
```

**è¯„åˆ†ç‚¹**:
- âœ… WebSocket è¿æ¥å»ºç«‹æ­£ç¡®ï¼ˆ6åˆ†ï¼‰
- âœ… äº‹ä»¶è¿‡æ»¤é€»è¾‘æ­£ç¡®ï¼ˆ6åˆ†ï¼‰
- âœ… å®ç°é‡è¿æœºåˆ¶ï¼ˆ4åˆ†ï¼‰
- âœ… ä»£ç è´¨é‡è‰¯å¥½ï¼ˆ4åˆ†ï¼‰

---

### ç¼–ç¨‹é¢˜ 3ï¼šæ•°æ®ç»Ÿè®¡åˆ†æï¼ˆ20åˆ†ï¼‰

```typescript
import axios from 'axios';

interface TransactionPattern {
  totalTransactions: number;
  successRate: number;
  averageGas: number;
  topFunctions: Array<{
    function: string;
    count: number;
    percentage: number;
  }>;
  hourlyDistribution: Record<number, number>;
}

async function analyzeTransactionPatterns(
  endpoint: string,
  accountAddress: string,
  transactionCount: number = 100
): Promise<TransactionPattern> {
  // æŸ¥è¯¢äº¤æ˜“æ•°æ®
  const query = `
    query GetAccountTransactions($address: String!, $limit: Int!) {
      account_transactions(
        where: {account_address: {_eq: $address}}
        limit: $limit
        order_by: {transaction_version: desc}
      ) {
        user_transaction {
          success
          gas_used
          timestamp
          entry_function_id_str
        }
      }
    }
  `;

  try {
    const response = await axios.post(endpoint, {
      query,
      variables: {
        address: accountAddress,
        limit: transactionCount
      }
    });

    if (response.data.errors) {
      throw new Error(`GraphQL errors: ${JSON.stringify(response.data.errors)}`);
    }

    const transactions = response.data.data.account_transactions
      .map((item: any) => item.user_transaction)
      .filter((tx: any) => tx !== null);

    // è®¡ç®—ç»Ÿè®¡æ•°æ®
    const totalTransactions = transactions.length;
    
    // æˆåŠŸç‡
    const successCount = transactions.filter((tx: any) => tx.success).length;
    const successRate = (successCount / totalTransactions) * 100;

    // å¹³å‡ Gas
    const totalGas = transactions.reduce(
      (sum: number, tx: any) => sum + parseInt(tx.gas_used || 0),
      0
    );
    const averageGas = Math.round(totalGas / totalTransactions);

    // å‡½æ•°è°ƒç”¨ç»Ÿè®¡
    const functionCounts: Record<string, number> = {};
    transactions.forEach((tx: any) => {
      const func = tx.entry_function_id_str;
      if (func) {
        functionCounts[func] = (functionCounts[func] || 0) + 1;
      }
    });

    // å–å‰5ä¸ªæœ€å¸¸ç”¨çš„å‡½æ•°
    const topFunctions = Object.entries(functionCounts)
      .map(([func, count]) => ({
        function: func,
        count: count as number,
        percentage: Math.round(((count as number) / totalTransactions) * 10000) / 100
      }))
      .sort((a, b) => b.count - a.count)
      .slice(0, 5);

    // æ—¶é—´åˆ†å¸ƒç»Ÿè®¡
    const hourlyDistribution: Record<number, number> = {};
    transactions.forEach((tx: any) => {
      if (tx.timestamp) {
        const hour = new Date(tx.timestamp).getHours();
        hourlyDistribution[hour] = (hourlyDistribution[hour] || 0) + 1;
      }
    });

    return {
      totalTransactions,
      successRate: Math.round(successRate * 100) / 100,
      averageGas,
      topFunctions,
      hourlyDistribution
    };

  } catch (error: any) {
    throw new Error(`Analysis failed: ${error.message}`);
  }
}

// æµ‹è¯•
async function test() {
  try {
    const analysis = await analyzeTransactionPatterns(
      'https://indexer.testnet.aptoslabs.com/v1/graphql',
      '0x1',
      50
    );

    console.log('äº¤æ˜“æ¨¡å¼åˆ†æç»“æœ:');
    console.log('================');
    console.log(`æ€»äº¤æ˜“æ•°: ${analysis.totalTransactions}`);
    console.log(`æˆåŠŸç‡: ${analysis.successRate}%`);
    console.log(`å¹³å‡ Gas: ${analysis.averageGas}`);
    console.log('\næœ€å¸¸è°ƒç”¨çš„å‡½æ•°:');
    analysis.topFunctions.forEach((func, i) => {
      console.log(`${i + 1}. ${func.function}`);
      console.log(`   è°ƒç”¨æ¬¡æ•°: ${func.count} (${func.percentage}%)`);
    });
    console.log('\næ¯å°æ—¶äº¤æ˜“åˆ†å¸ƒ:');
    Object.entries(analysis.hourlyDistribution)
      .sort(([a], [b]) => parseInt(a) - parseInt(b))
      .forEach(([hour, count]) => {
        console.log(`${hour.padStart(2, '0')}:00 - ${count} ç¬”`);
      });
  } catch (error) {
    console.error('åˆ†æå¤±è´¥:', error);
  }
}

test();
```

**è¯„åˆ†ç‚¹**:
- âœ… æ•°æ®æŸ¥è¯¢æ­£ç¡®ï¼ˆ5åˆ†ï¼‰
- âœ… ç»Ÿè®¡è®¡ç®—å‡†ç¡®ï¼ˆ8åˆ†ï¼‰
- âœ… æ•°æ®ç»“æ„è®¾è®¡åˆç†ï¼ˆ4åˆ†ï¼‰
- âœ… ä»£ç è´¨é‡è‰¯å¥½ï¼ˆ3åˆ†ï¼‰

---

## ğŸ“Š è¯„åˆ†ç»Ÿè®¡

### æ€»åˆ†è®¡ç®—
- é€‰æ‹©é¢˜ï¼š40åˆ†
- ç¼–ç¨‹é¢˜1ï¼š20åˆ†
- ç¼–ç¨‹é¢˜2ï¼š20åˆ†
- ç¼–ç¨‹é¢˜3ï¼š20åˆ†
- **æ€»è®¡ï¼š100åˆ†**

### ç­‰çº§åˆ’åˆ†
- **ä¼˜ç§€ï¼ˆ90-100åˆ†ï¼‰**: å…¨é¢æŒæ¡ Indexer å’Œ GraphQL
- **è‰¯å¥½ï¼ˆ80-89åˆ†ï¼‰**: è¾ƒå¥½æŒæ¡æ ¸å¿ƒæ¦‚å¿µ
- **åŠæ ¼ï¼ˆ70-79åˆ†ï¼‰**: åŸºæœ¬æŒæ¡å¿…è¦çŸ¥è¯†
- **éœ€è¦å¤ä¹ ï¼ˆ<70åˆ†ï¼‰**: å»ºè®®é‡æ–°å­¦ä¹ 

---

## ğŸ’¡ å¸¸è§é”™è¯¯åˆ†æ

### é€‰æ‹©é¢˜å¸¸è§é”™è¯¯

1. **æ··æ·† Processor çš„ç±»å‹**
   - è®°ä½ï¼šCoinï¼ˆä»£å¸ï¼‰ã€Tokenï¼ˆNFTï¼‰ã€Eventï¼ˆäº‹ä»¶ï¼‰å„æœ‰ä¸“é—¨çš„ Processor

2. **GraphQL è¯­æ³•é”™è¯¯**
   - å˜é‡å‰éœ€è¦ $ ç¬¦å·
   - ! è¡¨ç¤ºå¿…éœ€å‚æ•°
   - åˆ«åä½¿ç”¨å†’å· `:`

3. **æ•°æ®å»¶è¿Ÿä¼°è®¡ä¸å‡†ç¡®**
   - Indexer ä¸æ˜¯å®æ—¶çš„ï¼Œæœ‰ 400-500ms å»¶è¿Ÿ

### ç¼–ç¨‹é¢˜å¸¸è§é”™è¯¯

1. **æœªå¤„ç† GraphQL é”™è¯¯**
   ```typescript
   // âŒ é”™è¯¯
   const data = response.data.data;
   
   // âœ… æ­£ç¡®
   if (response.data.errors) {
     throw new Error('GraphQL errors');
   }
   const data = response.data.data;
   ```

2. **WebSocket é‡è¿é€»è¾‘ç¼ºå¤±**
   - å¿…é¡»å®ç°æŒ‡æ•°é€€é¿é‡è¿
   - è®¾ç½®æœ€å¤§é‡è¿æ¬¡æ•°

3. **æ•°æ®æ ¼å¼åŒ–ä¸å®Œæ•´**
   - ç¡®ä¿æ‰€æœ‰å­—æ®µéƒ½è¢«æ­£ç¡®æå–
   - å¤„ç†å¯èƒ½ä¸º null çš„å­—æ®µ

---

**å¦‚æœå¾—åˆ† < 70 åˆ†ï¼Œå»ºè®®é‡æ–°å­¦ä¹ ç†è®ºéƒ¨åˆ†å¹¶é‡åšç»ƒä¹ ï¼**

# Day 14 æ¯æ—¥è€ƒè¯•ï¼šç­”æ¡ˆè§£æ

---

## ç¼–ç¨‹é¢˜ç­”æ¡ˆ

### ç¬¬ä¸€é¢˜ï¼šé™é¢é“¸é€ ç³»ç»Ÿ - å®Œæ•´ç­”æ¡ˆ

```move
module token_exam::limited_mint {
    use std::signer;
    use aptos_framework::coin::{Self, MintCapability};
    use aptos_framework::timestamp;

    struct LimitedCoin {}

    struct MintLimits has key {
        mint_cap: MintCapability<LimitedCoin>,
        
        daily_limit: u64,
        minted_today: u64,
        last_daily_reset: u64,
        
        monthly_limit: u64,
        minted_this_month: u64,
        last_monthly_reset: u64,
    }

    const ERROR_NOT_ADMIN: u64 = 1;
    const ERROR_EXCEED_DAILY_LIMIT: u64 = 2;
    const ERROR_EXCEED_MONTHLY_LIMIT: u64 = 3;

    const DECIMALS: u64 = 100000000;
    const SECONDS_PER_DAY: u64 = 86400;
    const SECONDS_PER_MONTH: u64 = 2592000;  // 30 å¤©

    /// ç­”æ¡ˆ 1: åˆå§‹åŒ–å‡½æ•°
    fun init_module(account: &signer) {
        let (burn_cap, freeze_cap, mint_cap) = coin::initialize<LimitedCoin>(
            account,
            string::utf8(b"Limited Coin"),
            string::utf8(b"LMT"),
            8,
            true,
        );

        // é”€æ¯ä¸éœ€è¦çš„æƒé™
        coin::destroy_burn_cap(burn_cap);
        coin::destroy_freeze_cap(freeze_cap);

        let now = timestamp::now_seconds();

        move_to(account, MintLimits {
            mint_cap,
            daily_limit: 100000 * DECIMALS,      // 100,000
            minted_today: 0,
            last_daily_reset: now,
            monthly_limit: 2000000 * DECIMALS,   // 2,000,000
            minted_this_month: 0,
            last_monthly_reset: now,
        });
    }

    /// ç­”æ¡ˆ 2: é™é¢æ£€æŸ¥å’Œé‡ç½®
    fun check_and_reset_limits(limits: &mut MintLimits) {
        let now = timestamp::now_seconds();
        
        // æ£€æŸ¥æ—¥é™é¢é‡ç½®
        let current_day = now / SECONDS_PER_DAY;
        let last_day = limits.last_daily_reset / SECONDS_PER_DAY;
        
        if (current_day > last_day) {
            limits.minted_today = 0;
            limits.last_daily_reset = now;
        };
        
        // æ£€æŸ¥æœˆé™é¢é‡ç½®
        let current_month = now / SECONDS_PER_MONTH;
        let last_month = limits.last_monthly_reset / SECONDS_PER_MONTH;
        
        if (current_month > last_month) {
            limits.minted_this_month = 0;
            limits.last_monthly_reset = now;
        };
    }

    /// ç­”æ¡ˆ 3: é™é¢é“¸é€ 
    public entry fun mint_with_limits(
        admin: &signer,
        recipient: address,
        amount: u64
    ) acquires MintLimits {
        // 1. éªŒè¯æƒé™
        assert!(signer::address_of(admin) == @token_exam, ERROR_NOT_ADMIN);
        
        // 2. è·å–å¹¶æ£€æŸ¥é™é¢
        let limits = borrow_global_mut<MintLimits>(@token_exam);
        check_and_reset_limits(limits);
        
        // 3. æ£€æŸ¥æ—¥é™é¢
        assert!(
            limits.minted_today + amount <= limits.daily_limit,
            ERROR_EXCEED_DAILY_LIMIT
        );
        
        // 4. æ£€æŸ¥æœˆé™é¢
        assert!(
            limits.minted_this_month + amount <= limits.monthly_limit,
            ERROR_EXCEED_MONTHLY_LIMIT
        );
        
        // 5. é“¸é€ 
        let coins = coin::mint(amount, &limits.mint_cap);
        coin::deposit(recipient, coins);
        
        // 6. æ›´æ–°ç»Ÿè®¡
        limits.minted_today = limits.minted_today + amount;
        limits.minted_this_month = limits.minted_this_month + amount;
    }

    /// ç­”æ¡ˆ 4: æŸ¥è¯¢å‡½æ•°
    #[view]
    public fun get_remaining_daily_quota(): u64 acquires MintLimits {
        let limits = borrow_global<MintLimits>(@token_exam);
        limits.daily_limit - limits.minted_today
    }

    #[view]
    public fun get_remaining_monthly_quota(): u64 acquires MintLimits {
        let limits = borrow_global<MintLimits>(@token_exam);
        limits.monthly_limit - limits.minted_this_month
    }

    #[view]
    public fun get_minted_today(): u64 acquires MintLimits {
        borrow_global<MintLimits>(@token_exam).minted_today
    }

    #[view]
    public fun get_minted_this_month(): u64 acquires MintLimits {
        borrow_global<MintLimits>(@token_exam).minted_this_month
    }
}
```

**å…³é”®ç‚¹è§£æ**ï¼š
1. **æ—¶é—´é‡ç½®è®¡ç®—**ï¼šä½¿ç”¨æ•´é™¤ç®—æ³•ï¼ˆ`now / SECONDS_PER_DAY`ï¼‰è®¡ç®—å¤©æ•°ï¼Œæ¯”è¾ƒæ˜¯å¦å˜åŒ–
2. **åŒé‡é™é¢æ£€æŸ¥**ï¼šå¿…é¡»åŒæ—¶æ»¡è¶³æ—¥é™é¢å’Œæœˆé™é¢
3. **åŸå­æ€§æ›´æ–°**ï¼šå…ˆæ£€æŸ¥æ‰€æœ‰æ¡ä»¶ï¼Œæœ€åä¸€æ¬¡æ€§æ›´æ–°ç»Ÿè®¡æ•°æ®
4. **æŸ¥è¯¢å‡½æ•°**ï¼šæä¾›å¤šä¸ªè§†å›¾å‡½æ•°æ–¹ä¾¿ç›‘æ§

---

### ç¬¬äºŒé¢˜ï¼šé˜¶æ¢¯é”€æ¯ç‡è½¬è´¦ç³»ç»Ÿ - å®Œæ•´ç­”æ¡ˆ

```move
module token_exam::tiered_burn {
    use std::signer;
    use std::string::{Self, String};
    use aptos_std::table::{Self, Table};
    use aptos_framework::coin::{Self, Coin, BurnCapability};
    use aptos_framework::event::{Self, EventHandle};
    use aptos_framework::account;
    use aptos_framework::timestamp;

    struct TieredCoin {}

    const TIER1_THRESHOLD: u64 = 1000 * 100000000;
    const TIER2_THRESHOLD: u64 = 10000 * 100000000;
    const TIER3_THRESHOLD: u64 = 100000 * 100000000;

    const TIER1_RATE: u64 = 50;
    const TIER2_RATE: u64 = 100;
    const TIER3_RATE: u64 = 150;
    const TIER4_RATE: u64 = 200;

    const BASIS_POINTS: u64 = 10000;

    const ERROR_NOT_ADMIN: u64 = 1;

    struct BurnConfig has key {
        burn_cap: BurnCapability<TieredCoin>,
        
        tier1_burned: u64,
        tier2_burned: u64,
        tier3_burned: u64,
        tier4_burned: u64,
        
        vip_users: Table<address, bool>,
        burn_events: EventHandle<BurnEvent>,
    }

    struct BurnEvent has drop, store {
        from: address,
        to: address,
        total_amount: u64,
        burned_amount: u64,
        burn_rate: u64,
        tier: u8,
        timestamp: u64,
    }

    fun init_module(account: &signer) {
        let (burn_cap, freeze_cap, mint_cap) = coin::initialize<TieredCoin>(
            account,
            string::utf8(b"Tiered Burn Coin"),
            string::utf8(b"TBC"),
            8,
            true,
        );

        coin::destroy_freeze_cap(freeze_cap);
        coin::destroy_mint_cap(mint_cap);

        move_to(account, BurnConfig {
            burn_cap,
            tier1_burned: 0,
            tier2_burned: 0,
            tier3_burned: 0,
            tier4_burned: 0,
            vip_users: table::new(),
            burn_events: account::new_event_handle<BurnEvent>(account),
        });
    }

    /// ç­”æ¡ˆ 1: è®¡ç®—é”€æ¯ç‡
    fun calculate_burn_rate(amount: u64, is_vip: bool): (u64, u8) {
        let (base_rate, tier) = if (amount <= TIER1_THRESHOLD) {
            (TIER1_RATE, 1)
        } else if (amount <= TIER2_THRESHOLD) {
            (TIER2_RATE, 2)
        } else if (amount <= TIER3_THRESHOLD) {
            (TIER3_RATE, 3)
        } else {
            (TIER4_RATE, 4)
        };

        // VIP äº«å— 50% æŠ˜æ‰£
        let final_rate = if (is_vip) {
            base_rate / 2
        } else {
            base_rate
        };

        (final_rate, tier)
    }

    /// ç­”æ¡ˆ 2: å¸¦é”€æ¯çš„è½¬è´¦
    public entry fun transfer_with_tiered_burn(
        from: &signer,
        to: address,
        amount: u64
    ) acquires BurnConfig {
        let from_addr = signer::address_of(from);
        let config = borrow_global_mut<BurnConfig>(@token_exam);
        
        // æ£€æŸ¥æ˜¯å¦æ˜¯ VIP
        let is_vip = table::contains(&config.vip_users, from_addr);
        
        // è®¡ç®—é”€æ¯ç‡å’ŒåŒºé—´
        let (burn_rate, tier) = calculate_burn_rate(amount, is_vip);
        
        // è®¡ç®—é”€æ¯æ•°é‡
        let burn_amount = (amount * burn_rate) / BASIS_POINTS;
        let transfer_amount = amount - burn_amount;
        
        // æå–ä»£å¸
        let all_coins = coin::withdraw<TieredCoin>(from, amount);
        
        // åˆ†ç¦»é”€æ¯éƒ¨åˆ†
        let burn_coins = coin::extract(&mut all_coins, burn_amount);
        
        // æ‰§è¡Œé”€æ¯
        coin::burn(burn_coins, &config.burn_cap);
        
        // æ›´æ–°å¯¹åº”åŒºé—´ç»Ÿè®¡
        if (tier == 1) {
            config.tier1_burned = config.tier1_burned + burn_amount;
        } else if (tier == 2) {
            config.tier2_burned = config.tier2_burned + burn_amount;
        } else if (tier == 3) {
            config.tier3_burned = config.tier3_burned + burn_amount;
        } else {
            config.tier4_burned = config.tier4_burned + burn_amount;
        };
        
        // è½¬è´¦å‰©ä½™
        coin::deposit(to, all_coins);
        
        // å‘å°„äº‹ä»¶
        event::emit_event(&mut config.burn_events, BurnEvent {
            from: from_addr,
            to,
            total_amount: amount,
            burned_amount: burn_amount,
            burn_rate,
            tier,
            timestamp: timestamp::now_seconds(),
        });
    }

    /// ç­”æ¡ˆ 3: VIP ç®¡ç†
    public entry fun add_vip(admin: &signer, user: address) acquires BurnConfig {
        assert!(signer::address_of(admin) == @token_exam, ERROR_NOT_ADMIN);
        let config = borrow_global_mut<BurnConfig>(@token_exam);
        
        if (!table::contains(&config.vip_users, user)) {
            table::add(&mut config.vip_users, user, true);
        };
    }

    public entry fun remove_vip(admin: &signer, user: address) acquires BurnConfig {
        assert!(signer::address_of(admin) == @token_exam, ERROR_NOT_ADMIN);
        let config = borrow_global_mut<BurnConfig>(@token_exam);
        
        if (table::contains(&config.vip_users, user)) {
            table::remove(&mut config.vip_users, user);
        };
    }

    /// ç­”æ¡ˆ 4: ç»Ÿè®¡æŸ¥è¯¢
    #[view]
    public fun get_tier_stats(): (u64, u64, u64, u64) acquires BurnConfig {
        let config = borrow_global<BurnConfig>(@token_exam);
        (
            config.tier1_burned,
            config.tier2_burned,
            config.tier3_burned,
            config.tier4_burned
        )
    }

    #[view]
    public fun is_vip(user: address): bool acquires BurnConfig {
        let config = borrow_global<BurnConfig>(@token_exam);
        table::contains(&config.vip_users, user)
    }

    #[view]
    public fun calculate_burn_preview(
        user: address,
        amount: u64
    ): (u64, u64, u8) acquires BurnConfig {
        let config = borrow_global<BurnConfig>(@token_exam);
        let is_vip = table::contains(&config.vip_users, user);
        
        let (burn_rate, tier) = calculate_burn_rate(amount, is_vip);
        let burn_amount = (amount * burn_rate) / BASIS_POINTS;
        let transfer_amount = amount - burn_amount;
        
        (burn_amount, transfer_amount, tier)
    }
}
```

**å…³é”®ç‚¹è§£æ**ï¼š
1. **é˜¶æ¢¯è®¡ç®—**ï¼šä½¿ç”¨ if-else é“¾æ ¹æ®é‡‘é¢ç¡®å®šåŒºé—´
2. **VIP æŠ˜æ‰£**ï¼šåœ¨åŸºç¡€è´¹ç‡ä¸Šç›´æ¥å‡åŠ
3. **ç²¾ç¡®åˆ†ç±»ç»Ÿè®¡**ï¼šæ ¹æ® tier æ›´æ–°å¯¹åº”çš„ç´¯è®¡é”€æ¯é‡
4. **é¢„è§ˆåŠŸèƒ½**ï¼šå…è®¸ç”¨æˆ·åœ¨è½¬è´¦å‰æŸ¥çœ‹é”€æ¯è¯¦æƒ…

---

### ç¬¬ä¸‰é¢˜ï¼šé«˜çº§å¤šç­¾åæƒé™ç®¡ç†ç³»ç»Ÿ - å®Œæ•´ç­”æ¡ˆ

```move
module token_exam::advanced_multisig {
    use std::signer;
    use std::string::{Self, String};
    use std::vector;
    use aptos_std::table::{Self, Table};
    use aptos_framework::coin::{Self, MintCapability, FreezeCapability};
    use aptos_framework::timestamp;

    struct MultiSigCoin {}

    const OPERATION_MINT: u8 = 1;
    const OPERATION_FREEZE: u8 = 2;
    const OPERATION_CONFIG: u8 = 3;

    const PROPOSAL_EXPIRY: u64 = 604800;

    const ERROR_NOT_SIGNER: u64 = 1;
    const ERROR_ALREADY_SIGNED: u64 = 2;
    const ERROR_NOT_SIGNED: u64 = 3;
    const ERROR_ALREADY_EXECUTED: u64 = 4;
    const ERROR_EXPIRED: u64 = 5;
    const ERROR_INSUFFICIENT_SIGNATURES: u64 = 6;
    const ERROR_INVALID_PROPOSAL: u64 = 7;

    struct MultiSigManager has key {
        signers: vector<address>,
        
        mint_required_sigs: u64,
        freeze_required_sigs: u64,
        config_required_sigs: u64,
        
        proposals: Table<u64, Proposal>,
        next_proposal_id: u64,
        
        mint_cap: MintCapability<MultiSigCoin>,
        freeze_cap: FreezeCapability<MultiSigCoin>,
    }

    struct Proposal has store {
        operation_type: u8,
        proposer: address,
        created_at: u64,
        executed: bool,
        
        signatures: vector<address>,
        
        target_address: address,
        amount: u64,
        description: String,
    }

    fun init_module(account: &signer) {
        let (burn_cap, freeze_cap, mint_cap) = coin::initialize<MultiSigCoin>(
            account,
            string::utf8(b"MultiSig Coin"),
            string::utf8(b"MSC"),
            8,
            true,
        );

        coin::destroy_burn_cap(burn_cap);

        let admin_addr = signer::address_of(account);

        move_to(account, MultiSigManager {
            signers: vector[admin_addr],
            mint_required_sigs: 3,
            freeze_required_sigs: 2,
            config_required_sigs: 4,
            proposals: table::new(),
            next_proposal_id: 0,
            mint_cap,
            freeze_cap,
        });
    }

    /// ç­”æ¡ˆ 1: åˆ›å»ºææ¡ˆ
    public entry fun create_proposal(
        proposer: &signer,
        operation_type: u8,
        target_address: address,
        amount: u64,
        description: vector<u8>
    ) acquires MultiSigManager {
        let manager = borrow_global_mut<MultiSigManager>(@token_exam);
        let proposer_addr = signer::address_of(proposer);
        
        // éªŒè¯æ˜¯ç­¾åè€…
        assert!(vector::contains(&manager.signers, &proposer_addr), ERROR_NOT_SIGNER);
        
        // åˆ›å»ºææ¡ˆ
        let proposal_id = manager.next_proposal_id;
        table::add(&mut manager.proposals, proposal_id, Proposal {
            operation_type,
            proposer: proposer_addr,
            created_at: timestamp::now_seconds(),
            executed: false,
            signatures: vector[proposer_addr],  // è‡ªåŠ¨ç­¾å
            target_address,
            amount,
            description: string::utf8(description),
        });
        
        manager.next_proposal_id = proposal_id + 1;
    }

    /// ç­”æ¡ˆ 2: ç­¾åææ¡ˆ
    public entry fun sign_proposal(
        signer_account: &signer,
        proposal_id: u64
    ) acquires MultiSigManager {
        let manager = borrow_global_mut<MultiSigManager>(@token_exam);
        
        assert!(table::contains(&manager.proposals, proposal_id), ERROR_INVALID_PROPOSAL);
        let proposal = table::borrow_mut(&mut manager.proposals, proposal_id);
        
        let signer_addr = signer::address_of(signer_account);
        
        // éªŒè¯
        assert!(vector::contains(&manager.signers, &signer_addr), ERROR_NOT_SIGNER);
        assert!(!proposal.executed, ERROR_ALREADY_EXECUTED);
        assert!(!is_proposal_expired(proposal), ERROR_EXPIRED);
        assert!(!vector::contains(&proposal.signatures, &signer_addr), ERROR_ALREADY_SIGNED);
        
        // æ·»åŠ ç­¾å
        vector::push_back(&mut proposal.signatures, signer_addr);
    }

    /// æ’¤é”€ç­¾å
    public entry fun revoke_signature(
        signer_account: &signer,
        proposal_id: u64
    ) acquires MultiSigManager {
        let manager = borrow_global_mut<MultiSigManager>(@token_exam);
        
        assert!(table::contains(&manager.proposals, proposal_id), ERROR_INVALID_PROPOSAL);
        let proposal = table::borrow_mut(&mut manager.proposals, proposal_id);
        
        let signer_addr = signer::address_of(signer_account);
        
        // éªŒè¯
        assert!(!proposal.executed, ERROR_ALREADY_EXECUTED);
        assert!(vector::contains(&proposal.signatures, &signer_addr), ERROR_NOT_SIGNED);
        
        // ç§»é™¤ç­¾å
        let (found, index) = vector::index_of(&proposal.signatures, &signer_addr);
        if (found) {
            vector::remove(&mut proposal.signatures, index);
        };
    }

    /// ç­”æ¡ˆ 3: æ‰§è¡Œææ¡ˆ
    public entry fun execute_proposal(
        executor: &signer,
        proposal_id: u64
    ) acquires MultiSigManager {
        let manager = borrow_global_mut<MultiSigManager>(@token_exam);
        
        assert!(table::contains(&manager.proposals, proposal_id), ERROR_INVALID_PROPOSAL);
        let proposal = table::borrow_mut(&mut manager.proposals, proposal_id);
        
        // æ£€æŸ¥çŠ¶æ€
        assert!(!proposal.executed, ERROR_ALREADY_EXECUTED);
        assert!(!is_proposal_expired(proposal), ERROR_EXPIRED);
        
        // æ£€æŸ¥ç­¾åæ•°é‡
        let required = get_required_signatures(manager, proposal.operation_type);
        assert!(
            vector::length(&proposal.signatures) >= required,
            ERROR_INSUFFICIENT_SIGNATURES
        );
        
        // æ‰§è¡Œæ“ä½œ
        execute_operation(manager, proposal);
        
        // æ ‡è®°ä¸ºå·²æ‰§è¡Œ
        proposal.executed = true;
    }

    /// ç­”æ¡ˆ 4: è¾…åŠ©å‡½æ•°
    fun is_proposal_expired(proposal: &Proposal): bool {
        let now = timestamp::now_seconds();
        now > proposal.created_at + PROPOSAL_EXPIRY
    }

    fun get_required_signatures(
        manager: &MultiSigManager,
        operation_type: u8
    ): u64 {
        if (operation_type == OPERATION_MINT) {
            manager.mint_required_sigs
        } else if (operation_type == OPERATION_FREEZE) {
            manager.freeze_required_sigs
        } else if (operation_type == OPERATION_CONFIG) {
            manager.config_required_sigs
        } else {
            0
        }
    }

    fun execute_operation(manager: &mut MultiSigManager, proposal: &Proposal) {
        if (proposal.operation_type == OPERATION_MINT) {
            // é“¸é€ ä»£å¸
            let coins = coin::mint(proposal.amount, &manager.mint_cap);
            coin::deposit(proposal.target_address, coins);
        } else if (proposal.operation_type == OPERATION_FREEZE) {
            // å†»ç»“è´¦æˆ·
            coin::freeze_coin_store<MultiSigCoin>(
                proposal.target_address,
                &manager.freeze_cap
            );
        } else if (proposal.operation_type == OPERATION_CONFIG) {
            // ä¿®æ”¹é…ç½®ï¼ˆå¦‚ä¿®æ”¹ç­¾åè¦æ±‚ï¼‰
            // è¿™é‡Œç®€åŒ–ä¸ºä¿®æ”¹é“¸é€ ç­¾åè¦æ±‚
            manager.mint_required_sigs = proposal.amount;
        };
    }

    #[view]
    public fun get_proposal_status(
        proposal_id: u64
    ): (u8, u64, bool, bool) acquires MultiSigManager {
        let manager = borrow_global<MultiSigManager>(@token_exam);
        assert!(table::contains(&manager.proposals, proposal_id), ERROR_INVALID_PROPOSAL);
        
        let proposal = table::borrow(&manager.proposals, proposal_id);
        (
            proposal.operation_type,
            vector::length(&proposal.signatures),
            proposal.executed,
            is_proposal_expired(proposal)
        )
    }

    // ç®¡ç†å‡½æ•°
    public entry fun add_signer(admin: &signer, new_signer: address) 
    acquires MultiSigManager {
        let manager = borrow_global_mut<MultiSigManager>(@token_exam);
        if (!vector::contains(&manager.signers, &new_signer)) {
            vector::push_back(&mut manager.signers, new_signer);
        };
    }
}
```

**å…³é”®ç‚¹è§£æ**ï¼š
1. **æ“ä½œç±»å‹åŒºåˆ†**ï¼šä¸åŒæ“ä½œæœ‰ä¸åŒçš„ç­¾åè¦æ±‚
2. **è¿‡æœŸæœºåˆ¶**ï¼šææ¡ˆåˆ›å»ºå 7 å¤©è‡ªåŠ¨è¿‡æœŸ
3. **æ’¤é”€åŠŸèƒ½**ï¼šå…è®¸ç­¾åè€…åœ¨æ‰§è¡Œå‰æ’¤å›ç­¾å
4. **çµæ´»æ‰§è¡Œ**ï¼šæ ¹æ® operation_type è°ƒç”¨ä¸åŒçš„æƒé™

---

## é€‰æ‹©é¢˜é‡ç‚¹è§£æ

### æ¡ˆä¾‹åˆ†æé¢˜è¯¦è§£

**æ¡ˆä¾‹ 1ï¼šæƒé™é›†ä¸­é£é™©**
- **é—®é¢˜**ï¼šæ‰€æœ‰æƒé™å­˜å‚¨åœ¨åŒä¸€ä¸ªç»“æ„ä½“
- **é£é™©**ï¼šå•ç‚¹æ•…éšœï¼Œä¸€æ—¦è¢«æ”»ç ´ï¼Œæ‰€æœ‰æƒé™æ²¦é™·
- **è§£å†³æ–¹æ¡ˆ**ï¼š
  ```move
  // åˆ†ç¦»å­˜å‚¨
  struct MintCapStore has key { mint_cap: MintCapability<MyCoin> }
  struct BurnCapStore has key { burn_cap: BurnCapability<MyCoin> }
  struct FreezeCapStore has key { freeze_cap: FreezeCapability<MyCoin> }
  
  // å­˜å‚¨åˆ°ä¸åŒè´¦æˆ·
  move_to(&mint_admin, MintCapStore { mint_cap });
  move_to(&burn_admin, BurnCapStore { burn_cap });
  move_to(&compliance_admin, FreezeCapStore { freeze_cap });
  ```

**æ¡ˆä¾‹ 2ï¼šé“¸é€ é™é¢ç»•è¿‡**
- **æ”»å‡»æ‰‹æ³•**ï¼šåˆ©ç”¨æ¯æ—¥é‡ç½®æœºåˆ¶ï¼Œåœ¨åˆå¤œå‰åå„é“¸é€ ä¸€æ¬¡
- **é˜²èŒƒæªæ–½**ï¼š
  1. æ·»åŠ æœˆé™é¢æˆ–æ€»é™é¢
  2. æ·»åŠ é“¸é€ é—´éš”æ—¶é—´ï¼ˆå¦‚æ¯æ¬¡é“¸é€ è‡³å°‘é—´éš” 1 å°æ—¶ï¼‰
  3. å®æ–½å¤šç­¾åæ§åˆ¶
  4. æ·»åŠ å¼‚å¸¸æ£€æµ‹ï¼ˆçŸ­æ—¶é—´å†…å¤šæ¬¡é“¸é€ ï¼‰

**æ¡ˆä¾‹ 3ï¼šå†»ç»“æƒé™æ»¥ç”¨**
- **æœ€ä½³æ–¹æ¡ˆ**ï¼šå¤šç­¾åæ§åˆ¶
- **å®ç°**ï¼š
  ```move
  public entry fun freeze_account_multisig(
      proposal_id: u64
  ) acquires MultiSigManager, FreezeCapStore {
      // 1. éªŒè¯å¤šç­¾åææ¡ˆå·²é€šè¿‡
      verify_multisig_approval(proposal_id);
      
      // 2. æ‰§è¡Œå†»ç»“
      let freeze_store = borrow_global<FreezeCapStore>(@admin);
      coin::freeze_coin_store(target_address, &freeze_store.freeze_cap);
  }
  ```

---

## æ€»ç»“ä¸å»ºè®®

### æ ¸å¿ƒçŸ¥è¯†ç‚¹
1. **æƒé™èƒ½åŠ›ç³»ç»Ÿ**ï¼šMintCapabilityã€BurnCapabilityã€FreezeCapability
2. **é™é¢æ§åˆ¶**ï¼šæ—¥é™é¢ã€æœˆé™é¢ã€é‡ç½®æœºåˆ¶
3. **å¤šç­¾åç³»ç»Ÿ**ï¼šææ¡ˆã€ç­¾åã€æ‰§è¡Œæµç¨‹
4. **æ—¶é—´é”**ï¼šå»¶è¿Ÿæ‰§è¡Œã€å®‰å…¨ç¼“å†²
5. **é€šç¼©/é€šèƒ€**ï¼šé”€æ¯ç‡ã€é“¸é€ ç‡ã€ç»æµæ¨¡å‹

### å¸¸è§é”™è¯¯
1. âŒ å¿˜è®°é‡ç½®é™é¢
2. âŒ æƒé™éªŒè¯ä¸å……åˆ†
3. âŒ æ²¡æœ‰æ£€æŸ¥ææ¡ˆè¿‡æœŸ
4. âŒ æ•´æ•°æº¢å‡ºï¼ˆåº”ä½¿ç”¨ u128 æˆ–æ£€æŸ¥ï¼‰
5. âŒ äº‹ä»¶æ•°æ®ä¸å®Œæ•´

### æœ€ä½³å®è·µ
âœ… æƒé™åˆ†ç¦»å­˜å‚¨  
âœ… å¤šç­¾åæ§åˆ¶å…³é”®æ“ä½œ  
âœ… æ·»åŠ æ—¶é—´é”ä¿æŠ¤  
âœ… å®Œæ•´çš„äº‹ä»¶è®°å½•  
âœ… å……åˆ†çš„å‚æ•°éªŒè¯  
âœ… æä¾›æŸ¥è¯¢è§†å›¾å‡½æ•°  

æ­å–œå®Œæˆ Day 14 çš„å­¦ä¹ ï¼ğŸ‰

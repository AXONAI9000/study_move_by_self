# ç®€å• DEX - æµåŠ¨æ€§æ± æ ¸å¿ƒæ¦‚å¿µ

## ğŸ“š ç›®å½•

1. [æµåŠ¨æ€§æ± æ¶æ„](#1-æµåŠ¨æ€§æ± æ¶æ„)
2. [LP Token è®¾è®¡](#2-lp-token-è®¾è®¡)
3. [æµåŠ¨æ€§æ·»åŠ æœºåˆ¶](#3-æµåŠ¨æ€§æ·»åŠ æœºåˆ¶)
4. [æµåŠ¨æ€§ç§»é™¤æœºåˆ¶](#4-æµåŠ¨æ€§ç§»é™¤æœºåˆ¶)
5. [æ± å­æ³¨å†Œä¸ç®¡ç†](#5-æ± å­æ³¨å†Œä¸ç®¡ç†)
6. [å®‰å…¨æ€§è®¾è®¡](#6-å®‰å…¨æ€§è®¾è®¡)
7. [æŸ¥è¯¢æ¥å£è®¾è®¡](#7-æŸ¥è¯¢æ¥å£è®¾è®¡)
8. [å®é™…åº”ç”¨æ¡ˆä¾‹](#8-å®é™…åº”ç”¨æ¡ˆä¾‹)

---

## 1. æµåŠ¨æ€§æ± æ¶æ„

### 1.1 æ•´ä½“æ¶æ„

ä¸€ä¸ªå®Œæ•´çš„æµåŠ¨æ€§æ± ç³»ç»Ÿç”±ä»¥ä¸‹ç»„ä»¶æ„æˆï¼š

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚          Pool Registry (æ³¨å†Œè¡¨)               â”‚
â”‚  â€¢ ç®¡ç†æ‰€æœ‰æ± å­                               â”‚
â”‚  â€¢ é˜²æ­¢é‡å¤åˆ›å»º                               â”‚
â”‚  â€¢ æä¾›æ± å­æŸ¥æ‰¾                               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â”‚
                    â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         Liquidity Pool (æµåŠ¨æ€§æ± )            â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ State:                                 â”‚ â”‚
â”‚  â”‚ â€¢ reserve_x: Coin<X>                   â”‚ â”‚
â”‚  â”‚ â€¢ reserve_y: Coin<Y>                   â”‚ â”‚
â”‚  â”‚ â€¢ lp_total_supply: u64                 â”‚ â”‚
â”‚  â”‚ â€¢ locked_liquidity: u64                â”‚ â”‚
â”‚  â”‚ â€¢ fee_x, fee_y: u64                    â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                              â”‚
â”‚  Operations:                                 â”‚
â”‚  â€¢ add_liquidity_initial()                  â”‚
â”‚  â€¢ add_liquidity()                          â”‚
â”‚  â€¢ remove_liquidity()                       â”‚
â”‚  â€¢ swap() [ä¸‹èŠ‚è¯¾]                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â”‚
                    â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚           LP Token (æµåŠ¨æ€§å‡­è¯)              â”‚
â”‚  â€¢ åŸºäº Aptos Coin æ¡†æ¶                      â”‚
â”‚  â€¢ å¯è½¬è®©ã€å¯äº¤æ˜“                            â”‚
â”‚  â€¢ ä»£è¡¨æ± å­ä»½é¢                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 1.2 æ•°æ®ç»“æ„è®¾è®¡

#### 1.2.1 æµåŠ¨æ€§æ± ç»“æ„

```move
/// æµåŠ¨æ€§æ± 
/// æ³›å‹å‚æ•°å¿…é¡»æœ‰åºï¼šç¡®ä¿ type_of<X>() < type_of<Y>()
struct LiquidityPool<phantom X, phantom Y> has key {
    /// ä»£å¸ X å‚¨å¤‡
    reserve_x: Coin<X>,
    
    /// ä»£å¸ Y å‚¨å¤‡
    reserve_y: Coin<Y>,
    
    /// LP Token æ€»ä¾›åº”é‡
    lp_total_supply: u64,
    
    /// é”å®šçš„æœ€å°æµåŠ¨æ€§ï¼ˆæ°¸ä¹…é”å®šï¼Œé˜²æ­¢ä»·æ ¼æ“çºµï¼‰
    locked_liquidity: u64,
    
    /// ç´¯è®¡æ‰‹ç»­è´¹ Xï¼ˆç”¨äºç»Ÿè®¡ï¼‰
    fee_x_accumulated: u64,
    
    /// ç´¯è®¡æ‰‹ç»­è´¹ Yï¼ˆç”¨äºç»Ÿè®¡ï¼‰
    fee_y_accumulated: u64,
    
    /// LP Token é“¸é€ èƒ½åŠ›
    lp_mint_cap: coin::MintCapability<LPCoin<X, Y>>,
    
    /// LP Token é”€æ¯èƒ½åŠ›
    lp_burn_cap: coin::BurnCapability<LPCoin<X, Y>>,
    
    /// åˆ›å»ºæ—¶é—´æˆ³
    created_at: u64,
    
    /// æœ€åæ›´æ–°æ—¶é—´
    last_update_time: u64,
    
    /// äº‹ä»¶å¥æŸ„
    add_liquidity_events: EventHandle<AddLiquidityEvent>,
    remove_liquidity_events: EventHandle<RemoveLiquidityEvent>,
}
```

#### 1.2.2 LP Token å®šä¹‰

```move
/// LP Token
/// ä½¿ç”¨ phantom ç±»å‹å‚æ•°æ ‡è¯†å¯¹åº”çš„äº¤æ˜“å¯¹
struct LPCoin<phantom X, phantom Y> {}
```

**ä¸ºä»€ä¹ˆä½¿ç”¨ phantomï¼Ÿ**
- LP Token ä¸éœ€è¦å­˜å‚¨ X å’Œ Y çš„å®ä¾‹
- åªéœ€è¦ç±»å‹ä¿¡æ¯æ¥æ ‡è¯†æ˜¯å“ªä¸ªæ± å­çš„ LP
- èŠ‚çœå­˜å‚¨ç©ºé—´

#### 1.2.3 æ± å­æ³¨å†Œè¡¨

```move
/// æ± å­æ³¨å†Œè¡¨ï¼ˆå…¨å±€å•ä¾‹ï¼‰
struct PoolRegistry has key {
    /// æ± å­æ˜ å°„ï¼š(TypeInfo<X>, TypeInfo<Y>) => address
    pools: Table<vector<u8>, address>,
    
    /// æ± å­æ•°é‡
    pool_count: u64,
    
    /// åˆ›å»ºæ± å­äº‹ä»¶
    create_pool_events: EventHandle<CreatePoolEvent>,
}
```

### 1.3 ä¸ºä»€ä¹ˆéœ€è¦æ³¨å†Œè¡¨ï¼Ÿ

**é—®é¢˜**ï¼šå¦‚ä½•æ‰¾åˆ°ä¸€ä¸ªäº¤æ˜“å¯¹çš„æ± å­åœ°å€ï¼Ÿ

**æ–¹æ¡ˆ 1ï¼šå›ºå®šåœ°å€**
```move
// âŒ ä¸çµæ´»ï¼Œéœ€è¦é¢„å…ˆåˆ†é…åœ°å€
let pool_addr = @0x123;
```

**æ–¹æ¡ˆ 2ï¼šç”¨æˆ·è´¦æˆ·**
```move
// âŒ è°çš„è´¦æˆ·ï¼Ÿç¬¬ä¸€ä¸ªåˆ›å»ºè€…ï¼Ÿ
let pool_addr = signer::address_of(creator);
```

**æ–¹æ¡ˆ 3ï¼šæ³¨å†Œè¡¨ï¼ˆâœ… æ¨èï¼‰**
```move
// âœ… ä¸­å¤®æ³¨å†Œï¼Œç»Ÿä¸€ç®¡ç†
let pool_addr = registry::get_pool_address<X, Y>();
```

**æ³¨å†Œè¡¨çš„ä¼˜åŠ¿**ï¼š
1. ç»Ÿä¸€æŸ¥æ‰¾å…¥å£
2. é˜²æ­¢é‡å¤åˆ›å»º
3. ä¾¿äºæšä¸¾æ‰€æœ‰æ± å­
4. æ”¯æŒæ²»ç†å’Œå‡çº§

---

## 2. LP Token è®¾è®¡

### 2.1 ä¸ºä»€ä¹ˆä½¿ç”¨ Coin æ¡†æ¶ï¼Ÿ

Aptos æä¾›äº†æ ‡å‡†çš„ Coin æ¡†æ¶ï¼Œæˆ‘ä»¬ç›´æ¥å¤ç”¨ï¼š

**ä¼˜åŠ¿**ï¼š
1. âœ… è‡ªåŠ¨è·å¾—è½¬è´¦åŠŸèƒ½
2. âœ… é’±åŒ…è‡ªåŠ¨æ”¯æŒ
3. âœ… å¯ç”¨äºå…¶ä»– DeFi åè®®
4. âœ… å‡å°‘å¼€å‘å’Œå®¡è®¡æˆæœ¬

**å¯¹æ¯”è‡ªå®šä¹‰å®ç°**ï¼š

```move
// âŒ è‡ªå®šä¹‰ LP Token
struct LPToken has store {
    amount: u64,
}

struct LPBalance has key {
    tokens: LPToken,
}

// éœ€è¦è‡ªå·±å®ç°è½¬è´¦
public fun transfer(from: &signer, to: address, amount: u64) {
    // æ‰‹åŠ¨å®ç°...
}

// âœ… ä½¿ç”¨ Coin æ¡†æ¶
struct LPCoin<phantom X, phantom Y> {}

// è‡ªåŠ¨è·å¾—æ‰€æœ‰ Coin åŠŸèƒ½
coin::transfer<LPCoin<X, Y>>(from, to, amount);
coin::balance<LPCoin<X, Y>>(addr);
coin::register<LPCoin<X, Y>>(user);
```

### 2.2 LP Token åˆå§‹åŒ–

```move
/// åˆå§‹åŒ– LP Tokenï¼ˆåˆ›å»ºæ± å­æ—¶è°ƒç”¨ï¼‰
fun initialize_lp_coin<X, Y>(creator: &signer): (
    coin::MintCapability<LPCoin<X, Y>>,
    coin::BurnCapability<LPCoin<X, Y>>,
) {
    // ç”Ÿæˆ LP Token åç§°
    let name = string::utf8(b"LP-");
    string::append(&mut name, coin::name<X>());
    string::append_utf8(&mut name, b"-");
    string::append(&mut name, coin::name<Y>());
    
    // ç”Ÿæˆç¬¦å·
    let symbol = string::utf8(b"LP");
    
    // åˆå§‹åŒ– Coin
    let (burn_cap, freeze_cap, mint_cap) = coin::initialize<LPCoin<X, Y>>(
        creator,
        name,
        symbol,
        8,  // decimals
        true,  // monitor_supply
    );
    
    // é”€æ¯ freeze_capï¼ˆæˆ‘ä»¬ä¸éœ€è¦å†»ç»“åŠŸèƒ½ï¼‰
    coin::destroy_freeze_cap(freeze_cap);
    
    (mint_cap, burn_cap)
}
```

### 2.3 LP Token é“¸é€ å’Œé”€æ¯

```move
/// é“¸é€  LP Token
fun mint_lp<X, Y>(
    mint_cap: &coin::MintCapability<LPCoin<X, Y>>,
    amount: u64,
): Coin<LPCoin<X, Y>> {
    coin::mint(amount, mint_cap)
}

/// é”€æ¯ LP Token
fun burn_lp<X, Y>(
    burn_cap: &coin::BurnCapability<LPCoin<X, Y>>,
    lp_coins: Coin<LPCoin<X, Y>>,
) {
    coin::burn(lp_coins, burn_cap)
}
```

### 2.4 LP Token ä»·å€¼è®¡ç®—

LP Token çš„ä»·å€¼å–å†³äºæ± å­ä¸­çš„èµ„äº§ï¼š

```
LP Token ä»·å€¼ = (å‚¨å¤‡ X ä»·å€¼ + å‚¨å¤‡ Y ä»·å€¼) / LP æ€»é‡
```

**ç¤ºä¾‹**ï¼š

```
æ± å­çŠ¶æ€ï¼š
- 10,000 APTOS @ $10 = $100,000
- 100,000 USDC = $100,000
- æ€»ä»·å€¼ = $200,000
- LP æ€»é‡ = 31,623

æ¯ä¸ª LP ä»·å€¼ = $200,000 / 31,623 â‰ˆ $6.32
```

**èµå›æ¯”ä¾‹**ï¼š

```
æŒæœ‰ 1,000 LPï¼š
ä»½é¢ = 1,000 / 31,623 = 3.16%

å¯èµå›ï¼š
- APTOS: 10,000 * 3.16% = 316 APTOS
- USDC: 100,000 * 3.16% = 3,160 USDC
```

---

## 3. æµåŠ¨æ€§æ·»åŠ æœºåˆ¶

### 3.1 é¦–æ¬¡æ·»åŠ æµåŠ¨æ€§

é¦–æ¬¡æ·»åŠ æµåŠ¨æ€§æ¯”è¾ƒç‰¹æ®Šï¼Œå› ä¸ºï¼š
1. æ²¡æœ‰ç°æœ‰æ¯”ä¾‹é™åˆ¶
2. æä¾›è€…å†³å®šåˆå§‹ä»·æ ¼
3. éœ€è¦é”å®šæœ€å°æµåŠ¨æ€§

#### 3.1.1 æµç¨‹å›¾

```
ç”¨æˆ·å‘èµ·æ·»åŠ 
    â”‚
    â–¼
éªŒè¯æ± å­ä¸ºç©º
    â”‚
    â–¼
æå–ç”¨æˆ·ä»£å¸
    â”‚
    â–¼
è®¡ç®— LP = sqrt(x * y)
    â”‚
    â–¼
é”å®šæœ€å°æµåŠ¨æ€§
    â”‚
    â–¼
é“¸é€  LP Token
    â”‚
    â–¼
å­˜å…¥æ± å­å‚¨å¤‡
    â”‚
    â–¼
åˆ†é… LP ç»™ç”¨æˆ·
    â”‚
    â–¼
å‘å°„äº‹ä»¶
```

#### 3.1.2 ä»£ç å®ç°

```move
public entry fun add_liquidity_initial<X, Y>(
    provider: &signer,
    amount_x: u64,
    amount_y: u64,
) acquires LiquidityPool {
    // 1. éªŒè¯è¾“å…¥
    assert!(amount_x > 0 && amount_y > 0, ERROR_ZERO_AMOUNT);
    
    // 2. è·å–æ± å­
    let pool_addr = get_pool_address<X, Y>();
    let pool = borrow_global_mut<LiquidityPool<X, Y>>(pool_addr);
    
    // 3. ç¡®ä¿æ˜¯é¦–æ¬¡æ·»åŠ 
    assert!(pool.lp_total_supply == 0, ERROR_POOL_NOT_EMPTY);
    
    // 4. æå–ä»£å¸
    let coin_x = coin::withdraw<X>(provider, amount_x);
    let coin_y = coin::withdraw<Y>(provider, amount_y);
    
    // 5. è®¡ç®—åˆå§‹ LP
    let lp_amount = sqrt((amount_x as u128) * (amount_y as u128));
    assert!(lp_amount > MINIMUM_LIQUIDITY, ERROR_INSUFFICIENT_LIQUIDITY);
    
    // 6. é”å®šæœ€å°æµåŠ¨æ€§
    pool.locked_liquidity = MINIMUM_LIQUIDITY;
    let user_lp = lp_amount - MINIMUM_LIQUIDITY;
    
    // 7. é“¸é€  LP Token
    let lp_coins = coin::mint(user_lp, &pool.lp_mint_cap);
    
    // 8. æ›´æ–°æ± å­çŠ¶æ€
    coin::merge(&mut pool.reserve_x, coin_x);
    coin::merge(&mut pool.reserve_y, coin_y);
    pool.lp_total_supply = lp_amount;
    
    // 9. å­˜å…¥ç”¨æˆ·è´¦æˆ·
    if (!coin::is_account_registered<LPCoin<X, Y>>(provider_addr)) {
        coin::register<LPCoin<X, Y>>(provider);
    };
    coin::deposit(provider_addr, lp_coins);
    
    // 10. å‘å°„äº‹ä»¶
    event::emit_event(&mut pool.add_liquidity_events, AddLiquidityEvent {
        provider: provider_addr,
        amount_x,
        amount_y,
        lp_minted: user_lp,
    });
}
```

#### 3.1.3 ä¸ºä»€ä¹ˆé”å®šæœ€å°æµåŠ¨æ€§ï¼Ÿ

**é—®é¢˜åœºæ™¯**ï¼š

```
æ¶æ„ç”¨æˆ·æ·»åŠ æå°æµåŠ¨æ€§ï¼š
1 A + 1 B â†’ LP = sqrt(1) = 1

ç„¶åç«‹å³ç§»é™¤ï¼š
ç§»é™¤ 1 LP â†’ å–å› 1 A + 1 B

æ± å­å˜ç©ºï¼Œk = 0 * 0 = 0 âŒ
```

**è§£å†³æ–¹æ¡ˆ**ï¼š

```
æ·»åŠ æµåŠ¨æ€§ï¼š
1000 A + 1000 B â†’ LP = sqrt(1000000) â‰ˆ 1000

é”å®š 1000 LPï¼ˆæ°¸ä¹…ï¼‰
ç”¨æˆ·è·å¾— 0 LP âœ…

è¿™æ ·ç¡®ä¿æ± å­æ°¸è¿œæœ‰æœ€å°æµåŠ¨æ€§
```

### 3.2 åç»­æ·»åŠ æµåŠ¨æ€§

åç»­æ·»åŠ å¿…é¡»æŒ‰ç…§å½“å‰æ± å­æ¯”ä¾‹ï¼š

#### 3.2.1 ä¸ºä»€ä¹ˆå¿…é¡»æŒ‰æ¯”ä¾‹ï¼Ÿ

**é—®é¢˜**ï¼šå¦‚æœå…è®¸ä»»æ„æ¯”ä¾‹ä¼šæ€æ ·ï¼Ÿ

```
å½“å‰æ± å­ï¼š
- 10,000 APTOS
- 20,000 USDC
- ä»·æ ¼ = 2.0 USDC/APTOS

ç”¨æˆ·æ·»åŠ ï¼š
- 1,000 APTOS
- 1,000 USDCï¼ˆä¸ç¬¦åˆ 1:2 æ¯”ä¾‹ï¼‰

æ–°æ± å­ï¼š
- 11,000 APTOS
- 21,000 USDC
- ä»·æ ¼ = 1.91 USDC/APTOS âŒ ä»·æ ¼è¢«æ“çºµï¼

å¥—åˆ©è€…ç«‹å³ï¼š
- åœ¨æ± å­å†…ç”¨ USDC ä¹°å…¥ä¾¿å®œçš„ APTOS
- åœ¨å¤–éƒ¨å¸‚åœºå–å‡º
- ç”¨æˆ·æŸå¤±
```

**è§£å†³æ–¹æ¡ˆ**ï¼šå¼ºåˆ¶æŒ‰æ¯”ä¾‹

```
å½“å‰æ¯”ä¾‹ï¼š10,000 : 20,000 = 1 : 2

æ·»åŠ  1,000 APTOSï¼š
å¿…é¡»æ·»åŠ ï¼š(1,000 / 10,000) * 20,000 = 2,000 USDC âœ…

æ–°æ¯”ä¾‹ï¼š11,000 : 22,000 = 1 : 2 âœ… æ¯”ä¾‹ä¸å˜
```

#### 3.2.2 æœ€ä¼˜æ•°é‡è®¡ç®—

ç”¨æˆ·å¯èƒ½æä¾›æœŸæœ›æ•°é‡å’Œæœ€å°æ•°é‡ï¼š

```move
/// è®¡ç®—æœ€ä¼˜æ·»åŠ æ•°é‡
/// 
/// å‚æ•°ï¼š
///   - amount_x_desired: æœŸæœ›æ·»åŠ çš„ X
///   - amount_y_desired: æœŸæœ›æ·»åŠ çš„ Y
///   - amount_x_min: æœ€å°‘æ¥å—çš„ X
///   - amount_y_min: æœ€å°‘æ¥å—çš„ Y
///   - reserve_x: å½“å‰ X å‚¨å¤‡
///   - reserve_y: å½“å‰ Y å‚¨å¤‡
/// 
/// è¿”å›ï¼šå®é™…æ·»åŠ çš„ (amount_x, amount_y)
fun calculate_optimal_amounts(
    amount_x_desired: u64,
    amount_y_desired: u64,
    amount_x_min: u64,
    amount_y_min: u64,
    reserve_x: u64,
    reserve_y: u64,
): (u64, u64) {
    // æ ¹æ® amount_x_desired è®¡ç®—æ‰€éœ€çš„ y
    let amount_y_optimal = quote(amount_x_desired, reserve_x, reserve_y);
    
    if (amount_y_optimal <= amount_y_desired) {
        // Y å¤Ÿç”¨
        assert!(amount_y_optimal >= amount_y_min, ERROR_INSUFFICIENT_Y_AMOUNT);
        (amount_x_desired, amount_y_optimal)
    } else {
        // Y ä¸å¤Ÿï¼Œç”¨ Y è®¡ç®— X
        let amount_x_optimal = quote(amount_y_desired, reserve_y, reserve_x);
        assert!(amount_x_optimal >= amount_x_min, ERROR_INSUFFICIENT_X_AMOUNT);
        assert!(amount_x_optimal <= amount_x_desired, ERROR_INVALID_RATIO);
        (amount_x_optimal, amount_y_desired)
    }
}

/// æ ¹æ®ä¸€ä¸ªæ•°é‡è®¡ç®—å¦ä¸€ä¸ªæ•°é‡
/// amount_b = (amount_a / reserve_a) * reserve_b
fun quote(amount_a: u64, reserve_a: u64, reserve_b: u64): u64 {
    assert!(amount_a > 0, ERROR_ZERO_AMOUNT);
    assert!(reserve_a > 0 && reserve_b > 0, ERROR_INSUFFICIENT_LIQUIDITY);
    
    ((amount_a as u128) * (reserve_b as u128) / (reserve_a as u128) as u64)
}
```

#### 3.2.3 LP Token é“¸é€ é‡è®¡ç®—

```move
/// è®¡ç®—åº”è¯¥é“¸é€ çš„ LP Token æ•°é‡
/// 
/// LP = min(
///     (amount_x / reserve_x) * total_supply,
///     (amount_y / reserve_y) * total_supply
/// )
fun calculate_lp_amount(
    amount_x: u64,
    amount_y: u64,
    reserve_x: u64,
    reserve_y: u64,
    total_supply: u64,
): u64 {
    let lp_from_x = ((amount_x as u128) * (total_supply as u128) 
        / (reserve_x as u128) as u64);
    let lp_from_y = ((amount_y as u128) * (total_supply as u128) 
        / (reserve_y as u128) as u64);
    
    // å–è¾ƒå°å€¼ï¼Œç¡®ä¿æ¯”ä¾‹æ­£ç¡®
    if (lp_from_x < lp_from_y) { lp_from_x } else { lp_from_y }
}
```

**ä¸ºä»€ä¹ˆå– minï¼Ÿ**

```
ç¤ºä¾‹ï¼š
reserve_x = 10,000, reserve_y = 20,000
total_supply = 14,142

æ·»åŠ ï¼š1,000 X + 2,001 Yï¼ˆç•¥å¤šäºæ¯”ä¾‹ï¼‰

lp_from_x = (1,000 / 10,000) * 14,142 = 1,414.2
lp_from_y = (2,001 / 20,000) * 14,142 = 1,415.3

å– min(1,414.2, 1,415.3) = 1,414.2 âœ…

è¿™æ ·ç¡®ä¿ç”¨æˆ·ä¸ä¼šå› ä¸ºæä¾›ç•¥å¤šçš„ä»£å¸è€Œè·å¾—é¢å¤– LP
å¤šä½™çš„ 1 Y ä¼šè¢«é€€å›
```

### 3.3 å®Œæ•´æ·»åŠ æµç¨‹

```move
public entry fun add_liquidity<X, Y>(
    provider: &signer,
    amount_x_desired: u64,
    amount_y_desired: u64,
    amount_x_min: u64,
    amount_y_min: u64,
) acquires LiquidityPool {
    let provider_addr = signer::address_of(provider);
    let pool_addr = get_pool_address<X, Y>();
    let pool = borrow_global_mut<LiquidityPool<X, Y>>(pool_addr);
    
    // 1. è·å–å‚¨å¤‡
    let reserve_x = coin::value(&pool.reserve_x);
    let reserve_y = coin::value(&pool.reserve_y);
    
    // 2. è®¡ç®—æœ€ä¼˜æ•°é‡
    let (amount_x, amount_y) = calculate_optimal_amounts(
        amount_x_desired,
        amount_y_desired,
        amount_x_min,
        amount_y_min,
        reserve_x,
        reserve_y,
    );
    
    // 3. æå–ä»£å¸
    let coin_x = coin::withdraw<X>(provider, amount_x);
    let coin_y = coin::withdraw<Y>(provider, amount_y);
    
    // 4. è®¡ç®— LP
    let lp_amount = calculate_lp_amount(
        amount_x,
        amount_y,
        reserve_x,
        reserve_y,
        pool.lp_total_supply,
    );
    
    // 5. é“¸é€  LP
    let lp_coins = coin::mint(lp_amount, &pool.lp_mint_cap);
    
    // 6. æ›´æ–°æ± å­
    coin::merge(&mut pool.reserve_x, coin_x);
    coin::merge(&mut pool.reserve_y, coin_y);
    pool.lp_total_supply = pool.lp_total_supply + lp_amount;
    
    // 7. åˆ†é… LP
    if (!coin::is_account_registered<LPCoin<X, Y>>(provider_addr)) {
        coin::register<LPCoin<X, Y>>(provider);
    };
    coin::deposit(provider_addr, lp_coins);
    
    // 8. å‘å°„äº‹ä»¶
    event::emit_event(&mut pool.add_liquidity_events, AddLiquidityEvent {
        provider: provider_addr,
        amount_x,
        amount_y,
        lp_minted: lp_amount,
    });
}
```

---

## 4. æµåŠ¨æ€§ç§»é™¤æœºåˆ¶

### 4.1 ç§»é™¤æµç¨‹

```
ç”¨æˆ·å‘èµ·ç§»é™¤
    â”‚
    â–¼
éªŒè¯ LP ä½™é¢
    â”‚
    â–¼
æå– LP Token
    â”‚
    â–¼
è®¡ç®—åº”è¿”è¿˜çš„ä»£å¸
    â”‚
    â–¼
ä»æ± å­æå–ä»£å¸
    â”‚
    â–¼
é”€æ¯ LP Token
    â”‚
    â–¼
è¿”è¿˜ä»£å¸ç»™ç”¨æˆ·
    â”‚
    â–¼
æ›´æ–°æ± å­çŠ¶æ€
    â”‚
    â–¼
å‘å°„äº‹ä»¶
```

### 4.2 è¿”è¿˜æ•°é‡è®¡ç®—

```move
/// è®¡ç®—ç§»é™¤æµåŠ¨æ€§æ—¶è¿”è¿˜çš„ä»£å¸æ•°é‡
/// 
/// amount_x = (lp_amount / total_supply) * reserve_x
/// amount_y = (lp_amount / total_supply) * reserve_y
fun calculate_remove_amounts(
    lp_amount: u64,
    reserve_x: u64,
    reserve_y: u64,
    total_supply: u64,
): (u64, u64) {
    let amount_x = ((lp_amount as u128) * (reserve_x as u128) 
        / (total_supply as u128) as u64);
    let amount_y = ((lp_amount as u128) * (reserve_y as u128) 
        / (total_supply as u128) as u64);
    
    (amount_x, amount_y)
}
```

### 4.3 å®Œæ•´ç§»é™¤å®ç°

```move
public entry fun remove_liquidity<X, Y>(
    provider: &signer,
    lp_amount: u64,
    amount_x_min: u64,
    amount_y_min: u64,
) acquires LiquidityPool {
    assert!(lp_amount > 0, ERROR_ZERO_AMOUNT);
    
    let provider_addr = signer::address_of(provider);
    let pool_addr = get_pool_address<X, Y>();
    let pool = borrow_global_mut<LiquidityPool<X, Y>>(pool_addr);
    
    // 1. è·å–å‚¨å¤‡
    let reserve_x = coin::value(&pool.reserve_x);
    let reserve_y = coin::value(&pool.reserve_y);
    
    // 2. è®¡ç®—è¿”è¿˜æ•°é‡
    let (amount_x, amount_y) = calculate_remove_amounts(
        lp_amount,
        reserve_x,
        reserve_y,
        pool.lp_total_supply,
    );
    
    // 3. æ»‘ç‚¹ä¿æŠ¤
    assert!(amount_x >= amount_x_min, ERROR_INSUFFICIENT_X_AMOUNT);
    assert!(amount_y >= amount_y_min, ERROR_INSUFFICIENT_Y_AMOUNT);
    
    // 4. æå– LP Token
    let lp_coins = coin::withdraw<LPCoin<X, Y>>(provider, lp_amount);
    
    // 5. æå–ä»£å¸
    let coin_x = coin::extract(&mut pool.reserve_x, amount_x);
    let coin_y = coin::extract(&mut pool.reserve_y, amount_y);
    
    // 6. é”€æ¯ LP
    coin::burn(lp_coins, &pool.lp_burn_cap);
    
    // 7. è¿”è¿˜ä»£å¸
    coin::deposit(provider_addr, coin_x);
    coin::deposit(provider_addr, coin_y);
    
    // 8. æ›´æ–°çŠ¶æ€
    pool.lp_total_supply = pool.lp_total_supply - lp_amount);
    
    // 9. å‘å°„äº‹ä»¶
    event::emit_event(&mut pool.remove_liquidity_events, RemoveLiquidityEvent {
        provider: provider_addr,
        lp_burned: lp_amount,
        amount_x,
        amount_y,
    });
}
```

### 4.4 æ»‘ç‚¹ä¿æŠ¤

**ä¸ºä»€ä¹ˆéœ€è¦ï¼Ÿ**

```
ç”¨æˆ·æŸ¥è¯¢å½“å‰çŠ¶æ€ï¼š
- LP: 1,000
- å¯èµå›ï¼š100 APTOS + 200 USDC

ç”¨æˆ·æäº¤äº¤æ˜“...

åœ¨äº¤æ˜“è¢«å¤„ç†å‰ï¼Œæœ‰äººè¿›è¡Œäº†å¤§é¢äº¤æ¢ï¼š
- æ± å­æ¯”ä¾‹æ”¹å˜
- ç°åœ¨å¯èµå›ï¼š95 APTOS + 210 USDC

ç”¨æˆ·å¯èƒ½ä¸æ¥å—è¿™ä¸ªç»“æœ âŒ
```

**è§£å†³æ–¹æ¡ˆ**ï¼š

```move
// ç”¨æˆ·è®¾ç½®æœ€å°æ¥å—é‡
let min_aptos = 95;  // æœ€å°‘æ¥å— 95 APTOS
let min_usdc = 200;  // æœ€å°‘æ¥å— 200 USDC

remove_liquidity<APTOS, USDC>(
    provider,
    1000,
    min_aptos,
    min_usdc,
);
```

---

## 5. æ± å­æ³¨å†Œä¸ç®¡ç†

### 5.1 ä¸ºä»€ä¹ˆéœ€è¦ç±»å‹æ’åºï¼Ÿ

**é—®é¢˜**ï¼š`Pool<APTOS, USDC>` å’Œ `Pool<USDC, APTOS>` æ˜¯ä¸åŒç±»å‹ï¼

```move
// è¿™æ˜¯ä¸¤ä¸ªå®Œå…¨ä¸åŒçš„ç±»å‹
struct Pool<X, Y> {}

Pool<APTOS, USDC>  // ç±»å‹ 1
Pool<USDC, APTOS>  // ç±»å‹ 2
```

**åæœ**ï¼š
- å¯èƒ½åˆ›å»ºä¸¤ä¸ªæ± å­
- æµåŠ¨æ€§åˆ†æ•£
- ç”¨æˆ·å›°æƒ‘

**è§£å†³æ–¹æ¡ˆ**ï¼šç±»å‹æ’åº

```move
/// ç¡®ä¿ç±»å‹æœ‰åº
fun ensure_ordered<X, Y>() {
    let x_type = type_info::type_of<X>();
    let y_type = type_info::type_of<Y>();
    
    assert!(
        compare(&x_type, &y_type) == LESS_THAN,
        ERROR_INVALID_TYPE_ORDER
    );
}

/// åˆ›å»ºæ± å­æ—¶éªŒè¯
public entry fun create_pool<X, Y>(creator: &signer) {
    ensure_ordered<X, Y>();
    // ...
}
```

### 5.2 æ± å­æ³¨å†Œè¡¨å®ç°

```move
/// åˆå§‹åŒ–æ³¨å†Œè¡¨ï¼ˆéƒ¨ç½²æ—¶è°ƒç”¨ä¸€æ¬¡ï¼‰
fun init_registry(deployer: &signer) {
    move_to(deployer, PoolRegistry {
        pools: table::new(),
        pool_count: 0,
        create_pool_events: account::new_event_handle(deployer),
    });
}

/// æ³¨å†Œæ± å­
fun register_pool<X, Y>(pool_address: address) acquires PoolRegistry {
    let registry = borrow_global_mut<PoolRegistry>(@deployer);
    
    // ç”Ÿæˆé”®
    let key = generate_pool_key<X, Y>();
    
    // æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨
    assert!(!table::contains(&registry.pools, key), ERROR_POOL_EXISTS);
    
    // æ³¨å†Œ
    table::add(&mut registry.pools, key, pool_address);
    registry.pool_count = registry.pool_count + 1;
}

/// æŸ¥æ‰¾æ± å­
public fun get_pool_address<X, Y>(): address acquires PoolRegistry {
    let registry = borrow_global<PoolRegistry>(@deployer);
    let key = generate_pool_key<X, Y>();
    
    assert!(table::contains(&registry.pools, key), ERROR_POOL_NOT_EXISTS);
    *table::borrow(&registry.pools, key)
}

/// ç”Ÿæˆæ± å­é”®ï¼ˆä½¿ç”¨ç±»å‹åç§°ï¼‰
fun generate_pool_key<X, Y>(): vector<u8> {
    let x_name = type_info::type_name<X>();
    let y_name = type_info::type_name<Y>();
    
    // ç»„åˆç±»å‹åç§°
    let key = *string::bytes(&x_name);
    vector::append(&mut key, b"::");
    vector::append(&mut key, *string::bytes(&y_name));
    
    key
}
```

---

## 6. å®‰å…¨æ€§è®¾è®¡

### 6.1 é‡å…¥æ”»å‡»é˜²æŠ¤

**Move çš„ä¼˜åŠ¿**ï¼šèµ„æºæ‰€æœ‰æƒæ¨¡å‹å¤©ç„¶é˜²æ­¢é‡å…¥

```move
// âœ… Move ä¸­è¿™æ ·çš„æ”»å‡»ä¸å¯èƒ½
public fun vulnerable_withdraw(pool: &mut Pool, amount: u64) {
    // æå–ä»£å¸
    let coins = coin::extract(&mut pool.reserve, amount);
    
    // åœ¨è¿™é‡Œï¼Œå¦‚æœè°ƒç”¨å¤–éƒ¨åˆçº¦...
    // å¤–éƒ¨åˆçº¦æ— æ³•å†æ¬¡è°ƒç”¨ vulnerable_withdraw
    // å› ä¸º pool çš„å¯å˜å¼•ç”¨å·²ç»è¢«å€Ÿç”¨
    
    // å­˜å…¥ç”¨æˆ·è´¦æˆ·
    coin::deposit(user, coins);
}
```

**ä»¥å¤ªåŠä¸­çš„é—®é¢˜**ï¼š

```solidity
// âŒ ä»¥å¤ªåŠä¸­å®¹æ˜“å—åˆ°é‡å…¥æ”»å‡»
function withdraw(uint amount) public {
    // å…ˆè½¬è´¦
    payable(msg.sender).call{value: amount}("");
    
    // åæ›´æ–°ä½™é¢ï¼ˆå±é™©ï¼ï¼‰
    balance[msg.sender] -= amount;
}
```

### 6.2 æ•´æ•°æº¢å‡ºä¿æŠ¤

**Move çš„ä¼˜åŠ¿**ï¼šè‡ªåŠ¨æ£€æŸ¥æº¢å‡º

```move
// âœ… è‡ªåŠ¨æ£€æŸ¥ï¼Œæº¢å‡ºæ—¶ abort
let sum = a + b;  // å¦‚æœæº¢å‡ºï¼Œäº¤æ˜“å¤±è´¥

// æ‰‹åŠ¨ä½¿ç”¨æ›´å¤§ç±»å‹
let sum = (a as u128) + (b as u128);  // ä¸ä¼šæº¢å‡º
```

### 6.3 è®¿é—®æ§åˆ¶

```move
/// åªæœ‰æ± å­æ‰€æœ‰è€…å¯ä»¥è°ƒç”¨çš„å‡½æ•°ï¼ˆç¤ºä¾‹ï¼‰
public entry fun set_fee_rate<X, Y>(
    owner: &signer,
    new_rate: u64,
) acquires LiquidityPool {
    let pool = borrow_global_mut<LiquidityPool<X, Y>>(@pool_address);
    
    // éªŒè¯æ‰€æœ‰è€…
    assert!(signer::address_of(owner) == pool.owner, ERROR_NOT_OWNER);
    
    // éªŒè¯è´¹ç‡èŒƒå›´
    assert!(new_rate <= MAX_FEE_RATE, ERROR_INVALID_FEE_RATE);
    
    pool.fee_rate = new_rate;
}
```

### 6.4 ç´§æ€¥æš‚åœæœºåˆ¶

```move
/// æ± å­çŠ¶æ€
struct LiquidityPool<X, Y> has key {
    // ... å…¶ä»–å­—æ®µ
    
    /// æ˜¯å¦æš‚åœ
    is_paused: bool,
    
    /// æš‚åœæ—¶é—´
    paused_at: u64,
}

/// æš‚åœæ± å­
public entry fun pause<X, Y>(admin: &signer) acquires LiquidityPool {
    assert!(signer::address_of(admin) == @admin, ERROR_NOT_ADMIN);
    
    let pool = borrow_global_mut<LiquidityPool<X, Y>>(@pool_address);
    pool.is_paused = true;
    pool.paused_at = timestamp::now_seconds();
}

/// æ¢å¤æ± å­
public entry fun unpause<X, Y>(admin: &signer) acquires LiquidityPool {
    assert!(signer::address_of(admin) == @admin, ERROR_NOT_ADMIN);
    
    let pool = borrow_global_mut<LiquidityPool<X, Y>>(@pool_address);
    pool.is_paused = false;
}

/// æ£€æŸ¥æ˜¯å¦æš‚åœ
fun assert_not_paused<X, Y>(pool: &LiquidityPool<X, Y>) {
    assert!(!pool.is_paused, ERROR_POOL_PAUSED);
}
```

---

## 7. æŸ¥è¯¢æ¥å£è®¾è®¡

### 7.1 åªè¯»æŸ¥è¯¢

ä½¿ç”¨ `#[view]` å±æ€§æ ‡è®°ï¼š

```move
/// è·å–å‚¨å¤‡ä¿¡æ¯
#[view]
public fun get_reserves<X, Y>(): (u64, u64, u64) acquires LiquidityPool {
    let pool = borrow_global<LiquidityPool<X, Y>>(get_pool_address<X, Y>());
    (
        coin::value(&pool.reserve_x),
        coin::value(&pool.reserve_y),
        pool.lp_total_supply
    )
}

/// è·å–æ± å­ç»Ÿè®¡
#[view]
public fun get_pool_stats<X, Y>(): PoolStats acquires LiquidityPool {
    let pool = borrow_global<LiquidityPool<X, Y>>(get_pool_address<X, Y>());
    
    PoolStats {
        reserve_x: coin::value(&pool.reserve_x),
        reserve_y: coin::value(&pool.reserve_y),
        lp_total_supply: pool.lp_total_supply,
        fee_x_accumulated: pool.fee_x_accumulated,
        fee_y_accumulated: pool.fee_y_accumulated,
        created_at: pool.created_at,
        last_update_time: pool.last_update_time,
    }
}

/// è·å–ç”¨æˆ· LP ä½™é¢
#[view]
public fun get_lp_balance<X, Y>(user: address): u64 {
    coin::balance<LPCoin<X, Y>>(user)
}

/// è®¡ç®—æ·»åŠ æµåŠ¨æ€§èƒ½è·å¾—çš„ LP
#[view]
public fun quote_add_liquidity<X, Y>(
    amount_x: u64,
    amount_y: u64,
): u64 acquires LiquidityPool {
    let pool = borrow_global<LiquidityPool<X, Y>>(get_pool_address<X, Y>());
    let reserve_x = coin::value(&pool.reserve_x);
    let reserve_y = coin::value(&pool.reserve_y);
    
    calculate_lp_amount(amount_x, amount_y, reserve_x, reserve_y, pool.lp_total_supply)
}

/// è®¡ç®—ç§»é™¤æµåŠ¨æ€§èƒ½è·å¾—çš„ä»£å¸
#[view]
public fun quote_remove_liquidity<X, Y>(lp_amount: u64): (u64, u64) acquires LiquidityPool {
    let pool = borrow_global<LiquidityPool<X, Y>>(get_pool_address<X, Y>());
    let reserve_x = coin::value(&pool.reserve_x);
    let reserve_y = coin::value(&pool.reserve_y);
    
    calculate_remove_amounts(lp_amount, reserve_x, reserve_y, pool.lp_total_supply)
}
```

### 7.2 æ‰¹é‡æŸ¥è¯¢

```move
/// è·å–å¤šä¸ªæ± å­çš„ä¿¡æ¯
#[view]
public fun get_multiple_pool_stats(pool_types: vector<vector<u8>>): vector<PoolStats> {
    let result = vector::empty();
    let i = 0;
    let len = vector::length(&pool_types);
    
    while (i < len) {
        let pool_type = *vector::borrow(&pool_types, i);
        // è§£æç±»å‹å¹¶è·å–ç»Ÿè®¡...
        i = i + 1;
    };
    
    result
}
```

---

## 8. å®é™…åº”ç”¨æ¡ˆä¾‹

### 8.1 æ¡ˆä¾‹ 1ï¼šåˆ›å»º APTOS/USDC æ± å­

```move
// 1. éƒ¨ç½²åˆçº¦
aptos move publish

// 2. åˆ›å»ºæ± å­
aptos move run \
  --function-id 'deployer::liquidity_pool::create_pool' \
  --type-args '0x1::aptos_coin::AptosCoin' '0x1::usdc::USDC'

// 3. æ·»åŠ åˆå§‹æµåŠ¨æ€§
aptos move run \
  --function-id 'deployer::liquidity_pool::add_liquidity_initial' \
  --type-args '0x1::aptos_coin::AptosCoin' '0x1::usdc::USDC' \
  --args u64:100000000000 u64:1000000000000  // 1000 APTOS + 10000 USDC
```

### 8.2 æ¡ˆä¾‹ 2ï¼šLP æŒ–çŸ¿

ç”¨æˆ·å¯ä»¥å°† LP Token è´¨æŠ¼åˆ°å†œåœºåˆçº¦èµšå–å¥–åŠ±ï¼š

```move
/// ç®€åŒ–çš„å†œåœºåˆçº¦
module farm {
    struct Farm<phantom LPCoin> has key {
        staked_lp: Coin<LPCoin>,
        reward_per_second: u64,
        // ...
    }
    
    /// è´¨æŠ¼ LP
    public entry fun stake<LPCoin>(
        user: &signer,
        amount: u64,
    ) {
        let lp_coins = coin::withdraw<LPCoin>(user, amount);
        // å­˜å…¥å†œåœº...
    }
    
    /// é¢†å–å¥–åŠ±
    public entry fun claim_rewards<LPCoin>(user: &signer) {
        // è®¡ç®—å¥–åŠ±...
        // å‘æ”¾å¥–åŠ±...
    }
}
```

### 8.3 æ¡ˆä¾‹ 3ï¼šLP Token ä½œä¸ºæŠµæŠ¼å“

```move
/// LP Token å¯ä»¥ç”¨ä½œè´·æ¬¾æŠµæŠ¼å“
module lending {
    /// æŠµæŠ¼ LP å€Ÿæ¬¾
    public entry fun borrow_with_lp<LPCoin, BorrowCoin>(
        borrower: &signer,
        lp_amount: u64,
        borrow_amount: u64,
    ) {
        // 1. è½¬ç§» LP Token ä½œä¸ºæŠµæŠ¼
        let lp_coins = coin::withdraw<LPCoin>(borrower, lp_amount);
        
        // 2. è®¡ç®— LP ä»·å€¼
        let lp_value = calculate_lp_value<LPCoin>(lp_amount);
        
        // 3. æ£€æŸ¥æŠµæŠ¼ç‡
        let ltv = (borrow_amount as u128) * 100 / (lp_value as u128);
        assert!(ltv <= MAX_LTV, ERROR_INSUFFICIENT_COLLATERAL);
        
        // 4. å‘æ”¾è´·æ¬¾
        let borrow_coins = mint_stable<BorrowCoin>(borrow_amount);
        coin::deposit(signer::address_of(borrower), borrow_coins);
        
        // 5. è®°å½•å€ºåŠ¡
        // ...
    }
}
```

---

## ğŸ“Š æ€§èƒ½ä¼˜åŒ–

### ä¼˜åŒ– 1ï¼šå‡å°‘å­˜å‚¨è¯»å†™

```move
// âŒ å¤šæ¬¡è¯»å–
let reserve_x = coin::value(&pool.reserve_x);
let reserve_y = coin::value(&pool.reserve_y);
// ... å…¶ä»–æ“ä½œ
let reserve_x2 = coin::value(&pool.reserve_x);  // é‡å¤è¯»å–

// âœ… ç¼“å­˜å€¼
let reserve_x = coin::value(&pool.reserve_x);
let reserve_y = coin::value(&pool.reserve_y);
// ä½¿ç”¨ç¼“å­˜çš„å€¼
```

### ä¼˜åŒ– 2ï¼šæ‰¹é‡æ“ä½œ

```move
/// æ‰¹é‡æ·»åŠ æµåŠ¨æ€§ï¼ˆèŠ‚çœ Gasï¼‰
public entry fun batch_add_liquidity<X, Y>(
    provider: &signer,
    amounts: vector<(u64, u64)>,
) {
    let i = 0;
    let len = vector::length(&amounts);
    
    while (i < len) {
        let (amount_x, amount_y) = *vector::borrow(&amounts, i);
        // æ·»åŠ æµåŠ¨æ€§...
        i = i + 1;
    };
}
```

---

## ğŸ¯ æ€»ç»“

### å…³é”®è¦ç‚¹

1. **æµåŠ¨æ€§æ± æ˜¯ DEX çš„æ ¸å¿ƒ**
   - å­˜å‚¨ä»£å¸å‚¨å¤‡
   - å‘è¡Œ LP Token
   - ç®¡ç†æµåŠ¨æ€§

2. **LP Token ä½¿ç”¨ Coin æ¡†æ¶**
   - å¤ç”¨æ ‡å‡†åŠŸèƒ½
   - é™ä½å¼€å‘æˆæœ¬
   - æé«˜å…¼å®¹æ€§

3. **æµåŠ¨æ€§æ“ä½œå¿…é¡»æŒ‰æ¯”ä¾‹**
   - é˜²æ­¢ä»·æ ¼æ“çºµ
   - ä¿æŠ¤ç°æœ‰ LP
   - ç»´æŒæ± å­å¹³è¡¡

4. **å®‰å…¨æ€§è‡³å…³é‡è¦**
   - é”å®šæœ€å°æµåŠ¨æ€§
   - æ»‘ç‚¹ä¿æŠ¤
   - è®¿é—®æ§åˆ¶

5. **æŸ¥è¯¢æ¥å£å¾ˆé‡è¦**
   - æ–¹ä¾¿å‰ç«¯é›†æˆ
   - æ”¯æŒæ•°æ®åˆ†æ
   - ä¾¿äºç›‘æ§

---

**æ­å–œï¼** ä½ å·²ç»æŒæ¡äº†æµåŠ¨æ€§æ± çš„æ ¸å¿ƒåŸç†ã€‚ç°åœ¨è®©æˆ‘ä»¬è¿›å…¥ä»£ç å®ç°ç¯èŠ‚ï¼ğŸ’ª

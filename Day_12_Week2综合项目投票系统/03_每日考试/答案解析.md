# Day 12 每日考试 - 答案解析

---

## 选择题答案（50 分）

### 第一部分：单选题（每题 2 分，共 20 分）

**1. C - SmartTable<u64, Proposal>**
- 解析：提案数量可能很大，且需要迭代功能，SmartTable 最合适。Table 不可迭代，vector 不适合大数据量。

**2. B - 基于实时代币余额的投票**
- 解析：攻击者可以通过闪电贷临时获得大量代币，投票后立即归还。快照机制可以防止这种攻击。

**3. C - Pending → Active → Succeeded → Executed**
- 解析：提案创建后处于待定状态，投票开始后变为活跃，投票结束后根据结果变为成功或失败，最后可以被执行。

**4. B - 使用 Table<address, bool> 记录是否已投票**
- 解析：Table 提供 O(1) 查询，是最高效的方法。vector 需要遍历，效率低。

**5. B - 确保有足够的参与度才能统计结果**
- 解析：法定人数确保投票有效性，防止少数人决定重要事项。例如需要至少 30% 的人参与。

**6. C - UserLoginEvent**
- 解析：用户登录是链下行为，不需要在链上投票系统中记录。

**7. B - 提供缓冲期，防止恶意快速执行**
- 解析：时间锁给社区时间反应和准备，防止恶意提案立即执行造成损失。

**8. B - aptos_framework::timestamp::now_seconds()**
- 解析：这是 Aptos 官方提供的获取时间戳的正确方法。

**9. B - 让不活跃用户也能参与治理**
- 解析：委托投票允许用户将投票权委托给信任的人，提高参与度。

**10. C - ERROR_ALREADY_VOTED**
- 解析：专门的错误码使错误信息更清晰，便于调试和用户理解。

---

### 第二部分：多选题（每题 3 分，共 15 分）

**11. ABCDE - 全选**
- 解析：这些都是提案的基本信息。ID 用于唯一标识，标题描述说明内容，时间控制投票期，提案人地址用于权限验证，统计数据用于判断结果。

**12. ABCE**
- 解析：
  - A: 快照防止闪电贷攻击 ✓
  - B: 合理期限防止操纵 ✓
  - C: 时间锁提供缓冲 ✓
  - D: 允许无限次投票是漏洞 ✗
  - E: 验证时间范围防止过期投票 ✓

**13. ABCE**
- 解析：
  - A: SmartTable 适合大数据 ✓
  - B: 批量处理减少交易次数 ✓
  - C: 维护累计值避免重复计算 ✓
  - D: String 和 vector<u8> Gas 成本相近 ✗
  - E: 减少状态访问降低成本 ✓

**14. ABCDE - 全选**
- 解析：每种投票权重机制都有其优缺点，理解它们的权衡很重要。

**15. ABCE**
- 解析：
  - A: 链下索引需要事件 ✓
  - B: 前端实时更新 ✓
  - C: 审计和分析 ✓
  - D: 事件会增加少量 Gas，但不是主要原因 ✗
  - E: 提高透明度 ✓

---

### 第三部分：判断题（每题 1 分，共 15 分）

**16. 错**
- 解析：Table 不支持遍历，只能随机访问。SmartTable 才能遍历。

**17. 错**
- 解析：应该有时间锁延迟，给社区反应时间。

**18. 对**
- 解析：`#[view]` 标记的函数是只读的，不能修改状态。

**19. 错**
- 解析：通常不允许更改投票，以防止操纵。如果需要，应该是撤销后重新投票。

**20. 错**
- 解析：SmartTable 的删除是 O(n)，因为需要维护键的列表。Table 的删除是 O(1)。

**21. 错**
- 解析：初始化应该只允许一次，多次初始化会导致数据混乱。

**22. 对**
- 解析：法定人数是判断提案有效性的前提条件。

**23. 对**
- 解析：event 结构体需要 `drop` 和 `store` 能力。

**24. 对**
- 解析：委托期间，委托人的投票权转给受托人。

**25. 错**
- 解析：虽然 timestamp 相对安全，但区块生产者仍有一定的时间操纵空间（通常几秒内）。

**26. 对**
- 解析：Option 是表示可选值的标准方式，用户可能没有投票记录。

**27. 错**
- 解析：executable 表示提案类型是否支持自动执行，只有通过的提案才能执行。

**28. 对**
- 解析：acquires 声明函数会访问哪些全局资源，这是 Move 的安全特性。

**29. 错**
- 解析：应该使用快照，防止闪电贷攻击和投票期间的代币操纵。

**30. 对**
- 解析：assert! 失败会中止交易并回滚所有状态，这是 Move 的原子性保证。

---

## 编程题答案（50 分）

### 编程题 1：提案状态管理（15 分）

```move
use aptos_framework::timestamp;

const STATUS_PENDING: u8 = 0;
const STATUS_ACTIVE: u8 = 1;
const STATUS_SUCCEEDED: u8 = 2;
const STATUS_DEFEATED: u8 = 3;

public fun update_proposal_status(
    proposal: &mut Proposal,
    total_voting_power: u64,
    quorum_percentage: u64,
    approval_threshold: u64
) {
    let now = timestamp::now_seconds();
    
    // 判断时间状态
    if (now < proposal.voting_start) {
        // 投票未开始
        proposal.status = STATUS_PENDING;
    } else if (now < proposal.voting_end) {
        // 投票进行中
        proposal.status = STATUS_ACTIVE;
    } else {
        // 投票已结束，统计结果
        let total_votes = proposal.yes_votes + proposal.no_votes + proposal.abstain_votes;
        
        // 计算法定人数
        let quorum_required = (total_voting_power * quorum_percentage) / 100;
        
        if (total_votes >= quorum_required) {
            // 达到法定人数，判断是否通过
            let approval_required = (total_votes * approval_threshold) / 100;
            
            if (proposal.yes_votes >= approval_required) {
                proposal.status = STATUS_SUCCEEDED;
            } else {
                proposal.status = STATUS_DEFEATED;
            }
        } else {
            // 未达到法定人数，自动否决
            proposal.status = STATUS_DEFEATED;
        }
    }
}
```

**评分点**：
- 正确使用 timestamp::now_seconds()（2 分）
- 正确判断三个时间状态（3 分）
- 正确计算法定人数（5 分）
- 正确判断通过条件（5 分）

---

### 编程题 2：防止重复投票（15 分）

```move
use std::signer;
use aptos_framework::timestamp;
use aptos_std::table;
use aptos_std::smart_table;

const ERROR_PROPOSAL_NOT_FOUND: u64 = 1;
const ERROR_VOTING_NOT_STARTED: u64 = 2;
const ERROR_VOTING_ENDED: u64 = 3;
const ERROR_ALREADY_VOTED: u64 = 4;
const ERROR_INVALID_VOTE_TYPE: u64 = 5;

const VOTE_NO: u8 = 0;
const VOTE_YES: u8 = 1;
const VOTE_ABSTAIN: u8 = 2;

public fun vote(
    voter: &signer,
    proposal_id: u64,
    vote_type: u8,
) acquires VotingSystem {
    let voter_addr = signer::address_of(voter);
    
    // 1. 检查投票类型有效
    assert!(vote_type <= VOTE_ABSTAIN, ERROR_INVALID_VOTE_TYPE);
    
    let system = borrow_global_mut<VotingSystem>(@module_addr);
    
    // 2. 检查提案存在
    assert!(
        smart_table::contains(&system.proposals, proposal_id),
        ERROR_PROPOSAL_NOT_FOUND
    );
    
    let proposal = smart_table::borrow_mut(&mut system.proposals, proposal_id);
    
    // 3. 检查投票时间
    let now = timestamp::now_seconds();
    assert!(now >= proposal.voting_start, ERROR_VOTING_NOT_STARTED);
    assert!(now < proposal.voting_end, ERROR_VOTING_ENDED);
    
    // 4. 检查是否已投票
    let proposal_votes = table::borrow(&system.votes, proposal_id);
    assert!(!table::contains(proposal_votes, voter_addr), ERROR_ALREADY_VOTED);
    
    // 5. 计算投票权重（简化：每人 1 票）
    let voting_power = 1u64;
    
    // 6. 记录投票
    let vote_record = Vote {
        proposal_id,
        voter: voter_addr,
        vote_type,
        voting_power,
        timestamp: now,
    };
    
    let proposal_votes_mut = table::borrow_mut(&mut system.votes, proposal_id);
    table::add(proposal_votes_mut, voter_addr, vote_record);
    
    // 7. 更新提案统计
    if (vote_type == VOTE_YES) {
        proposal.yes_votes = proposal.yes_votes + voting_power;
    } else if (vote_type == VOTE_NO) {
        proposal.no_votes = proposal.no_votes + voting_power;
    } else {
        proposal.abstain_votes = proposal.abstain_votes + voting_power;
    };
}
```

**评分点**：
- 检查投票类型（2 分）
- 检查提案存在（2 分）
- 检查投票时间（2 分）
- 检查重复投票（2 分）
- 获取状态正确（2 分）
- 记录投票（3 分）
- 更新统计（2 分）

---

### 编程题 3：投票历史查询（20 分）

#### 3.1 数据结构设计
```move
use aptos_std::table::{Self, Table};
use std::vector;

struct VotingHistory has key {
    // 用户 -> 投票记录列表
    user_votes: Table<address, vector<Vote>>,
}

// 初始化（在系统初始化时调用）
public fun init_voting_history(account: &signer) {
    move_to(account, VotingHistory {
        user_votes: table::new()
    });
}
```

#### 3.2 记录投票历史
```move
fun record_vote_history(
    voter: address,
    vote: Vote
) acquires VotingHistory {
    let history = borrow_global_mut<VotingHistory>(@module_addr);
    
    if (!table::contains(&history.user_votes, voter)) {
        // 用户首次投票，创建空列表
        table::add(&mut history.user_votes, voter, vector::empty<Vote>());
    };
    
    // 添加投票记录
    let user_votes = table::borrow_mut(&mut history.user_votes, voter);
    vector::push_back(user_votes, vote);
}
```

#### 3.3 查询用户投票历史
```move
#[view]
public fun get_user_vote_history(
    user: address
): vector<u64> acquires VotingHistory {
    let history = borrow_global<VotingHistory>(@module_addr);
    
    if (!table::contains(&history.user_votes, user)) {
        return vector::empty<u64>()
    };
    
    let votes = table::borrow(&history.user_votes, user);
    let proposal_ids = vector::empty<u64>();
    
    let i = 0;
    let len = vector::length(votes);
    while (i < len) {
        let vote = vector::borrow(votes, i);
        vector::push_back(&mut proposal_ids, vote.proposal_id);
        i = i + 1;
    };
    
    proposal_ids
}
```

#### 3.4 查询用户在特定提案的投票
```move
use std::option::{Self, Option};

#[view]
public fun get_user_vote_on_proposal(
    user: address,
    proposal_id: u64
): Option<Vote> acquires VotingHistory {
    let history = borrow_global<VotingHistory>(@module_addr);
    
    if (!table::contains(&history.user_votes, user)) {
        return option::none()
    };
    
    let votes = table::borrow(&history.user_votes, user);
    
    // 遍历查找特定提案的投票
    let i = 0;
    let len = vector::length(votes);
    while (i < len) {
        let vote = vector::borrow(votes, i);
        if (vote.proposal_id == proposal_id) {
            return option::some(*vote)
        };
        i = i + 1;
    };
    
    option::none()
}
```

**评分点**：
- 数据结构合理（5 分）
- 记录函数处理首次投票（3 分）
- 记录函数添加投票（2 分）
- 查询历史正确遍历（5 分）
- 查询特定投票正确查找（5 分）

---

## 总分计算

**选择题**：50 分
- 单选题：20 分（10 题 × 2 分）
- 多选题：15 分（5 题 × 3 分）
- 判断题：15 分（15 题 × 1 分）

**编程题**：50 分
- 编程题 1：15 分
- 编程题 2：15 分
- 编程题 3：20 分

**总分**：100 分  
**及格分**：70 分

---

## 评分等级

- **90-100 分**：优秀 ⭐⭐⭐⭐⭐
  - 完全掌握投票系统设计
  - 代码质量高
  - 可以开始独立开发复杂 DApp

- **80-89 分**：良好 ⭐⭐⭐⭐
  - 基本掌握核心概念
  - 代码基本正确
  - 需要加强细节处理

- **70-79 分**：及格 ⭐⭐⭐
  - 理解基础知识
  - 部分功能实现正确
  - 需要继续练习

- **60-69 分**：不及格 ⭐⭐
  - 概念理解不够
  - 建议重新学习本周内容

- **< 60 分**：需重学 ⭐
  - 基础知识薄弱
  - 建议从 Day 06 重新开始

---

## 学习建议

### 如果得分 < 70 分
1. 重新阅读 `01_理论学习/核心概念.md`
2. 逐行研究 `01_理论学习/代码示例.move`
3. 重做编程题，对照答案理解
4. 完成综合项目后再次测试

### 如果得分 70-89 分
1. 总结错题原因
2. 补充薄弱知识点
3. 完成综合项目
4. 阅读开源项目代码

### 如果得分 >= 90 分
1. 恭喜你！准备进入 Week 3
2. 可以挑战编程题的进阶版本
3. 尝试优化代码的 Gas 效率
4. 考虑为项目添加 Move Prover 规约

---

**继续努力，Week 3 见！** 🚀

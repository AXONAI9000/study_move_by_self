# MEV ç­–ç•¥ä¸é˜²æŠ¤ - æ ¸å¿ƒæ¦‚å¿µè¯¦è§£

## ç›®å½•

1. [MEV åŸºç¡€ç†è®º](#mev-åŸºç¡€ç†è®º)
2. [MEV ç­–ç•¥è¯¦è§£](#mev-ç­–ç•¥è¯¦è§£)
3. [é˜²æŠ¤æœºåˆ¶è®¾è®¡](#é˜²æŠ¤æœºåˆ¶è®¾è®¡)
4. [Aptos ç‰¹æ®Šæ€§](#aptos-ç‰¹æ®Šæ€§)
5. [å®æˆ˜æ¡ˆä¾‹åˆ†æ](#å®æˆ˜æ¡ˆä¾‹åˆ†æ)

---

## MEV åŸºç¡€ç†è®º

### 1.1 MEV çš„å®šä¹‰ä¸æ¼”å˜

**MEV (Maximal Extractable Value)** æ˜¯æŒ‡åŒºå—ç”Ÿäº§è€…ï¼ˆéªŒè¯è€…ã€çŸ¿å·¥ã€æ’åºè€…ï¼‰é€šè¿‡ä»¥ä¸‹æ–¹å¼èƒ½å¤Ÿæå–çš„æœ€å¤§ä»·å€¼ï¼š
- åŒ…å«ç‰¹å®šäº¤æ˜“
- æ’é™¤ç‰¹å®šäº¤æ˜“
- é‡æ–°æ’åºäº¤æ˜“

#### å†å²æ¼”å˜

```
2019å¹´ä¹‹å‰: "éšå½¢ç¨"
â””â”€ çŸ¿å·¥ä¼˜å…ˆæ‰“åŒ…é«˜gasäº¤æ˜“ï¼Œå¶å°”ä¼šåˆ©ç”¨é¡ºåº

2019-2020: MEVè¢«å‘ç°å’Œå‘½å
â””â”€ Flashbotsç ”ç©¶æ­ç¤ºMEVè§„æ¨¡
â””â”€ ç§°ä¸º"Miner Extractable Value"

2021å¹´å: MEVä¸“ä¸šåŒ–
â””â”€ ä¸“ä¸šSearcherå‡ºç°
â””â”€ MEVåŸºç¡€è®¾æ–½å‘å±•ï¼ˆFlashbotsï¼‰
â””â”€ æ”¹åä¸º"Maximal Extractable Value"ï¼ˆé€‚ç”¨äºPoSï¼‰

å½“å‰: MEVç”Ÿæ€æˆç†Ÿ
â””â”€ æ¯å¹´æ•°äº¿ç¾å…ƒçš„MEVè¢«æå–
â””â”€ å‡ºç°MEVä¿æŠ¤æ–¹æ¡ˆ
â””â”€ æˆä¸ºåè®®è®¾è®¡çš„é‡è¦è€ƒé‡
```

### 1.2 MEV çš„æ•°å­¦æ¨¡å‹

**åŸºæœ¬å…¬å¼**ï¼š

```
MEV = max(Value_extracted) - Cost_of_extraction

å…¶ä¸­ï¼š
Value_extracted = Profit_from_reordering
Cost_of_extraction = Gas_fees + Opportunity_cost
```

**å…·ä½“åœºæ™¯**ï¼š

#### DEX å¥—åˆ© MEV

```
ä»·æ ¼å·® = Price_DEX_B - Price_DEX_A
å¥—åˆ©é‡ = min(Liquidity_A, Liquidity_B, Capital)
Gasæˆæœ¬ = Gas_price Ã— Gas_used

MEV = (ä»·æ ¼å·® Ã— å¥—åˆ©é‡) - Gasæˆæœ¬ - æ»‘ç‚¹æŸå¤±
```

**ç¤ºä¾‹è®¡ç®—**ï¼š

```
DEX A: 1 APT = 10.0 USDC
DEX B: 1 APT = 10.5 USDC
å¯ç”¨èµ„æœ¬: 10,000 USDC
Gasæˆæœ¬: 5 USDC

æ­¥éª¤1: åœ¨DEX Aä¹°å…¥
  10,000 USDC â†’ 1,000 APT (å¿½ç•¥æ»‘ç‚¹)

æ­¥éª¤2: åœ¨DEX Bå–å‡º
  1,000 APT â†’ 10,500 USDC

MEV = 10,500 - 10,000 - 5 = 495 USDC
```

#### Sandwich æ”»å‡» MEV

```
å—å®³è€…äº¤æ˜“: V_amount
æ”»å‡»è€…èµ„æœ¬: A_capital
ä»·æ ¼å½±å“å‡½æ•°: P(x)

Front-runä¹°å…¥: A_capital â†’ æ¨é«˜ä»·æ ¼åˆ° P1
å—å®³è€…äº¤æ˜“: V_amount â†’ ä»¥P1æˆäº¤ï¼Œæ¨é«˜åˆ°P2
Back-runå–å‡º: åœ¨P2å–å‡º â†’ è·åˆ©

MEV = (P2 - P0) Ã— A_capital - Gas - æ»‘ç‚¹
```

### 1.3 MEV çš„åˆ†ç±»

#### æŒ‰é“å¾·æ€§åˆ†ç±»

| ç±»å‹ | è¯´æ˜ | ç¤ºä¾‹ | é“å¾·æ€§ |
|------|------|------|--------|
| **è‰¯æ€§MEV** | å¯¹ç”Ÿæ€æœ‰ç›Š | DEXå¥—åˆ©ã€æ¸…ç®— | âœ… ç§¯æ |
| **ä¸­æ€§MEV** | ä¸å½±å“ä»–äºº | NFTç‹™å‡» | ğŸŸ¡ ä¸­ç«‹ |
| **æ¶æ€§MEV** | æŸå®³ç”¨æˆ· | Sandwichæ”»å‡» | âŒ è´Ÿé¢ |

#### æŒ‰æŠ€æœ¯æ‰‹æ®µåˆ†ç±»

```
1. æ—¶åºä¾èµ–å‹
   â”œâ”€ Front-runningï¼ˆæŠ¢å…ˆäº¤æ˜“ï¼‰
   â”œâ”€ Back-runningï¼ˆè·Ÿéšäº¤æ˜“ï¼‰
   â””â”€ Sandwichï¼ˆä¸‰æ˜æ²»æ”»å‡»ï¼‰

2. ä¿¡æ¯ä¸å¯¹ç§°å‹
   â”œâ”€ Mempoolç›‘æ§
   â”œâ”€ é“¾ä¸Šäº‹ä»¶ç›‘å¬
   â””â”€ é¢„è¨€æœºä»·æ ¼æŠ¢è·‘

3. å¤æ‚ç­–ç•¥å‹
   â”œâ”€ å¤šæ­¥å¥—åˆ©
   â”œâ”€ é—ªç”µè´·ç»„åˆ
   â””â”€ è·¨é“¾MEV
```

---

## MEV ç­–ç•¥è¯¦è§£

### 2.1 Front-runningï¼ˆæŠ¢å…ˆäº¤æ˜“ï¼‰

#### åŸç†

```
æ—¶é—´çº¿:
  t0: ç”¨æˆ·æäº¤äº¤æ˜“åˆ°mempool
  t1: MEV botæ£€æµ‹åˆ°äº¤æ˜“
  t2: Botæäº¤é«˜gasäº¤æ˜“
  t3: Botäº¤æ˜“ä¼˜å…ˆæ‰§è¡Œ âœ…
  t4: ç”¨æˆ·äº¤æ˜“æ‰§è¡Œ
```

#### æ£€æµ‹ç®—æ³•

```typescript
// ä¼ªä»£ç 
function detectFrontRunOpportunity(pendingTx) {
    // 1. è§£æäº¤æ˜“
    const action = parseTxAction(pendingTx);
    
    // 2. åˆ¤æ–­æ˜¯å¦æ˜¯å¤§é¢äº¤æ˜“
    if (action.type === 'SWAP' && action.amount > THRESHOLD) {
        // 3. è®¡ç®—é¢„æœŸä»·æ ¼å½±å“
        const priceImpact = calculatePriceImpact(action);
        
        // 4. ä¼°ç®—MEV
        const expectedMEV = estimateMEV(priceImpact);
        
        // 5. å¦‚æœæœ‰åˆ©å¯å›¾ï¼Œæäº¤front-runäº¤æ˜“
        if (expectedMEV > GAS_COST + MIN_PROFIT) {
            return {
                shouldFrontRun: true,
                buyAmount: calculateOptimalAmount(expectedMEV),
                gasPrice: calculateOptimalGas(pendingTx.gasPrice)
            };
        }
    }
    
    return { shouldFrontRun: false };
}
```

#### å®é™…æ¡ˆä¾‹

```
çœŸå®æ¡ˆä¾‹ï¼ˆä»¥å¤ªåŠï¼‰:

2021å¹´æŸæ—¥ï¼Œä¸€ä¸ªç”¨æˆ·æäº¤äº†ç”¨1000 ETHè´­ä¹°æŸä»£å¸çš„äº¤æ˜“
â†’ MEV botæ£€æµ‹åˆ°
â†’ Botç”¨100 ETHæŠ¢å…ˆä¹°å…¥
â†’ ä»·æ ¼ä¸Šæ¶¨15%
â†’ ç”¨æˆ·ä»¥æ›´é«˜ä»·æ ¼æˆäº¤
â†’ Botå–å‡ºï¼Œè·åˆ©~15 ETHï¼ˆçº¦50,000ç¾å…ƒï¼‰
```

### 2.2 Back-runningï¼ˆè·Ÿéšäº¤æ˜“ï¼‰

#### åŸç†

```
è§¦å‘äº‹ä»¶:
  User Transaction â†’ åˆ›å»ºå¥—åˆ©æœºä¼š
         â†“
  Botç«‹å³è·Ÿè¿› â†’ è·å–æ”¶ç›Š
         â†“
  å¸‚åœºæ¢å¤å¹³è¡¡
```

#### å¸¸è§åœºæ™¯

**åœºæ™¯1: DEXå¥—åˆ©**

```
1. ç”¨æˆ·åœ¨Pancake Swapå¤§é¢ä¹°å…¥APT
   â†’ APT/USDCä»·æ ¼ä»10ä¸Šå‡åˆ°10.2

2. Botæ£€æµ‹åˆ°ä»·æ ¼å¤±è¡¡
   â†’ åœ¨å¦ä¸€ä¸ªDEXä»æ˜¯10.0

3. Botç«‹å³å¥—åˆ©
   â†’ åœ¨DEX Bä¹°å…¥ï¼Œåœ¨Pancakeå–å‡º
   â†’ è·åˆ©0.2 USDC/APT
```

**åœºæ™¯2: æ¸…ç®—è§¦å‘**

```
1. APTä»·æ ¼ä¸‹è·Œ
   â†’ æŸå€Ÿè´·ä»“ä½å˜å¾—ä¸å¥åº·

2. æ¸…ç®—æœºå™¨äººç›‘æµ‹åˆ°
   â†’ health_factor < 1.0

3. ç«‹å³æäº¤æ¸…ç®—äº¤æ˜“
   â†’ è·å¾—5%æ¸…ç®—å¥–åŠ±
```

#### ä¼˜åŒ–ç­–ç•¥

```move
// é«˜æ•ˆçš„back-runningéœ€è¦ï¼š
// 1. å®æ—¶ç›‘æ§
// 2. å¿«é€Ÿè®¡ç®—
// 3. ä¼˜åŒ–çš„gasä½¿ç”¨

module mev_bot::backrun_optimizer {
    // è®¡ç®—æœ€ä¼˜æ‰§è¡Œé‡
    public fun calculate_optimal_amount(
        price_diff: u64,
        liquidity: u64,
        gas_cost: u64,
    ): u64 {
        // è€ƒè™‘æ»‘ç‚¹çš„æœ€ä¼˜åŒ–å…¬å¼
        // amount = sqrt(liquidity * price_diff / gas_cost)
        // ç®€åŒ–ç‰ˆæœ¬
        let optimal = math::sqrt((liquidity * price_diff) / gas_cost);
        optimal
    }
}
```

### 2.3 Sandwich æ”»å‡»ï¼ˆä¸‰æ˜æ²»æ”»å‡»ï¼‰

#### å®Œæ•´æµç¨‹

```
é˜¶æ®µ0: ç›‘æ§é˜¶æ®µ
  â””â”€ ç›‘æ§mempoolä¸­çš„å¤§é¢swapäº¤æ˜“

é˜¶æ®µ1: æ£€æµ‹åˆ°ç›®æ ‡
  â””â”€ ç”¨æˆ·è¦ç”¨100,000 USDCä¹°APT

é˜¶æ®µ2: æ„å»ºsandwich
  Tx1 (Front): Botä¹°å…¥APTï¼Œæ¨é«˜ä»·æ ¼
  Tx2 (Victim): ç”¨æˆ·çš„äº¤æ˜“ï¼Œä»¥æ›´å·®ä»·æ ¼æˆäº¤
  Tx3 (Back): Botå–å‡ºAPTï¼Œè·åˆ©

é˜¶æ®µ3: æäº¤bundle
  â””â”€ ç¡®ä¿ä¸‰ç¬”äº¤æ˜“æŒ‰é¡ºåºæ‰§è¡Œ
  â””â”€ ä½¿ç”¨é«˜gasç¡®ä¿ä¼˜å…ˆçº§
```

#### æ•°å­¦å»ºæ¨¡

**æ’å®šä¹˜ç§¯å…¬å¼**ï¼š
$$
x \times y = k
$$

**ä»·æ ¼å‡½æ•°**ï¼š
$$
P = \frac{y}{x}
$$

**Sandwichæ”»å‡»ä¼˜åŒ–**ï¼š

```
åˆå§‹çŠ¶æ€: x0, y0, k = x0 * y0
å—å®³è€…äº¤æ˜“é‡: V

æœ€ä¼˜Front-runé‡ F:
maximize: Profit = (å–å‡ºä»· - ä¹°å…¥ä»·) * F - Gas

çº¦æŸæ¡ä»¶:
1. F + V ä¸èƒ½è€—å°½æµåŠ¨æ€§
2. Profit > 0
3. æ»‘ç‚¹ä¿æŠ¤æœªè§¦å‘

æ•°å€¼è§£:
F â‰ˆ sqrt(V * x0) - x0  (ç®€åŒ–å…¬å¼)
```

**å®é™…æ¡ˆä¾‹åˆ†æ**ï¼š

```python
# Pythonæ¨¡æ‹Ÿ
def simulate_sandwich(x0, y0, victim_amount):
    k = x0 * y0
    
    # åˆå§‹ä»·æ ¼
    initial_price = y0 / x0
    
    # Front-run: Botä¹°å…¥
    bot_amount = 0.5 * victim_amount  # ç®€åŒ–ç­–ç•¥
    x1 = x0 - bot_amount
    y1 = k / x1
    bot_cost = y1 - y0
    price_after_front = y1 / x1
    
    # Victimäº¤æ˜“
    x2 = x1 - victim_amount
    y2 = k / x2
    victim_cost = y2 - y1
    price_after_victim = y2 / x2
    
    # Back-run: Botå–å‡º
    x3 = x2 + bot_amount
    y3 = k / x3
    bot_revenue = y2 - y3
    
    # è®¡ç®—åˆ©æ¶¦
    bot_profit = bot_revenue - bot_cost
    victim_loss = (price_after_front - initial_price) * victim_amount
    
    return {
        'bot_profit': bot_profit,
        'victim_loss': victim_loss,
        'price_impact': (price_after_victim - initial_price) / initial_price
    }

# ç¤ºä¾‹
result = simulate_sandwich(
    x0=100000,      # 100k APT
    y0=1000000,     # 1M USDC
    victim_amount=10000  # å—å®³è€…ä¹°10k APT
)
print(f"Bot profit: {result['bot_profit']} USDC")
print(f"Victim loss: {result['victim_loss']} USDC")
```

### 2.4 é«˜çº§MEVç­–ç•¥

#### è·¨DEXå¥—åˆ©

```
åŒæ—¶ç›‘æ§å¤šä¸ªDEX:

DEX_A: APT/USDC = 10.0
DEX_B: APT/USDC = 10.3
DEX_C: APT/DAI = 10.1

ç­–ç•¥: 
1. åœ¨DEX_Aä¹°å…¥APTï¼ˆä¾¿å®œï¼‰
2. åœ¨DEX_Bå–å‡ºAPTï¼ˆæ˜‚è´µï¼‰
3. åˆ©æ¶¦: 0.3 USDC/APT
```

#### ä¸‰è§’å¥—åˆ©

```
å¯»æ‰¾å¾ªç¯å¥—åˆ©è·¯å¾„:

USDC â†’ APT â†’ BTC â†’ USDC

å¦‚æœ:
USDC/APT = 10
APT/BTC = 0.001
BTC/USDC = 11000

é‚£ä¹ˆ:
100 USDC â†’ 10 APT â†’ 0.01 BTC â†’ 110 USDC
åˆ©æ¶¦: 10 USDC (10%)
```

#### JITæµåŠ¨æ€§ï¼ˆJust-In-Time Liquidityï¼‰

```
æ£€æµ‹åˆ°å¤§é¢swapå³å°†å‘ç”Ÿ:

1. åœ¨äº¤æ˜“å‰æ·»åŠ æµåŠ¨æ€§
2. èµšå–è¯¥ç¬”äº¤æ˜“çš„å¤§éƒ¨åˆ†æ‰‹ç»­è´¹
3. äº¤æ˜“åç«‹å³ç§»é™¤æµåŠ¨æ€§
4. é¿å…é•¿æœŸæŒæœ‰çš„æ— å¸¸æŸå¤±é£é™©
```

---

## é˜²æŠ¤æœºåˆ¶è®¾è®¡

### 3.1 åè®®å±‚é˜²æŠ¤

#### æ»‘ç‚¹ä¿æŠ¤

```move
module dex::swap_with_protection {
    use std::signer;
    
    // å¸¦æ»‘ç‚¹ä¿æŠ¤çš„swap
    public entry fun swap_exact_input(
        user: &signer,
        amount_in: u64,
        min_amount_out: u64,  // ç”¨æˆ·è®¾ç½®çš„æœ€å°è¾“å‡º
        deadline: u64,         // äº¤æ˜“æˆªæ­¢æ—¶é—´
    ) {
        // 1. æ£€æŸ¥deadline
        let now = timestamp::now_seconds();
        assert!(now <= deadline, ERROR_EXPIRED);
        
        // 2. è®¡ç®—å®é™…è¾“å‡º
        let amount_out = calculate_amount_out(amount_in);
        
        // 3. æ»‘ç‚¹æ£€æŸ¥
        assert!(amount_out >= min_amount_out, ERROR_SLIPPAGE_TOO_HIGH);
        
        // 4. æ‰§è¡Œswap
        execute_swap(user, amount_in, amount_out);
    }
    
    // æ¨èæ»‘ç‚¹è®¾ç½®
    public fun recommend_slippage(amount: u64): u64 {
        if (amount < 1000) {
            50  // 0.5% for small trades
        } else if (amount < 10000) {
            100 // 1% for medium trades
        } else {
            200 // 2% for large trades
        }
    }
}
```

#### TWAPï¼ˆæ—¶é—´åŠ æƒå¹³å‡ä»·æ ¼ï¼‰

```move
module oracle::twap {
    use aptos_framework::timestamp;
    
    struct PriceAccumulator has key {
        cumulative_price: u128,
        last_price: u64,
        last_timestamp: u64,
    }
    
    // æ›´æ–°ç´¯ç§¯ä»·æ ¼
    public fun update(account: &signer) acquires PriceAccumulator {
        let acc = borrow_global_mut<PriceAccumulator>(
            signer::address_of(account)
        );
        
        let now = timestamp::now_seconds();
        let elapsed = now - acc.last_timestamp;
        
        // ç´¯åŠ : cumulative += price * time
        acc.cumulative_price = acc.cumulative_price + 
            (acc.last_price as u128) * (elapsed as u128);
        
        acc.last_timestamp = now;
    }
    
    // è·å–TWAP
    public fun get_twap(
        account: address,
        period: u64,
    ): u64 acquires PriceAccumulator {
        let acc = borrow_global<PriceAccumulator>(account);
        let now = timestamp::now_seconds();
        
        let time_elapsed = now - (acc.last_timestamp - period);
        let price_sum = acc.cumulative_price - 
            get_cumulative_at(account, acc.last_timestamp - period);
        
        // TWAP = total_price / total_time
        ((price_sum / (time_elapsed as u128)) as u64)
    }
}
```

#### Commit-Reveal æ¨¡å¼

```move
module dex::commit_reveal {
    use std::hash;
    use aptos_framework::timestamp;
    
    struct CommittedOrder has key {
        order_hash: vector<u8>,
        commit_time: u64,
        revealed: bool,
    }
    
    // é˜¶æ®µ1: æäº¤è®¢å•å“ˆå¸Œ
    public entry fun commit_order(
        user: &signer,
        order_hash: vector<u8>,
    ) {
        let user_addr = signer::address_of(user);
        
        move_to(user, CommittedOrder {
            order_hash,
            commit_time: timestamp::now_seconds(),
            revealed: false,
        });
    }
    
    // é˜¶æ®µ2: æ­ç¤ºå¹¶æ‰§è¡Œ
    public entry fun reveal_and_execute(
        user: &signer,
        amount_in: u64,
        min_amount_out: u64,
        nonce: vector<u8>,
    ) acquires CommittedOrder {
        let user_addr = signer::address_of(user);
        let committed = borrow_global_mut<CommittedOrder>(user_addr);
        
        // 1. éªŒè¯æœªè¢«æ­ç¤º
        assert!(!committed.revealed, ERROR_ALREADY_REVEALED);
        
        // 2. éªŒè¯æ—¶é—´çª—å£
        let now = timestamp::now_seconds();
        assert!(
            now >= committed.commit_time + MIN_DELAY,
            ERROR_TOO_EARLY
        );
        assert!(
            now <= committed.commit_time + MAX_DELAY,
            ERROR_TOO_LATE
        );
        
        // 3. éªŒè¯å“ˆå¸Œ
        let order_data = encode_order(amount_in, min_amount_out, nonce);
        let computed_hash = hash::sha3_256(order_data);
        assert!(computed_hash == committed.order_hash, ERROR_HASH_MISMATCH);
        
        // 4. æ ‡è®°å·²æ­ç¤º
        committed.revealed = true;
        
        // 5. æ‰§è¡Œè®¢å•
        execute_swap(user, amount_in, min_amount_out);
    }
}
```

#### æ‰¹é‡æ‹å–

```move
module dex::batch_auction {
    use std::vector;
    
    struct OrderBatch has key {
        orders: vector<Order>,
        batch_start: u64,
        batch_duration: u64,
        executed: bool,
    }
    
    struct Order has store {
        user: address,
        amount_in: u64,
        limit_price: u64,  // ç”¨æˆ·çš„é™ä»·
    }
    
    // æäº¤è®¢å•åˆ°å½“å‰æ‰¹æ¬¡
    public entry fun submit_order(
        user: &signer,
        amount_in: u64,
        limit_price: u64,
    ) acquires OrderBatch {
        let batch = borrow_global_mut<OrderBatch>(@dex);
        
        // æ£€æŸ¥æ‰¹æ¬¡ä»ç„¶å¼€æ”¾
        let now = timestamp::now_seconds();
        assert!(
            now < batch.batch_start + batch.batch_duration,
            ERROR_BATCH_CLOSED
        );
        
        // æ·»åŠ è®¢å•
        vector::push_back(&mut batch.orders, Order {
            user: signer::address_of(user),
            amount_in,
            limit_price,
        });
    }
    
    // æ‰§è¡Œæ‰¹æ¬¡ï¼ˆæ‰€æœ‰è®¢å•ç»Ÿä¸€ä»·æ ¼ï¼‰
    public fun execute_batch() acquires OrderBatch {
        let batch = borrow_global_mut<OrderBatch>(@dex);
        
        // 1. è®¡ç®—æ¸…ç®—ä»·æ ¼
        let clearing_price = calculate_clearing_price(&batch.orders);
        
        // 2. æ‰§è¡Œæ‰€æœ‰è®¢å•
        let i = 0;
        let len = vector::length(&batch.orders);
        while (i < len) {
            let order = vector::borrow(&batch.orders, i);
            
            // åªæ‰§è¡Œé™ä»·æ»¡è¶³çš„è®¢å•
            if (order.limit_price >= clearing_price) {
                execute_order_at_price(order, clearing_price);
            };
            
            i = i + 1;
        };
        
        // 3. æ ‡è®°å·²æ‰§è¡Œ
        batch.executed = true;
    }
    
    // è®¡ç®—å¸‚åœºæ¸…ç®—ä»·æ ¼
    fun calculate_clearing_price(orders: &vector<Order>): u64 {
        // ç®€åŒ–ç‰ˆæœ¬ï¼šå–ä¸­ä½æ•°ä»·æ ¼
        // å®é™…åº”è¯¥ç”¨ä¾›éœ€æ›²çº¿äº¤å‰ç‚¹
        let total_buy_volume = 0u64;
        let total_sell_volume = 0u64;
        
        // ... å¤æ‚çš„åŒ¹é…ç®—æ³• ...
        
        1000 // ç¤ºä¾‹ä»·æ ¼
    }
}
```

### 3.2 ç”¨æˆ·å±‚é˜²æŠ¤

#### æ¨èæœ€ä½³å®è·µ

```move
module user_protection::best_practices {
    // 1. åˆç†çš„æ»‘ç‚¹è®¾ç½®
    public fun get_recommended_slippage(
        trade_size: u64,
        liquidity: u64,
    ): u64 {
        let size_ratio = (trade_size * 10000) / liquidity;
        
        if (size_ratio < 10) {      // < 0.1%
            50                       // 0.5% slippage
        } else if (size_ratio < 100) { // < 1%
            100                      // 1% slippage
        } else if (size_ratio < 500) { // < 5%
            300                      // 3% slippage
        } else {
            500                      // 5% slippage (å¤§é¢äº¤æ˜“)
        }
    }
    
    // 2. äº¤æ˜“æ‹†åˆ†
    public fun should_split_trade(
        amount: u64,
        liquidity: u64,
    ): (bool, u64) {
        // å¦‚æœäº¤æ˜“è¶…è¿‡æ± å­çš„5%ï¼Œå»ºè®®æ‹†åˆ†
        let threshold = liquidity / 20;
        
        if (amount > threshold) {
            let num_splits = (amount / threshold) + 1;
            (true, num_splits)
        } else {
            (false, 1)
        }
    }
    
    // 3. æ—¶é—´åˆ†æ•£
    public fun get_optimal_timing(): vector<u64> {
        // è¿”å›å»ºè®®çš„äº¤æ˜“æ—¶é—´æˆ³
        // é¿å…åœ¨MEVæ´»è·ƒæœŸäº¤æ˜“
        vector[
            timestamp::now_seconds() + 300,   // 5åˆ†é’Ÿå
            timestamp::now_seconds() + 600,   // 10åˆ†é’Ÿå
            timestamp::now_seconds() + 900,   // 15åˆ†é’Ÿå
        ]
    }
}
```

---

## Aptos ç‰¹æ®Šæ€§

### 4.1 Block-STM å¯¹MEVçš„å½±å“

#### å¹¶è¡Œæ‰§è¡Œæ¨¡å‹

```
ä»¥å¤ªåŠï¼ˆé¡ºåºæ‰§è¡Œï¼‰:
Block {
    Tx1 â†’ State1
    Tx2 â†’ State2
    Tx3 â†’ State3
}
é¡ºåºå®Œå…¨å¯é¢„æµ‹

Aptosï¼ˆå¹¶è¡Œæ‰§è¡Œï¼‰:
Block {
    Tx1 â”€â”
    Tx2 â”€â”¼â†’ å¹¶è¡Œå°è¯• â†’ å†²çªæ£€æµ‹ â†’ é‡æ–°æ‰§è¡Œ
    Tx3 â”€â”˜
}
é¡ºåºéƒ¨åˆ†ä¸å¯é¢„æµ‹
```

#### è¯»å†™é›†åˆ†æ

```
Transaction A:
  Read: Pool_APT_USDC.reserve_x
  Write: Pool_APT_USDC.reserve_y

Transaction B:
  Read: Pool_APT_USDC.reserve_x
  Write: Pool_APT_USDC.reserve_y

å†²çªï¼â†’ éœ€è¦é‡æ–°æ‰§è¡Œ

è¿™ä½¿å¾—ç²¾ç¡®çš„sandwichæ”»å‡»æ›´å›°éš¾
```

#### MEVå½±å“å¯¹æ¯”

| MEVç±»å‹ | ä»¥å¤ªåŠéš¾åº¦ | Aptoséš¾åº¦ | åŸå›  |
|---------|-----------|----------|------|
| Front-running | ç®€å• | ä¸­ç­‰ | å¹¶è¡Œæ‰§è¡Œé™ä½å¯é¢„æµ‹æ€§ |
| Back-running | ç®€å• | ç®€å• | ä»ç„¶å¯è¡Œ |
| Sandwich | ç®€å• | å›°éš¾ | éœ€è¦ç²¾ç¡®æ§åˆ¶3ç¬”äº¤æ˜“é¡ºåº |
| DEXå¥—åˆ© | ç®€å• | ç®€å• | ä¸ä¾èµ–é¡ºåº |
| æ¸…ç®— | ç®€å• | ç®€å• | å…ˆåˆ°å…ˆå¾— |

### 4.2 Aptos MEVæœ€ä½³å®è·µ

```move
module aptos_mev::strategies {
    // Aptoså‹å¥½çš„MEVç­–ç•¥
    
    // 1. ç‹¬ç«‹å¥—åˆ©ï¼ˆä¸ä¾èµ–å…¶ä»–äº¤æ˜“ï¼‰
    public entry fun independent_arbitrage(
        bot: &signer,
    ) {
        // æ‰«æå¤šä¸ªDEX
        let price_a = dex_a::get_price();
        let price_b = dex_b::get_price();
        
        if (price_a < price_b) {
            // ç›´æ¥æ‰§è¡Œï¼Œä¸ä¾èµ–mempool
            let token = dex_a::buy(bot, amount);
            dex_b::sell(bot, token);
        }
    }
    
    // 2. åŸºäºäº‹ä»¶çš„ååº”å¼å¥—åˆ©
    public entry fun event_based_arbitrage(
        bot: &signer,
    ) {
        // ç›‘å¬é“¾ä¸Šäº‹ä»¶è€Œémempool
        // åœ¨äº‹ä»¶å‘ç”Ÿåç«‹å³ååº”
    }
    
    // 3. æ¸…ç®—æœºå™¨äººï¼ˆä¸å—å¹¶è¡Œå½±å“ï¼‰
    public entry fun liquidate_positions(
        bot: &signer,
    ) {
        // æ‰«æä¸å¥åº·ä»“ä½
        // ç›´æ¥æ¸…ç®—ï¼Œå…ˆåˆ°å…ˆå¾—
    }
}
```

---

## å®æˆ˜æ¡ˆä¾‹åˆ†æ

### 5.1 æ¡ˆä¾‹1: DEXå¥—åˆ©æœºå™¨äºº

```move
module mev_examples::dex_arbitrage {
    use aptos_framework::coin;
    use aptos_framework::timestamp;
    
    // å¥—åˆ©æœºä¼šç»“æ„
    struct ArbitrageOpportunity {
        buy_dex: address,
        sell_dex: address,
        profit: u64,
        amount: u64,
    }
    
    // æ‰«æå¥—åˆ©æœºä¼š
    public fun scan_opportunities(): vector<ArbitrageOpportunity> {
        let opportunities = vector::empty();
        
        // è·å–å„DEXä»·æ ¼
        let dexes = get_all_dexes();
        let i = 0;
        while (i < vector::length(&dexes)) {
            let j = i + 1;
            while (j < vector::length(&dexes)) {
                let dex_a = vector::borrow(&dexes, i);
                let dex_b = vector::borrow(&dexes, j);
                
                // æ£€æŸ¥æ˜¯å¦æœ‰å¥—åˆ©ç©ºé—´
                let opp = check_arbitrage(dex_a, dex_b);
                if (opp.profit > MIN_PROFIT) {
                    vector::push_back(&mut opportunities, opp);
                };
                
                j = j + 1;
            };
            i = i + 1;
        };
        
        opportunities
    }
    
    // æ‰§è¡Œå¥—åˆ©
    public entry fun execute_arbitrage(
        bot: &signer,
        buy_dex: address,
        sell_dex: address,
        amount: u64,
    ) {
        // 1. åœ¨ä½ä»·DEXä¹°å…¥
        let token = buy_on_dex(bot, buy_dex, amount);
        
        // 2. åœ¨é«˜ä»·DEXå–å‡º
        let proceeds = sell_on_dex(bot, sell_dex, token);
        
        // 3. éªŒè¯ç›ˆåˆ©
        assert!(proceeds > amount, ERROR_NO_PROFIT);
    }
}
```

### 5.2 æ¡ˆä¾‹2: æ¸…ç®—æœºå™¨äºº

```move
module mev_examples::liquidation_bot {
    // æ‰«æä¸å¥åº·ä»“ä½
    public fun scan_unhealthy_positions(): vector<address> {
        let unhealthy = vector::empty();
        
        // è·å–æ‰€æœ‰å€Ÿæ¬¾äºº
        let borrowers = lending::get_all_borrowers();
        
        let i = 0;
        while (i < vector::length(&borrowers)) {
            let borrower = vector::borrow(&borrowers, i);
            
            // è®¡ç®—å¥åº·å› å­
            let health = calculate_health_factor(*borrower);
            
            if (health < LIQUIDATION_THRESHOLD) {
                vector::push_back(&mut unhealthy, *borrower);
            };
            
            i = i + 1;
        };
        
        unhealthy
    }
    
    // æ‰§è¡Œæ¸…ç®—
    public entry fun liquidate(
        liquidator: &signer,
        borrower: address,
    ) {
        // 1. éªŒè¯å¯æ¸…ç®—
        let health = calculate_health_factor(borrower);
        assert!(health < LIQUIDATION_THRESHOLD, ERROR_HEALTHY);
        
        // 2. è®¡ç®—æ¸…ç®—é‡
        let liquidate_amount = calculate_liquidation_amount(borrower);
        
        // 3. æ‰§è¡Œæ¸…ç®—
        lending::liquidate(
            liquidator,
            borrower,
            liquidate_amount
        );
        
        // 4. è·å¾—å¥–åŠ±ï¼ˆé€šå¸¸æ˜¯5-10%æŠ˜æ‰£ï¼‰
    }
    
    // ä¼˜åŒ–ï¼šæ‰¹é‡æ¸…ç®—
    public entry fun batch_liquidate(
        liquidator: &signer,
        borrowers: vector<address>,
    ) {
        let i = 0;
        while (i < vector::length(&borrowers)) {
            let borrower = vector::borrow(&borrowers, i);
            
            // å°è¯•æ¸…ç®—ï¼ˆå¿½ç•¥å¤±è´¥ï¼‰
            try_liquidate(liquidator, *borrower);
            
            i = i + 1;
        };
    }
}
```

### 5.3 æ¡ˆä¾‹3: MEVæ£€æµ‹å™¨

```move
module mev_examples::mev_detector {
    use aptos_framework::event;
    
    struct SuspiciousTxEvent has drop, store {
        tx_hash: vector<u8>,
        mev_type: u8,  // 1=front-run, 2=sandwich, etc.
        confidence: u64,
    }
    
    // åˆ†æäº¤æ˜“æ¨¡å¼
    public fun analyze_transaction(
        tx: &Transaction,
        prev_tx: &Transaction,
        next_tx: &Transaction,
    ): bool {
        // æ£€æµ‹sandwichæ¨¡å¼
        if (is_sandwich_pattern(tx, prev_tx, next_tx)) {
            emit_alert(tx, 2, 90);
            return true;
        };
        
        // æ£€æµ‹front-running
        if (is_frontrun_pattern(tx, next_tx)) {
            emit_alert(tx, 1, 85);
            return true;
        };
        
        false
    }
    
    // æ£€æµ‹sandwichæ¨¡å¼
    fun is_sandwich_pattern(
        victim: &Transaction,
        front: &Transaction,
        back: &Transaction,
    ): bool {
        // 1. æ£€æŸ¥äº¤æ˜“æ–¹
        let same_attacker = (front.sender == back.sender);
        
        // 2. æ£€æŸ¥äº¤æ˜“å¯¹
        let same_pair = (front.pool == victim.pool && 
                        victim.pool == back.pool);
        
        // 3. æ£€æŸ¥æ–¹å‘
        let opposite_direction = (front.buy == back.sell);
        
        // 4. æ£€æŸ¥æ•°é‡
        let similar_amount = approx_equal(front.amount, back.amount);
        
        same_attacker && same_pair && opposite_direction && similar_amount
    }
}
```

---

## æ€»ç»“

### å…³é”®è¦ç‚¹

1. **MEVæ˜¯ä¸­æ€§æŠ€æœ¯**
   - å¯ç”¨äºæœ‰ç›Šçš„å¥—åˆ©å’Œæ¸…ç®—
   - ä¹Ÿå¯ç”¨äºæ”»å‡»ç”¨æˆ·

2. **ç†è§£æ˜¯é˜²æŠ¤çš„ç¬¬ä¸€æ­¥**
   - äº†è§£æ”»å‡»åŸç†æ‰èƒ½æœ‰æ•ˆé˜²æŠ¤
   - å¤šå±‚é˜²æŠ¤æ›´å®‰å…¨

3. **Aptosæœ‰ç‹¬ç‰¹ä¼˜åŠ¿**
   - Block-STMé™ä½æŸäº›MEVé£é™©
   - ä½†ä»éœ€ä¸»åŠ¨é˜²æŠ¤

4. **å¹³è¡¡æ•ˆç‡ä¸å®‰å…¨**
   - è¿‡åº¦é˜²æŠ¤å½±å“ç”¨æˆ·ä½“éªŒ
   - éœ€è¦åœ¨å®‰å…¨ä¸ä¾¿åˆ©é—´å–èˆ

### å»¶ä¼¸é˜…è¯»

- Flashbotsæ–‡æ¡£: https://docs.flashbots.net/
- MEVç ”ç©¶: https://arxiv.org/abs/1904.05234
- Aptos Block-STM: https://arxiv.org/abs/2203.06871

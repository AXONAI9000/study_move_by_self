# Day 15 实践任务：实现 AMM 核心算法

## 🎯 任务目标

通过本次实践，你将独立实现一个完整的 AMM 核心模块，巩固对恒定乘积公式和流动性管理的理解。

**预计完成时间**：3-4 小时

---

## 📋 任务清单

### 必做任务（80分）

- [ ] **任务 1**：实现基础流动性池结构（15分）
- [ ] **任务 2**：实现添加流动性功能（20分）
- [ ] **任务 3**：实现交换功能（25分）
- [ ] **任务 4**：实现移除流动性功能（20分）

### 进阶任务（20分）

- [ ] **任务 5**：实现价格影响计算（10分）
- [ ] **任务 6**：添加滑点保护机制（10分）

### 挑战任务（加分项）

- [ ] **挑战 1**：实现多跳路由（+10分）
- [ ] **挑战 2**：实现集中流动性（+15分）
- [ ] **挑战 3**：Gas 优化（+5分）

---

## 📝 详细任务说明

### 任务 1：实现基础流动性池结构（15分）

#### 要求

创建一个流动性池模块，包含以下数据结构：

```move
module day15_practice::simple_amm {
    use aptos_framework::coin::{Self, Coin};
    
    /// 流动性池
    struct LiquidityPool<phantom X, phantom Y> has key {
        // TODO: 定义储备、LP 总量等字段
    }
    
    /// LP Token 余额
    struct LPBalance<phantom X, phantom Y> has key {
        // TODO: 定义 LP 余额
    }
}
```

#### 评分标准

- ✅ 正确定义储备字段（5分）
- ✅ 正确定义 LP 总供应量（5分）
- ✅ 合理的能力约束（5分）

#### 提示

- 使用 `Coin<T>` 存储代币储备
- 考虑需要哪些统计数据
- 思考是否需要事件处理

---

### 任务 2：实现添加流动性功能（20分）

#### 要求

实现两个函数：

1. **首次添加流动性**
```move
public entry fun add_liquidity_initial<X, Y>(
    provider: &signer,
    amount_x: u64,
    amount_y: u64,
) acquires LiquidityPool, LPBalance {
    // TODO: 实现首次添加流动性
    // 提示：LP = sqrt(x * y)
}
```

2. **后续添加流动性**
```move
public entry fun add_liquidity<X, Y>(
    provider: &signer,
    amount_x: u64,
    amount_y: u64,
    min_lp: u64,  // 最小 LP Token
) acquires LiquidityPool, LPBalance {
    // TODO: 实现按比例添加流动性
    // 提示：必须保持当前储备比例
}
```

#### 评分标准

- ✅ 正确计算初始 LP（5分）
- ✅ 正确处理锁定流动性（3分）
- ✅ 正确计算后续 LP（5分）
- ✅ 比例验证逻辑（4分）
- ✅ 错误处理（3分）

#### 测试用例

```move
#[test]
fun test_add_liquidity() {
    // 初始添加：1000 X + 2000 Y
    // 预期 LP ≈ sqrt(1000 * 2000) - 1000 = 1414 - 1000 = 414
    
    // 后续添加：100 X
    // 预期需要：200 Y
    // 预期 LP：(100 / 1000) * 1414 = 141.4
}
```

---

### 任务 3：实现交换功能（25分）

#### 要求

实现交换函数，支持双向兑换：

```move
/// 用 X 换 Y
public entry fun swap_x_to_y<X, Y>(
    trader: &signer,
    amount_in: u64,
    min_amount_out: u64,
) acquires LiquidityPool {
    // TODO: 实现交换逻辑
    // 公式：amount_out = (amount_in * 0.997 * reserve_y) / (reserve_x + amount_in * 0.997)
}

/// 用 Y 换 X
public entry fun swap_y_to_x<X, Y>(
    trader: &signer,
    amount_in: u64,
    min_amount_out: u64,
) acquires LiquidityPool {
    // TODO: 实现交换逻辑
}
```

#### 评分标准

- ✅ 正确实现恒定乘积公式（10分）
- ✅ 正确扣除 0.3% 手续费（5分）
- ✅ 滑点保护（5分）
- ✅ 错误处理（3分）
- ✅ 双向交换都正确（2分）

#### 测试用例

```move
#[test]
fun test_swap() {
    // 池子：10000 X, 20000 Y
    // 交换：1000 X
    // 手续费：3 X
    // 实际用于交换：997 X
    // 预期输出：(997 * 20000) / (10000 + 997) ≈ 1812 Y
    // 验证：(10000 + 1000) * (20000 - 1812) ≈ 10000 * 20000 ✅
}
```

#### 提示

```move
// 手续费计算
const FEE_NUMERATOR: u64 = 30;      // 0.3%
const FEE_DENOMINATOR: u64 = 10000;

let amount_in_with_fee = amount_in * (FEE_DENOMINATOR - FEE_NUMERATOR) / FEE_DENOMINATOR;
```

---

### 任务 4：实现移除流动性功能（20分）

#### 要求

```move
public entry fun remove_liquidity<X, Y>(
    provider: &signer,
    lp_amount: u64,
    min_amount_x: u64,
    min_amount_y: u64,
) acquires LiquidityPool, LPBalance {
    // TODO: 实现移除流动性
    // 按比例返还两种代币
}
```

#### 评分标准

- ✅ 正确计算返还数量（8分）
- ✅ LP Token 余额检查（4分）
- ✅ 滑点保护（4分）
- ✅ 状态更新（4分）

#### 计算公式

```
amount_x = (lp_amount / total_lp) * reserve_x
amount_y = (lp_amount / total_lp) * reserve_y
```

#### 测试用例

```move
#[test]
fun test_remove_liquidity() {
    // 池子：10000 X, 20000 Y, 14142 LP
    // 移除：1414 LP (10%)
    // 预期取回：1000 X, 2000 Y
}
```

---

### 任务 5：实现价格影响计算（10分）

#### 要求

```move
#[view]
public fun calculate_price_impact(
    amount_in: u64,
    reserve_in: u64,
    reserve_out: u64,
): u64 {
    // TODO: 计算价格影响（百分比）
    // 返回值放大 1e6 倍（例如 5% = 50000）
}
```

#### 计算步骤

1. 计算当前价格：`P_old = reserve_out / reserve_in`
2. 计算交换后价格：`P_new = new_reserve_out / new_reserve_in`
3. 计算影响：`Impact = |P_new - P_old| / P_old`

#### 评分标准

- ✅ 正确计算旧价格（3分）
- ✅ 正确计算新价格（4分）
- ✅ 正确计算百分比（3分）

---

### 任务 6：添加滑点保护机制（10分）

#### 要求

在所有用户交互函数中添加滑点保护：

1. **添加流动性**：最小 LP Token
2. **移除流动性**：最小代币数量
3. **交换**：最小输出量

#### 示例

```move
// 用户设置：最多接受 1% 滑点
let expected_output = 1000;
let min_output = expected_output * 99 / 100;  // 990

swap_x_to_y(trader, 500, min_output);
```

#### 评分标准

- ✅ 所有函数都有滑点保护（5分）
- ✅ 错误消息清晰（3分）
- ✅ 边界值测试（2分）

---

## 🎮 挑战任务

### 挑战 1：实现多跳路由（+10分）

当没有直接交易对时，通过中间代币完成交换。

```move
// X -> Z -> Y
public entry fun swap_multi_hop<X, Z, Y>(
    trader: &signer,
    amount_in: u64,
    min_amount_out: u64,
) acquires LiquidityPool {
    // TODO: 先用 X 换 Z，再用 Z 换 Y
}
```

**示例**：
```
池子 1：APTOS/USDC
池子 2：USDC/BTC

用户想要：APTOS -> BTC
路由：APTOS -> USDC -> BTC
```

---

### 挑战 2：实现集中流动性（+15分）

参考 Uniswap V3，允许 LP 指定价格范围。

```move
struct ConcentratedPosition has store {
    lower_tick: u64,  // 下界
    upper_tick: u64,  // 上界
    liquidity: u64,
}
```

**难点**：
- Tick 数学计算
- 跨 Tick 交换
- 手续费分配

---

### 挑战 3：Gas 优化（+5分）

优化合约以降低 Gas 消耗：

**优化技巧**：
1. 减少存储读写
2. 使用 `u128` 避免溢出检查
3. 批量操作
4. 缓存重复计算

**目标**：
- 交换操作 < 100 gas units
- 添加流动性 < 150 gas units

---

## 📦 项目结构

```
Day_15_AMM原理与恒定乘积公式/
├── sources/
│   ├── simple_amm.move       # 你的实现（必做任务）
│   ├── advanced_amm.move     # 进阶功能（可选）
│   └── router.move           # 路由器（挑战任务）
├── tests/
│   ├── amm_tests.move        # 单元测试
│   └── integration_tests.move # 集成测试
└── scripts/
    ├── deploy.sh             # 部署脚本
    └── test_swap.sh          # 测试交换脚本
```

---

## 🧪 测试要求

### 单元测试

为每个函数编写至少 3 个测试用例：

```move
#[test]
fun test_add_liquidity_initial_success() {
    // 正常情况
}

#[test]
#[expected_failure(abort_code = ERROR_ZERO_AMOUNT)]
fun test_add_liquidity_zero_amount() {
    // 异常情况：零数量
}

#[test]
fun test_swap_with_fee() {
    // 验证手续费计算
}
```

### 集成测试

测试完整的用户流程：

```move
#[test]
fun test_full_lifecycle() {
    // 1. 创建池子
    // 2. 添加流动性
    // 3. 多次交换
    // 4. 移除流动性
    // 5. 验证最终余额
}
```

---

## 📊 评分标准

### 必做任务（80分）

| 任务 | 分数 | 要求 |
|------|------|------|
| 任务 1 | 15 | 数据结构设计合理 |
| 任务 2 | 20 | 流动性计算正确 |
| 任务 3 | 25 | 交换逻辑正确，含手续费 |
| 任务 4 | 20 | 移除逻辑正确 |

### 进阶任务（20分）

| 任务 | 分数 | 要求 |
|------|------|------|
| 任务 5 | 10 | 价格影响计算准确 |
| 任务 6 | 10 | 滑点保护完善 |

### 代码质量（额外评估）

- ✅ 代码风格规范（-5分 如不符合）
- ✅ 注释清晰完整（-5分 如不符合）
- ✅ 测试覆盖率 ≥ 80%（-10分 如不符合）
- ✅ 无编译警告（-3分 如有警告）

---

## 🚀 开始实现

### Step 1: 设置开发环境

```bash
cd Day_15_AMM原理与恒定乘积公式
aptos init
```

### Step 2: 创建基础文件

```bash
# 创建源文件
mkdir -p sources
touch sources/simple_amm.move

# 创建测试文件
mkdir -p tests
touch tests/amm_tests.move
```

### Step 3: 实现核心功能

按照任务顺序逐个实现，每完成一个任务就：
1. ✅ 编写单元测试
2. ✅ 运行测试验证
3. ✅ 提交代码

```bash
# 编译
aptos move compile

# 测试
aptos move test

# 查看覆盖率
aptos move test --coverage
```

### Step 4: 部署到测试网（可选）

```bash
# 发布模块
aptos move publish --profile testnet

# 调用函数
aptos move run \
  --function-id 'your_address::simple_amm::create_pool' \
  --type-args '0x1::aptos_coin::AptosCoin' '0x1::test_coin::TestCoin'
```

---

## 💡 实现提示

### 提示 1：避免整数溢出

```move
// ❌ 错误：可能溢出
let k = reserve_x * reserve_y;

// ✅ 正确：使用 u128
let k = (reserve_x as u128) * (reserve_y as u128);
```

### 提示 2：平方根计算

```move
// 牛顿迭代法
fun sqrt(x: u128): u64 {
    if (x == 0) return 0;
    let z = (x + 1) / 2;
    let y = x;
    while (z < y) {
        y = z;
        z = (x / z + z) / 2;
    };
    (y as u64)
}
```

### 提示 3：处理精度损失

```move
// 先乘后除，减少精度损失
let amount_out = (amount_in * reserve_out) / (reserve_in + amount_in);

// 不要：
// let ratio = amount_in / reserve_in;
// let amount_out = ratio * reserve_out;  // 精度损失！
```

### 提示 4：比例验证

```move
// 验证添加流动性的比例
let ratio_x = (amount_x as u128) * (reserve_y as u128);
let ratio_y = (amount_y as u128) * (reserve_x as u128);

// 允许 1% 的误差
let diff = if (ratio_x > ratio_y) {
    ratio_x - ratio_y
} else {
    ratio_y - ratio_x
};

assert!(diff * 100 <= ratio_x, ERROR_INVALID_RATIO);
```

---

## 📚 参考资料

### 必读

1. **理论学习**
   - 重读 `01_理论学习/核心概念.md`
   - 特别关注公式推导部分

2. **代码示例**
   - 参考 `01_理论学习/代码示例.move`
   - 理解每个函数的实现

### 推荐阅读

1. [Uniswap V2 源码](https://github.com/Uniswap/v2-core/blob/master/contracts/UniswapV2Pair.sol)
2. [Aptos Coin 框架文档](https://aptos.dev/guides/move-guides/aptos-coin/)
3. [Move 数学库](https://github.com/aptos-labs/aptos-core/tree/main/aptos-move/framework/aptos-stdlib/sources)

---

## ❓ 常见问题

### Q1: 为什么要锁定最小流动性？

**A**: 防止恶意用户通过添加和移除极小流动性来操纵价格。锁定的流动性永久留在池子中。

### Q2: LP Token 为什么用 sqrt(x * y)？

**A**: 几何平均数确保 LP Token 数量与流动性价值成正比，且不受初始价格影响。

### Q3: 如何测试手续费是否正确？

**A**: 验证交换后 `k_new > k_old`，差值就是手续费带来的增长。

```move
#[test]
fun test_fee_accumulation() {
    let k_old = reserve_x * reserve_y;
    
    // 执行交换
    swap_x_to_y(...);
    
    let k_new = new_reserve_x * new_reserve_y;
    assert!(k_new > k_old, 0);  // k 应该增加
}
```

### Q4: 如何处理精度问题？

**A**: 
- 使用 `u128` 进行中间计算
- 先乘后除
- 必要时向上取整

---

## 🎯 完成标准

### 基本要求（通过）

- ✅ 所有必做任务完成
- ✅ 测试通过
- ✅ 代码可以编译
- ✅ 得分 ≥ 56 分（70%）

### 优秀标准

- ✅ 所有任务完成（包括进阶）
- ✅ 测试覆盖率 ≥ 80%
- ✅ 代码规范
- ✅ 得分 ≥ 85 分

### 卓越标准

- ✅ 完成挑战任务
- ✅ 测试覆盖率 100%
- ✅ 性能优化
- ✅ 得分 ≥ 100 分

---

## 📤 提交要求

### 提交内容

```
Day_15_提交/
├── sources/
│   └── *.move
├── tests/
│   └── *.move
├── Move.toml
├── README.md           # 实现说明
└── REPORT.md          # 学习报告
```

### 学习报告要求

```markdown
# Day 15 学习报告

## 1. 完成情况
- [x] 任务 1
- [x] 任务 2
- ...

## 2. 实现亮点
- 描述你的创新点
- 优化措施

## 3. 遇到的问题
- 问题描述
- 解决方案

## 4. 测试结果
- 测试覆盖率：85%
- 所有测试通过

## 5. 学习收获
- 关键概念理解
- 实战经验
```

---

## 🏆 评分示例

### 示例 1：基础实现

```
任务 1: 15/15
任务 2: 18/20  (比例验证有小bug)
任务 3: 23/25  (手续费计算轻微偏差)
任务 4: 20/20
任务 5: 未完成
任务 6: 8/10   (缺少边界测试)

总分: 84/100  ✅ 优秀
```

### 示例 2：完整实现

```
必做任务: 80/80
进阶任务: 20/20
挑战 1: +10
代码质量: 优秀

总分: 110/100  🏆 卓越
```

---

**准备好开始编码了吗？祝你实现愉快！💪**

如有任何问题，请参考：
- 📖 理论学习材料
- 💡 代码示例
- 🤝 社区讨论区

**记住**：理解原理比完成任务更重要。慢慢来，确保每一步都扎实掌握！🚀

# Day 07 å®è·µä»»åŠ¡

## ä»»åŠ¡æ¦‚è¿°

ä»Šå¤©ä½ éœ€è¦å®Œæˆä¸‰ä¸ªå®è·µä»»åŠ¡ï¼Œæ·±å…¥æŒæ¡å…¨å±€å­˜å‚¨æ“ä½œå’Œèµ„æºç®¡ç†æ¨¡å¼ã€‚

---

## ä»»åŠ¡ 1ï¼šç”¨æˆ·è´¦æˆ·ç³»ç»Ÿï¼ˆ35 åˆ†ï¼‰

### ğŸ“‹ ä»»åŠ¡æè¿°

å®ç°ä¸€ä¸ªå®Œæ•´çš„ç”¨æˆ·è´¦æˆ·ç®¡ç†ç³»ç»Ÿï¼ŒåŒ…å«æ³¨å†Œã€æ›´æ–°ã€æŸ¥è¯¢å’Œåˆ é™¤åŠŸèƒ½ã€‚

### ğŸ¯ åŠŸèƒ½è¦æ±‚

1. å®šä¹‰ç”¨æˆ·è´¦æˆ·èµ„æºï¼š
```move
struct UserAccount has key {
    username: vector<u8>,
    email: vector<u8>,
    age: u8,
    balance: u64,
    created_at: u64  // æ—¶é—´æˆ³
}
```

2. å®ç°ä»¥ä¸‹å‡½æ•°ï¼š
   - `register(account: &signer, username: vector<u8>, email: vector<u8>, age: u8)`
   - `update_profile(account: &signer, new_email: vector<u8>, new_age: u8)`
   - `get_user_info(addr: address): (vector<u8>, vector<u8>, u8, u64)`
   - `deposit_balance(account: &signer, amount: u64)`
   - `withdraw_balance(account: &signer, amount: u64)`
   - `transfer_balance(from: &signer, to: address, amount: u64)`
   - `delete_account(account: &signer)`
   - `account_exists(addr: address): bool`

### ğŸ” å®‰å…¨è¦æ±‚

1. æ³¨å†Œå‰æ£€æŸ¥è´¦æˆ·æ˜¯å¦å·²å­˜åœ¨
2. æ›´æ–°å’Œåˆ é™¤æ“ä½œéœ€è¦éªŒè¯æ˜¯èµ„æºæ‰€æœ‰è€…
3. å–æ¬¾å’Œè½¬è´¦éœ€è¦æ£€æŸ¥ä½™é¢æ˜¯å¦å……è¶³
4. åˆ é™¤è´¦æˆ·æ—¶ä½™é¢å¿…é¡»ä¸º 0

### ğŸ’¡ æç¤º

- ä½¿ç”¨ `timestamp::now_seconds()` è·å–å½“å‰æ—¶é—´
- ä½¿ç”¨ `signer::address_of()` è·å–ç­¾åè€…åœ°å€
- ä½¿ç”¨ä½œç”¨åŸŸé¿å…å€Ÿç”¨å†²çª

### âœ… æµ‹è¯•ç”¨ä¾‹

```move
#[test(user1 = @0x1, user2 = @0x2)]
fun test_account_system(user1: &signer, user2: &signer) {
    // æ³¨å†Œ
    register(user1, b"Alice", b"alice@example.com", 25);
    register(user2, b"Bob", b"bob@example.com", 30);
    
    // å­˜æ¬¾
    deposit_balance(user1, 1000);
    deposit_balance(user2, 500);
    
    // è½¬è´¦
    transfer_balance(user1, signer::address_of(user2), 300);
    
    // éªŒè¯ä½™é¢
    let (_, _, _, balance1) = get_user_info(signer::address_of(user1));
    let (_, _, _, balance2) = get_user_info(signer::address_of(user2));
    assert!(balance1 == 700, 0);
    assert!(balance2 == 800, 1);
}
```

---

## ä»»åŠ¡ 2ï¼šèµ„æºæ³¨å†Œè¡¨ï¼ˆ35 åˆ†ï¼‰

### ğŸ“‹ ä»»åŠ¡æè¿°

å®ç°ä¸€ä¸ªä¸­å¿ƒåŒ–çš„èµ„æºæ³¨å†Œè¡¨ï¼Œç”¨äºç®¡ç†å¤šä¸ªç”¨æˆ·çš„æ•°æ®é¡¹ã€‚

### ğŸ¯ åŠŸèƒ½è¦æ±‚

1. å®šä¹‰æ•°æ®ç»“æ„ï¼š
```move
struct DataItem has store, drop {
    id: u64,
    owner: address,
    content: vector<u8>,
    timestamp: u64
}

struct Registry has key {
    items: Table<u64, DataItem>,
    owner_items: Table<address, vector<u64>>,  // ç”¨æˆ·æ‹¥æœ‰çš„é¡¹ç›®IDåˆ—è¡¨
    next_id: u64
}
```

2. å®ç°ä»¥ä¸‹å‡½æ•°ï¼š
   - `initialize_registry(admin: &signer)`ï¼šåˆå§‹åŒ–æ³¨å†Œè¡¨
   - `register_item(user: &signer, registry_addr: address, content: vector<u8>): u64`ï¼šæ³¨å†Œæ–°é¡¹ç›®ï¼Œè¿”å›ID
   - `get_item(registry_addr: address, item_id: u64): DataItem`ï¼šè·å–é¡¹ç›®
   - `update_item(user: &signer, registry_addr: address, item_id: u64, new_content: vector<u8>)`ï¼šæ›´æ–°é¡¹ç›®
   - `delete_item(user: &signer, registry_addr: address, item_id: u64)`ï¼šåˆ é™¤é¡¹ç›®
   - `get_user_items(registry_addr: address, user_addr: address): vector<u64>`ï¼šè·å–ç”¨æˆ·æ‰€æœ‰é¡¹ç›®ID
   - `get_total_items(registry_addr: address): u64`ï¼šè·å–æ€»é¡¹ç›®æ•°

### ğŸ” å®‰å…¨è¦æ±‚

1. åªæœ‰ç®¡ç†å‘˜å¯ä»¥åˆå§‹åŒ–æ³¨å†Œè¡¨
2. åªæœ‰é¡¹ç›®æ‰€æœ‰è€…å¯ä»¥æ›´æ–°å’Œåˆ é™¤é¡¹ç›®
3. åˆ é™¤é¡¹ç›®æ—¶è¦ä» owner_items ä¸­ç§»é™¤

### ğŸ’¡ æç¤º

- ä½¿ç”¨ `table::new()` åˆ›å»ºè¡¨
- ä½¿ç”¨ `table::add()` å’Œ `table::borrow()` æ“ä½œè¡¨
- ä½¿ç”¨ `vector::contains()` æ£€æŸ¥å…ƒç´ æ˜¯å¦å­˜åœ¨

### âœ… æµ‹è¯•ç”¨ä¾‹

```move
#[test(admin = @0x100, user1 = @0x1, user2 = @0x2)]
fun test_registry(admin: &signer, user1: &signer, user2: &signer) {
    // åˆå§‹åŒ–
    initialize_registry(admin);
    let registry_addr = signer::address_of(admin);
    
    // æ³¨å†Œé¡¹ç›®
    let id1 = register_item(user1, registry_addr, b"data1");
    let id2 = register_item(user1, registry_addr, b"data2");
    let id3 = register_item(user2, registry_addr, b"data3");
    
    assert!(id1 == 1 && id2 == 2 && id3 == 3, 0);
    
    // æŸ¥è¯¢ç”¨æˆ·é¡¹ç›®
    let user1_items = get_user_items(registry_addr, signer::address_of(user1));
    assert!(vector::length(&user1_items) == 2, 1);
    
    // æ›´æ–°é¡¹ç›®
    update_item(user1, registry_addr, id1, b"updated_data");
    
    // åˆ é™¤é¡¹ç›®
    delete_item(user1, registry_addr, id2);
}
```

---

## ä»»åŠ¡ 3ï¼šå¤šé‡ç­¾åé’±åŒ…ï¼ˆ30 åˆ†ï¼‰

### ğŸ“‹ ä»»åŠ¡æè¿°

å®ç°ä¸€ä¸ªç®€å•çš„å¤šé‡ç­¾åé’±åŒ…ï¼Œéœ€è¦å¤šä¸ªæ‰€æœ‰è€…æ‰¹å‡†æ‰èƒ½æ‰§è¡Œäº¤æ˜“ã€‚

### ğŸ¯ åŠŸèƒ½è¦æ±‚

1. å®šä¹‰æ•°æ®ç»“æ„ï¼š
```move
struct MultiSigWallet has key {
    owners: vector<address>,
    required_confirmations: u64,
    balance: u64,
    transaction_count: u64
}

struct Transaction has store, drop {
    id: u64,
    to: address,
    amount: u64,
    executed: bool,
    confirmations: vector<address>
}

struct PendingTransactions has key {
    transactions: Table<u64, Transaction>
}
```

2. å®ç°ä»¥ä¸‹å‡½æ•°ï¼š
   - `create_wallet(creator: &signer, owners: vector<address>, required: u64)`
   - `deposit(account: &signer, amount: u64)`
   - `submit_transaction(owner: &signer, to: address, amount: u64): u64`
   - `confirm_transaction(owner: &signer, tx_id: u64)`
   - `execute_transaction(owner: &signer, tx_id: u64)`
   - `get_balance(wallet_addr: address): u64`
   - `is_owner(wallet_addr: address, addr: address): bool`

### ğŸ” å®‰å…¨è¦æ±‚

1. åªæœ‰æ‰€æœ‰è€…å¯ä»¥æäº¤å’Œç¡®è®¤äº¤æ˜“
2. åŒä¸€æ‰€æœ‰è€…ä¸èƒ½é‡å¤ç¡®è®¤åŒä¸€äº¤æ˜“
3. åªæœ‰è¾¾åˆ°æ‰€éœ€ç¡®è®¤æ•°æ‰èƒ½æ‰§è¡Œäº¤æ˜“
4. äº¤æ˜“åªèƒ½æ‰§è¡Œä¸€æ¬¡
5. æ‰§è¡Œäº¤æ˜“æ—¶æ£€æŸ¥ä½™é¢æ˜¯å¦å……è¶³

### ğŸ’¡ æç¤º

- ä½¿ç”¨ `vector::contains()` æ£€æŸ¥æ˜¯å¦ä¸ºæ‰€æœ‰è€…
- äº¤æ˜“æ‰§è¡Œåè®¾ç½® `executed = true`
- ç¡®è®¤æ•° >= required_confirmations æ—¶æ‰èƒ½æ‰§è¡Œ

### âœ… æµ‹è¯•ç”¨ä¾‹

```move
#[test(owner1 = @0x1, owner2 = @0x2, owner3 = @0x3, recipient = @0x99)]
fun test_multisig_wallet(
    owner1: &signer, 
    owner2: &signer, 
    owner3: &signer,
    recipient: &signer
) {
    // åˆ›å»ºé’±åŒ…ï¼ˆ3ä¸ªæ‰€æœ‰è€…ï¼Œéœ€è¦2ä¸ªç¡®è®¤ï¼‰
    let owners = vector::empty<address>();
    vector::push_back(&mut owners, signer::address_of(owner1));
    vector::push_back(&mut owners, signer::address_of(owner2));
    vector::push_back(&mut owners, signer::address_of(owner3));
    
    create_wallet(owner1, owners, 2);
    
    // å­˜æ¬¾
    deposit(owner1, 1000);
    
    // æäº¤äº¤æ˜“
    let tx_id = submit_transaction(owner1, signer::address_of(recipient), 300);
    
    // ç¬¬ä¸€ä¸ªç¡®è®¤
    confirm_transaction(owner1, tx_id);
    
    // ç¬¬äºŒä¸ªç¡®è®¤
    confirm_transaction(owner2, tx_id);
    
    // æ‰§è¡Œäº¤æ˜“
    execute_transaction(owner1, tx_id);
    
    // éªŒè¯ä½™é¢
    assert!(get_balance(signer::address_of(owner1)) == 700, 0);
}
```

---

## æäº¤è¦æ±‚

### ğŸ“‚ æ–‡ä»¶ç»“æ„

```
02_å®è·µä»»åŠ¡/
â”œâ”€â”€ ä½ çš„ç­”æ¡ˆ/
â”‚   â”œâ”€â”€ task1_user_account.move
â”‚   â”œâ”€â”€ task2_registry.move
â”‚   â””â”€â”€ task3_multisig_wallet.move
â””â”€â”€ Move.toml
```

### âœ… éªŒè¯æ–¹æ³•

```bash
aptos move test --filter task1
aptos move test --filter task2
aptos move test --filter task3
```

### ğŸ“Š è¯„åˆ†æ ‡å‡†

| é¡¹ç›® | åˆ†æ•° | è¯„åˆ†è¦ç‚¹ |
|------|------|----------|
| **ä»»åŠ¡ 1** | 35 | åŠŸèƒ½å®Œæ•´ (15) + acquiresæ­£ç¡® (10) + å®‰å…¨æ£€æŸ¥ (10) |
| **ä»»åŠ¡ 2** | 35 | æ³¨å†Œè¡¨è®¾è®¡ (15) + åŠŸèƒ½å®ç° (15) + æƒé™æ§åˆ¶ (5) |
| **ä»»åŠ¡ 3** | 30 | å¤šç­¾é€»è¾‘ (15) + å®‰å…¨éªŒè¯ (10) + æµ‹è¯•é€šè¿‡ (5) |

**æ€»åˆ†**ï¼š100 åˆ†  
**åŠæ ¼çº¿**ï¼š70 åˆ†

---

## ğŸ’¡ å­¦ä¹ å»ºè®®

1. **ä»»åŠ¡ 1**ï¼šå·©å›ºåŸºç¡€çš„èµ„æº CRUD æ“ä½œ
2. **ä»»åŠ¡ 2**ï¼šå­¦ä¹ é›†ä¸­å¼èµ„æºç®¡ç†æ¨¡å¼
3. **ä»»åŠ¡ 3**ï¼šç†è§£å¤æ‚çš„å¤šæ–¹åä½œé€»è¾‘

### å¸¸è§é”™è¯¯

âŒ **å¿˜è®° acquires å£°æ˜**
âŒ **å€Ÿç”¨å†²çª**ï¼šåŒæ—¶å¯å˜å’Œä¸å¯å˜å€Ÿç”¨
âŒ **æƒé™æ£€æŸ¥ä¸å®Œæ•´**ï¼šå…è®¸éæ‰€æœ‰è€…æ“ä½œèµ„æº

**é¢„è®¡å®Œæˆæ—¶é—´**ï¼š3-4 å°æ—¶

åŠ æ²¹ï¼ğŸ’ª

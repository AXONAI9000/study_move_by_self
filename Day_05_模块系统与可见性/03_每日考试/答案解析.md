# Day 05: æ¨¡å—ç³»ç»Ÿä¸å¯è§æ€§ - ç­”æ¡ˆè§£æ

---

## ğŸ“ é€‰æ‹©é¢˜ç­”æ¡ˆä¸è§£æ

### ç¬¬ä¸€éƒ¨åˆ†ï¼šåŸºç¡€çŸ¥è¯†

#### 1. æ­£ç¡®ç­”æ¡ˆï¼šB

**è§£æ**ï¼š
- Move æ¨¡å—çš„æ­£ç¡®å®šä¹‰æ ¼å¼æ˜¯ `module <address>::<module_name> { }`
- åœ°å€åœ¨å‰ï¼Œæ¨¡å—ååœ¨åï¼Œç”¨ `::` åˆ†éš”
- A é€‰é¡¹ç¼ºå°‘åœ°å€
- C å’Œ D é€‰é¡¹æ ¼å¼é”™è¯¯

**ç¤ºä¾‹**ï¼š
```move
module 0x1::my_module { }        // âœ… æ­£ç¡®
module my_addr::token_system { } // âœ… æ­£ç¡®ï¼ˆä½¿ç”¨å‘½ååœ°å€ï¼‰
```

---

#### 2. æ­£ç¡®ç­”æ¡ˆï¼šB

**è§£æ**ï¼š
- åœ¨ Move ä¸­ï¼Œå‡½æ•°é»˜è®¤æ˜¯ç§æœ‰çš„ï¼ˆprivateï¼‰
- åªæœ‰åœ¨æ¨¡å—å†…éƒ¨å¯ä»¥è°ƒç”¨
- å¦‚æœéœ€è¦å¯¹å¤–æš´éœ²ï¼Œå¿…é¡»æ˜¾å¼ä½¿ç”¨ `public` æˆ–å…¶ä»–ä¿®é¥°ç¬¦

**ç¤ºä¾‹**ï¼š
```move
module 0x1::example {
    // ç§æœ‰å‡½æ•°
    fun helper() { }  
    
    // åªèƒ½åœ¨æ¨¡å—å†…è°ƒç”¨
    public fun use_helper() {
        helper();  // âœ… å¯ä»¥
    }
}

module 0x1::other {
    use 0x1::example;
    
    public fun test() {
        example::helper();  // âŒ ç¼–è¯‘é”™è¯¯ï¼
    }
}
```

---

#### 3. æ­£ç¡®ç­”æ¡ˆï¼šC

**è§£æ**ï¼š
- `entry` å‡½æ•°å¯ä»¥ä½œä¸ºäº¤æ˜“çš„å…¥å£ç‚¹ï¼Œç”¨æˆ·å¯ä»¥ç›´æ¥é€šè¿‡äº¤æ˜“è°ƒç”¨
- é™åˆ¶ï¼šä¸èƒ½æœ‰è¿”å›å€¼
- å‚æ•°ç±»å‹æœ‰é™åˆ¶ï¼ˆåŸºæœ¬ç±»å‹ã€`&signer`ã€`vector` ç­‰ï¼‰
- å¯ä»¥ä¸ `public` ç»„åˆä½¿ç”¨

**ç¤ºä¾‹**ï¼š
```move
module 0x1::game {
    // âœ… å¯ä»¥è¢«äº¤æ˜“ç›´æ¥è°ƒç”¨
    entry fun start_game(player: &signer) { }
    
    // âœ… æ—¢å¯ä»¥è¢«äº¤æ˜“è°ƒç”¨ï¼Œä¹Ÿå¯ä»¥è¢«å…¶ä»–æ¨¡å—è°ƒç”¨
    public entry fun join_game(player: &signer) { }
    
    // âŒ é”™è¯¯ï¼šentry å‡½æ•°ä¸èƒ½æœ‰è¿”å›å€¼
    entry fun get_score(): u64 { 100 }
}
```

---

#### 4. æ­£ç¡®ç­”æ¡ˆï¼šA

**è§£æ**ï¼š
- Move ä½¿ç”¨ `use` å…³é”®å­—å¯¼å…¥æ¨¡å—
- å¯ä»¥ä½¿ç”¨ `as` ä¸ºæ¨¡å—è®¾ç½®åˆ«å
- å…¶ä»–è¯­è¨€çš„å…³é”®å­—ï¼ˆimportã€includeã€requireï¼‰åœ¨ Move ä¸­ä¸é€‚ç”¨

**å¯¼å…¥æ–¹å¼æ€»ç»“**ï¼š
```move
// 1. åŸºæœ¬å¯¼å…¥
use std::vector;

// 2. ä½¿ç”¨åˆ«å
use std::vector as vec;

// 3. å¯¼å…¥ç‰¹å®šæˆå‘˜
use std::vector::{push_back, pop_back};

// 4. å¯¼å…¥æ¨¡å—å’Œæˆå‘˜
use std::vector::{Self, push_back};
```

---

#### 5. æ­£ç¡®ç­”æ¡ˆï¼šB

**è§£æ**ï¼š
- Move æ¨¡å—ä¸€æ—¦éƒ¨ç½²åˆ°åŒºå—é“¾å°±æ˜¯**å®Œå…¨ä¸å¯å˜**çš„
- è¿™æ˜¯åŒºå—é“¾å®‰å…¨æ€§çš„é‡è¦ä¿è¯
- ä¸èƒ½ä¿®æ”¹ã€ä¸èƒ½æ·»åŠ ã€ä¸èƒ½åˆ é™¤ä»»ä½•å†…å®¹

**åº”å¯¹ç­–ç•¥**ï¼š
```move
// ç­–ç•¥ 1ï¼šç‰ˆæœ¬åŒ–
module 0x1::token_v1 { }
module 0x1::token_v2 { }

// ç­–ç•¥ 2ï¼šå¯é…ç½®å‚æ•°
module 0x1::config {
    struct Config has key {
        parameter: u64
    }
    
    // é€šè¿‡ä¿®æ”¹é…ç½®è€Œä¸æ˜¯ä»£ç æ¥è°ƒæ•´è¡Œä¸º
}

// ç­–ç•¥ 3ï¼šä»£ç†æ¨¡å¼
module 0x1::proxy {
    struct Registry has key {
        implementation: address
    }
}
```

---

#### 6. æ­£ç¡®ç­”æ¡ˆï¼šC

**è§£æ**ï¼š
- Move æ¨èä½¿ç”¨ **snake_case**ï¼ˆå°å†™å­—æ¯ + ä¸‹åˆ’çº¿ï¼‰å‘½åæ¨¡å—
- è¿™æ˜¯ Move ç¤¾åŒºçš„çº¦å®šä¿—æˆ
- æœ‰åŠ©äºä»£ç çš„å¯è¯»æ€§å’Œä¸€è‡´æ€§

**å‘½åè§„èŒƒ**ï¼š
```move
// âœ… æ¨è
module 0x1::user_account { }
module 0x1::token_manager { }
module 0x1::nft_marketplace { }

// âŒ ä¸æ¨è
module 0x1::UserAccount { }     // PascalCase
module 0x1::tokenManager { }    // camelCase
module 0x1::nft-marketplace { } // kebab-case
```

---

### ç¬¬äºŒéƒ¨åˆ†ï¼šå¯è§æ€§æ§åˆ¶

#### 7. æ­£ç¡®ç­”æ¡ˆï¼šC

**è§£æ**ï¼š
- `public(friend)` å‡½æ•°åªèƒ½è¢«å£°æ˜ä¸ºå‹å…ƒçš„æ¨¡å—è°ƒç”¨
- æä¾›äº†ä»‹äº public å’Œ private ä¹‹é—´çš„è®¿é—®æ§åˆ¶
- ç”¨äºæ¨¡å—é—´çš„å—é™å…±äº«

**ç¤ºä¾‹**ï¼š
```move
module 0x1::treasury {
    friend 0x1::admin;  // å£°æ˜å‹å…ƒ
    
    // åªæœ‰ admin æ¨¡å—å¯ä»¥è°ƒç”¨
    public(friend) fun privileged_operation() { }
}

module 0x1::admin {
    use 0x1::treasury;
    
    public fun do_admin_work() {
        treasury::privileged_operation();  // âœ… å¯ä»¥è°ƒç”¨
    }
}

module 0x1::other {
    use 0x1::treasury;
    
    public fun try_call() {
        treasury::privileged_operation();  // âŒ ç¼–è¯‘é”™è¯¯
    }
}
```

---

#### 8. æ­£ç¡®ç­”æ¡ˆï¼šA

**è§£æ**ï¼š
- `public entry` æ˜¯åˆæ³•çš„ç»„åˆ
- è¡¨ç¤ºå‡½æ•°æ—¢å¯ä»¥ä½œä¸ºäº¤æ˜“å…¥å£ï¼Œä¹Ÿå¯ä»¥è¢«å…¶ä»–æ¨¡å—è°ƒç”¨
- å…¶ä»–ç»„åˆä¸å­˜åœ¨æˆ–è¯­æ³•é”™è¯¯

**å¯è§æ€§ç»„åˆ**ï¼š
```move
module 0x1::valid {
    // âœ… åˆæ³•ç»„åˆ
    public fun f1() { }
    public entry fun f2() { }
    public(friend) fun f3() { }
    entry fun f4() { }
    
    // âŒ éæ³•ç»„åˆ
    // private entry fun f5() { }      // æ²¡æœ‰ private å…³é”®å­—
    // entry friend fun f6() { }       // è¯­æ³•é”™è¯¯
    // public private fun f7() { }     // å†²çª
}
```

---

#### 9. æ­£ç¡®ç­”æ¡ˆï¼šB

**è§£æ**ï¼š
- `entry` å‡½æ•°**ä¸èƒ½æœ‰è¿”å›å€¼**
- è¿™æ˜¯å› ä¸ºäº¤æ˜“æœ¬èº«ä¸è¿”å›å€¼ï¼ˆé™¤äº†æˆåŠŸ/å¤±è´¥ï¼‰
- å¦‚æœéœ€è¦è¿”å›æ•°æ®ï¼Œåº”è¯¥ä½¿ç”¨äº‹ä»¶æˆ–ä¿®æ”¹å­˜å‚¨

**å¯¹æ¯”**ï¼š
```move
module 0x1::comparison {
    // âœ… entry å‡½æ•°ï¼šæ— è¿”å›å€¼
    entry fun register(account: &signer, name: vector<u8>) {
        // å¤„ç†æ³¨å†Œé€»è¾‘
    }
    
    // âœ… public å‡½æ•°ï¼šå¯ä»¥æœ‰è¿”å›å€¼
    public fun get_balance(addr: address): u64 {
        100  // è¿”å›å€¼
    }
    
    // âŒ é”™è¯¯ï¼šentry ä¸èƒ½æœ‰è¿”å›å€¼
    entry fun wrong(): u64 {
        100
    }
}
```

---

#### 10. æ­£ç¡®ç­”æ¡ˆï¼šB

**è§£æ**ï¼š
- å¦‚æœå‡½æ•°éœ€è¦è¢«å…¶ä»–æ¨¡å—è°ƒç”¨**å¹¶ä¸”æœ‰è¿”å›å€¼**ï¼Œå¿…é¡»ä½¿ç”¨ `public`
- `entry` ä¸èƒ½æœ‰è¿”å›å€¼
- `public(friend)` åªå¯¹å‹å…ƒå¯è§
- ç§æœ‰å‡½æ•°åªèƒ½åœ¨æ¨¡å—å†…è°ƒç”¨

**å†³ç­–æ ‘**ï¼š
```
éœ€è¦è¢«å…¶ä»–æ¨¡å—è°ƒç”¨ï¼Ÿ
â”œâ”€ æ˜¯
â”‚  â”œâ”€ éœ€è¦è¿”å›å€¼ï¼Ÿ
â”‚  â”‚  â”œâ”€ æ˜¯ â†’ public
â”‚  â”‚  â””â”€ å¦ â†’ public entry æˆ– entry
â”‚  â””â”€ åªå¯¹ç‰¹å®šæ¨¡å—ï¼Ÿ
â”‚     â””â”€ æ˜¯ â†’ public(friend)
â””â”€ å¦ â†’ ç§æœ‰å‡½æ•°ï¼ˆæ— ä¿®é¥°ç¬¦ï¼‰
```

---

#### 11. æ­£ç¡®ç­”æ¡ˆï¼šB

**è§£æ**ï¼š
- åœ¨ Move ä¸­ï¼Œ**ç»“æ„ä½“å­—æ®µæ€»æ˜¯ç§æœ‰çš„**
- å³ä½¿ç»“æ„ä½“æœ¬èº«æ˜¯ `public`ï¼Œå­—æ®µä¹Ÿä¸èƒ½è¢«å¤–éƒ¨ç›´æ¥è®¿é—®
- å¿…é¡»é€šè¿‡è®¿é—®å™¨ï¼ˆgetterï¼‰å’Œä¿®æ”¹å™¨ï¼ˆsetterï¼‰å‡½æ•°

**ç¤ºä¾‹**ï¼š
```move
module 0x1::user {
    // public ç»“æ„ä½“
    public struct User has drop {
        name: vector<u8>,  // å­—æ®µä»ç„¶æ˜¯ç§æœ‰çš„
        age: u64
    }
    
    // å¿…é¡»æä¾›è®¿é—®å™¨
    public fun get_name(user: &User): vector<u8> {
        user.name  // åªèƒ½åœ¨æ¨¡å—å†…è®¿é—®å­—æ®µ
    }
}

module 0x1::other {
    use 0x1::user::{Self, User};
    
    public fun test(user: &User) {
        let name = user.name;       // âŒ ç¼–è¯‘é”™è¯¯
        let name = user::get_name(user);  // âœ… æ­£ç¡®
    }
}
```

---

#### 12. æ­£ç¡®ç­”æ¡ˆï¼šB

**è§£æ**ï¼š
- å‹å…ƒå£°æ˜å¿…é¡»åœ¨**æ¨¡å—é¡¶éƒ¨**ï¼Œæ‰€æœ‰å…¶ä»–å®šä¹‰ï¼ˆç»“æ„ä½“ã€å‡½æ•°ç­‰ï¼‰ä¹‹å‰
- è¿™æ˜¯ Move çš„è¯­æ³•è¦æ±‚
- æœ‰åŠ©äºå¿«é€Ÿäº†è§£æ¨¡å—çš„ä¾èµ–å…³ç³»

**æ­£ç¡®æ ¼å¼**ï¼š
```move
module 0x1::my_module {
    // âœ… å‹å…ƒå£°æ˜åœ¨æœ€å‰é¢
    friend 0x1::friend_module_1;
    friend 0x1::friend_module_2;
    
    // use è¯­å¥
    use std::signer;
    
    // å¸¸é‡å®šä¹‰
    const ERROR_CODE: u64 = 1;
    
    // ç»“æ„ä½“å®šä¹‰
    struct MyStruct { }
    
    // å‡½æ•°å®šä¹‰
    public fun my_function() { }
}
```

---

#### 13. æ­£ç¡®ç­”æ¡ˆï¼šC

**è§£æ**ï¼š
- ä¸€ä¸ªæ¨¡å—å¯ä»¥æœ‰**ä»»æ„æ•°é‡**çš„å‹å…ƒæ¨¡å—
- æ²¡æœ‰æ•°é‡é™åˆ¶
- ä½†åº”è¯¥è°¨æ…ä½¿ç”¨ï¼Œé¿å…è¿‡åº¦æš´éœ²å†…éƒ¨å®ç°

**å®è·µå»ºè®®**ï¼š
```move
module 0x1::core {
    // å¯ä»¥æœ‰å¤šä¸ªå‹å…ƒ
    friend 0x1::module_a;
    friend 0x1::module_b;
    friend 0x1::module_c;
    friend 0x1::test_helpers;
    
    // ä½†è¦è€ƒè™‘ï¼š
    // 1. å‹å…ƒè¶Šå¤šï¼Œè€¦åˆè¶Šå¼º
    // 2. ç»´æŠ¤æˆæœ¬å¢åŠ 
    // 3. å®‰å…¨é£é™©å¯èƒ½å¢å¤§
}
```

---

### ç¬¬ä¸‰éƒ¨åˆ†ï¼šæ¨¡å—ä¾èµ–ä¸å¯¼å…¥

#### 14. æ­£ç¡®ç­”æ¡ˆï¼šB

**è§£æ**ï¼š
- `use std::vector::{Self, push_back};` å¯¼å…¥äº†ï¼š
  - `Self` - vector æ¨¡å—æœ¬èº«
  - `push_back` - ç‰¹å®šå‡½æ•°
- è¿™æ ·å¯ä»¥åŒæ—¶ä½¿ç”¨ `vector::xxx` å’Œ `push_back`

**å¯¹æ¯”ä¸åŒå¯¼å…¥æ–¹å¼**ï¼š
```move
module 0x1::examples {
    // æ–¹å¼ Aï¼šåªå¯¼å…¥æ¨¡å—
    use std::vector;
    
    public fun example_a() {
        let v = vector::empty<u64>();
        vector::push_back(&mut v, 1);  // å¿…é¡»ä½¿ç”¨æ¨¡å—å‰ç¼€
    }
    
    // æ–¹å¼ Bï¼šå¯¼å…¥æ¨¡å—å’Œå‡½æ•°
    use std::vector::{Self, push_back};
    
    public fun example_b() {
        let v = vector::empty<u64>();
        push_back(&mut v, 1);  // å¯ä»¥ç›´æ¥ä½¿ç”¨
    }
    
    // æ–¹å¼ Cï¼šåªå¯¼å…¥å‡½æ•°
    use std::vector::push_back;
    
    public fun example_c() {
        // let v = vector::empty<u64>();  // âŒ é”™è¯¯ï¼šæ²¡æœ‰å¯¼å…¥ vector
        push_back(&mut v, 1);
    }
}
```

---

#### 15. æ­£ç¡®ç­”æ¡ˆï¼šB

**è§£æ**ï¼š
- Move **ä¸å…è®¸å¾ªç¯ä¾èµ–**
- è¿™æ˜¯ä¸ºäº†ä¿è¯æ¨¡å—çš„ç¼–è¯‘é¡ºåºå’Œä¾èµ–å…³ç³»æ¸…æ™°
- å¦‚æœå‡ºç°å¾ªç¯ä¾èµ–ï¼Œç¼–è¯‘å™¨ä¼šæŠ¥é”™

**é”™è¯¯ç¤ºä¾‹**ï¼š
```move
// âŒ å¾ªç¯ä¾èµ–
module 0x1::a {
    use 0x1::b;  // A ä¾èµ– B
    
    public fun use_b() {
        b::function();
    }
}

module 0x1::b {
    use 0x1::a;  // B ä¾èµ– A - é”™è¯¯ï¼
    
    public fun use_a() {
        a::function();
    }
}
```

**è§£å†³æ–¹æ¡ˆ**ï¼š
```move
// âœ… å¼•å…¥ä¸­é—´å±‚æ‰“ç ´å¾ªç¯
module 0x1::common {
    public fun shared_logic() { }
}

module 0x1::a {
    use 0x1::common;
    
    public fun function_a() {
        common::shared_logic();
    }
}

module 0x1::b {
    use 0x1::common;
    
    public fun function_b() {
        common::shared_logic();
    }
}
```

---

#### 16. æ­£ç¡®ç­”æ¡ˆï¼šB

**è§£æ**ï¼š
- åœ¨ `Move.toml` ä¸­ä½¿ç”¨ `[addresses]` æ®µå®šä¹‰åœ°å€åˆ«å
- æ ¼å¼ï¼š`alias_name = "0xåœ°å€"` æˆ– `alias_name = "_"`
- `_` è¡¨ç¤ºéƒ¨ç½²æ—¶åŠ¨æ€æŒ‡å®š

**Move.toml ç¤ºä¾‹**ï¼š
```toml
[package]
name = "my_project"
version = "1.0.0"

[addresses]
std = "0x1"
aptos_framework = "0x1"
my_project = "_"        # éƒ¨ç½²æ—¶æŒ‡å®š
test_addr = "0x42"      # å›ºå®šæµ‹è¯•åœ°å€

[dependencies]
# ...
```

**ä»£ç ä¸­ä½¿ç”¨**ï¼š
```move
module my_project::core {
    use std::vector;
    use aptos_framework::coin;
}
```

---

#### 17. æ­£ç¡®ç­”æ¡ˆï¼šB

**è§£æ**ï¼š
- `_` ä½œä¸ºåœ°å€å€¼è¡¨ç¤º**éƒ¨ç½²æ—¶åŠ¨æ€æŒ‡å®š**
- åœ¨å¼€å‘æ—¶æä¾›çµæ´»æ€§
- å®é™…éƒ¨ç½²æ—¶å¿…é¡»æŒ‡å®šå…·ä½“åœ°å€

**ä½¿ç”¨åœºæ™¯**ï¼š
```toml
[addresses]
deployer = "_"  # ä¸åŒç¯å¢ƒä½¿ç”¨ä¸åŒåœ°å€
```

**éƒ¨ç½²æ—¶æŒ‡å®š**ï¼š
```bash
# éƒ¨ç½²æ—¶æŒ‡å®šåœ°å€
aptos move publish --named-addresses deployer=0x123456
```

---

#### 18. æ­£ç¡®ç­”æ¡ˆï¼šA

**è§£æ**ï¼š
- å¯¼å…¥ä½†æœªä½¿ç”¨çš„æ¨¡å—ä¼šäº§ç”Ÿç¼–è¯‘è­¦å‘Š
- è¿™æœ‰åŠ©äºä¿æŒä»£ç æ•´æ´
- åˆ é™¤æœªä½¿ç”¨çš„å¯¼å…¥å¯ä»¥æé«˜ä»£ç è´¨é‡

**ç¤ºä¾‹**ï¼š
```move
module 0x1::example {
    use std::vector;  // âš ï¸ è­¦å‘Šï¼šæœªä½¿ç”¨
    use std::signer;  // âœ… ä½¿ç”¨äº†
    
    public fun test(account: &signer) {
        let _addr = signer::address_of(account);
        // vector æœªè¢«ä½¿ç”¨
    }
}
```

---

### ç¬¬å››éƒ¨åˆ†ï¼šé«˜çº§æ¦‚å¿µ

#### 19. æ­£ç¡®ç­”æ¡ˆï¼šC

**è§£æ**ï¼š
- ç”±äºæ¨¡å—ä¸å¯å˜ï¼Œ**ä»£ç†æ¨¡å¼å’Œç‰ˆæœ¬åŒ–**æ˜¯æœ€å¸¸ç”¨çš„ç­–ç•¥
- ä»£ç†æ¨¡å¼ï¼šé€šè¿‡ä»£ç†æ¨¡å—è½¬å‘åˆ°ä¸åŒçš„å®ç°
- ç‰ˆæœ¬åŒ–ï¼šéƒ¨ç½²æ–°ç‰ˆæœ¬æ¨¡å—ï¼Œä¿ç•™æ—§ç‰ˆæœ¬

**å®ç°ç¤ºä¾‹**ï¼š
```move
// ä»£ç†æ¨¡å¼
module 0x1::proxy {
    struct Registry has key {
        implementation_v: u64,
        impl_address: address,
    }
    
    public entry fun upgrade(admin: &signer, new_impl: address) {
        // æ›´æ–°å®ç°åœ°å€
    }
}

// ç‰ˆæœ¬åŒ–
module 0x1::contract_v1 { }
module 0x1::contract_v2 { }  // æ–°ç‰ˆæœ¬
```

---

#### 20. æ­£ç¡®ç­”æ¡ˆï¼šC

**è§£æ**ï¼š
- åœ¨åˆ†å±‚æ¶æ„ä¸­ï¼Œ**entry å‡½æ•°åº”è¯¥åœ¨ API/æ¥å£å±‚**
- è¿™ä¸€å±‚è´Ÿè´£ä¸å¤–éƒ¨äº¤äº’ï¼ˆç”¨æˆ·äº¤æ˜“ï¼‰
- æ ¸å¿ƒå±‚å’Œé€»è¾‘å±‚åº”è¯¥ä¸“æ³¨äºå†…éƒ¨å®ç°

**åˆ†å±‚æ¶æ„ç¤ºä¾‹**ï¼š
```move
// âŒ ä¸å¥½ï¼šentry åœ¨æ ¸å¿ƒå±‚
module project::core {
    entry fun process() { }  // æ··æ·†äº†èŒè´£
}

// âœ… å¥½ï¼šæ¸…æ™°çš„åˆ†å±‚
module project::core {
    // æ ¸å¿ƒæ•°æ®ç»“æ„
    public struct Data has key { }
}

module project::logic {
    // ä¸šåŠ¡é€»è¾‘
    public fun calculate() { }
}

module project::api {
    // API å±‚ï¼šentry å‡½æ•°åœ¨è¿™é‡Œ
    public entry fun user_action(account: &signer) {
        // è°ƒç”¨é€»è¾‘å±‚
    }
}
```

---

## ğŸ’» ç¼–ç¨‹é¢˜å‚è€ƒç­”æ¡ˆ

### ç¬¬ 1 é¢˜ï¼šç”¨æˆ·æ³¨å†Œç³»ç»Ÿ

```move
// sources/user_registry.move
module 0x1::user_registry {
    use std::vector;
    
    /// ç”¨æˆ·ä¿¡æ¯ç»“æ„ä½“
    public struct UserInfo has store, drop {
        username: vector<u8>,
        registration_time: u64,
        is_active: bool,
    }
    
    /// ç”¨æˆ·æ³¨å†Œè¡¨
    public struct UserRegistry has key {
        users: vector<UserInfo>,
        total_users: u64,
    }
    
    /// åˆ›å»ºç”¨æˆ·ä¿¡æ¯
    public fun create_user_info(name: vector<u8>, time: u64): UserInfo {
        UserInfo {
            username: name,
            registration_time: time,
            is_active: true,
        }
    }
    
    /// è·å–æ€»ç”¨æˆ·æ•°
    public fun get_total_users(registry: &UserRegistry): u64 {
        registry.total_users
    }
    
    /// è·å–ç”¨æˆ·æ•°é‡
    public fun get_user_count(registry: &UserRegistry): u64 {
        vector::length(&registry.users)
    }
}

// sources/user_service.move
module 0x1::user_service {
    use 0x1::user_registry::{Self, UserRegistry, UserInfo};
    use std::signer;
    use std::vector;
    
    const ERROR_REGISTRY_EXISTS: u64 = 1;
    const ERROR_REGISTRY_NOT_FOUND: u64 = 2;
    const ERROR_INVALID_INDEX: u64 = 3;
    
    /// åˆå§‹åŒ–ç”¨æˆ·æ³¨å†Œè¡¨
    public entry fun initialize(account: &signer) {
        let addr = signer::address_of(account);
        assert!(!exists<UserRegistry>(addr), ERROR_REGISTRY_EXISTS);
        
        let registry = UserRegistry {
            users: vector::empty<UserInfo>(),
            total_users: 0,
        };
        move_to(account, registry);
    }
    
    /// æ³¨å†Œæ–°ç”¨æˆ·
    public entry fun register_user(
        account: &signer,
        username: vector<u8>,
        time: u64
    ) acquires UserRegistry {
        let addr = signer::address_of(account);
        assert!(exists<UserRegistry>(addr), ERROR_REGISTRY_NOT_FOUND);
        
        let registry = borrow_global_mut<UserRegistry>(addr);
        let user = user_registry::create_user_info(username, time);
        
        vector::push_back(&mut registry.users, user);
        registry.total_users = registry.total_users + 1;
    }
    
    /// åœç”¨ç”¨æˆ·
    public entry fun deactivate_user(
        account: &signer,
        user_index: u64
    ) acquires UserRegistry {
        let addr = signer::address_of(account);
        let registry = borrow_global_mut<UserRegistry>(addr);
        
        let users_len = vector::length(&registry.users);
        assert!(user_index < users_len, ERROR_INVALID_INDEX);
        
        let user = vector::borrow_mut(&mut registry.users, user_index);
        user.is_active = false;
    }
}
```

**è¯„åˆ†è¦ç‚¹**ï¼š
- âœ… ç»“æ„ä½“å®šä¹‰æ­£ç¡®ï¼Œä½¿ç”¨äº†é€‚å½“çš„èƒ½åŠ›
- âœ… å¯è§æ€§è®¾ç½®åˆç†ï¼ˆpublic, entryï¼‰
- âœ… æ¨¡å—å¯¼å…¥æ­£ç¡®
- âœ… ä¸šåŠ¡é€»è¾‘å®Œæ•´
- âœ… æœ‰é”™è¯¯å¤„ç†

---

### ç¬¬ 2 é¢˜ï¼šè®¿é—®æ§åˆ¶ç³»ç»Ÿ

```move
// sources/access_control.move
module 0x1::access_control {
    use std::signer;
    
    friend 0x1::admin_operations;
    
    // è§’è‰²å¸¸é‡
    const ROLE_ADMIN: u8 = 1;
    const ROLE_MODERATOR: u8 = 2;
    const ROLE_USER: u8 = 3;
    
    // é”™è¯¯å¸¸é‡
    const ERROR_NOT_AUTHORIZED: u64 = 1;
    const ERROR_INVALID_ROLE: u64 = 2;
    const ERROR_ACCOUNT_EXISTS: u64 = 3;
    const ERROR_ACCOUNT_NOT_FOUND: u64 = 4;
    
    /// è´¦æˆ·èµ„æº
    public struct Account has key {
        role: u8,
        created_at: u64,
    }
    
    /// æ³¨å†Œè´¦æˆ·ï¼ˆé»˜è®¤ä¸ºæ™®é€šç”¨æˆ·ï¼‰
    public entry fun register(account: &signer) {
        let addr = signer::address_of(account);
        assert!(!exists<Account>(addr), ERROR_ACCOUNT_EXISTS);
        
        move_to(account, Account {
            role: ROLE_USER,
            created_at: 0,  // å®é™…åº”è¯¥ä½¿ç”¨æ—¶é—´æˆ³
        });
    }
    
    /// è·å–ç”¨æˆ·è§’è‰²
    public fun get_role(addr: address): u8 acquires Account {
        assert!(exists<Account>(addr), ERROR_ACCOUNT_NOT_FOUND);
        let account = borrow_global<Account>(addr);
        account.role
    }
    
    /// è®¾ç½®è§’è‰²ï¼ˆå‹å…ƒå‡½æ•°ï¼‰
    public(friend) fun set_role(addr: address, new_role: u8) acquires Account {
        // éªŒè¯è§’è‰²æœ‰æ•ˆæ€§
        assert!(
            new_role == ROLE_ADMIN || 
            new_role == ROLE_MODERATOR || 
            new_role == ROLE_USER,
            ERROR_INVALID_ROLE
        );
        
        assert!(exists<Account>(addr), ERROR_ACCOUNT_NOT_FOUND);
        
        let account = borrow_global_mut<Account>(addr);
        account.role = new_role;
    }
    
    /// æ£€æŸ¥æ˜¯å¦ä¸ºç®¡ç†å‘˜
    public fun is_admin(addr: address): bool acquires Account {
        if (!exists<Account>(addr)) {
            return false
        };
        
        let account = borrow_global<Account>(addr);
        account.role == ROLE_ADMIN
    }
    
    /// æ£€æŸ¥æ˜¯å¦ä¸ºç‰ˆä¸»
    public fun is_moderator(addr: address): bool acquires Account {
        if (!exists<Account>(addr)) {
            return false
        };
        
        let account = borrow_global<Account>(addr);
        account.role == ROLE_MODERATOR
    }
}

// sources/admin_operations.move
module 0x1::admin_operations {
    use 0x1::access_control;
    use std::signer;
    
    const ERROR_NOT_ADMIN: u64 = 100;
    const ERROR_ALREADY_ADMIN: u64 = 101;
    
    /// ç®¡ç†å‘˜èƒ½åŠ›
    struct AdminCapability has key {}
    
    /// åˆå§‹åŒ–ç®¡ç†å‘˜
    public entry fun initialize_admin(account: &signer) {
        let addr = signer::address_of(account);
        
        // ç¡®ä¿è¿˜æ²¡æœ‰ç®¡ç†å‘˜èƒ½åŠ›
        assert!(!exists<AdminCapability>(addr), ERROR_ALREADY_ADMIN);
        
        // æˆäºˆç®¡ç†å‘˜èƒ½åŠ›
        move_to(account, AdminCapability {});
        
        // åœ¨è®¿é—®æ§åˆ¶ä¸­æ³¨å†Œä¸ºç®¡ç†å‘˜
        if (!access_control::is_admin(addr)) {
            access_control::register(account);
            access_control::set_role(addr, 1);  // ROLE_ADMIN
        };
    }
    
    /// æå‡ä¸ºç‰ˆä¸»
    public entry fun promote_to_moderator(
        admin: &signer,
        target: address
    ) acquires AdminCapability {
        // éªŒè¯è°ƒç”¨è€…æ˜¯ç®¡ç†å‘˜
        let admin_addr = signer::address_of(admin);
        assert!(exists<AdminCapability>(admin_addr), ERROR_NOT_ADMIN);
        
        // è°ƒç”¨å‹å…ƒå‡½æ•°
        access_control::set_role(target, 2);  // ROLE_MODERATOR
    }
    
    /// é™çº§ä¸ºæ™®é€šç”¨æˆ·
    public entry fun demote_to_user(
        admin: &signer,
        target: address
    ) acquires AdminCapability {
        // éªŒè¯è°ƒç”¨è€…æ˜¯ç®¡ç†å‘˜
        let admin_addr = signer::address_of(admin);
        assert!(exists<AdminCapability>(admin_addr), ERROR_NOT_ADMIN);
        
        // è°ƒç”¨å‹å…ƒå‡½æ•°
        access_control::set_role(target, 3);  // ROLE_USER
    }
    
    /// æå‡ä¸ºç®¡ç†å‘˜
    public entry fun promote_to_admin(
        admin: &signer,
        target: address
    ) acquires AdminCapability {
        let admin_addr = signer::address_of(admin);
        assert!(exists<AdminCapability>(admin_addr), ERROR_NOT_ADMIN);
        
        access_control::set_role(target, 1);  // ROLE_ADMIN
    }
}
```

**è¯„åˆ†è¦ç‚¹**ï¼š
- âœ… å‹å…ƒå£°æ˜æ­£ç¡®
- âœ… å¸¸é‡å®šä¹‰å®Œæ•´
- âœ… æƒé™éªŒè¯ä¸¥æ ¼
- âœ… è§’è‰²ç®¡ç†åŠŸèƒ½å®Œæ•´
- âœ… é”™è¯¯å¤„ç†å®Œå–„

---

### ç¬¬ 3 é¢˜ï¼šä»£å¸è½¬è´¦ç³»ç»Ÿ

```move
// sources/token_core.move
module 0x1::token_core {
    /// ä»£å¸ç»“æ„ä½“
    public struct Token has store, drop {
        value: u64,
    }
    
    /// åˆ›å»ºä»£å¸
    public fun create_token(value: u64): Token {
        Token { value }
    }
    
    /// è·å–ä»£å¸ä»·å€¼
    public fun get_value(token: &Token): u64 {
        token.value
    }
    
    /// é”€æ¯ä»£å¸å¹¶è¿”å›ä»·å€¼
    public fun destroy_token(token: Token): u64 {
        let Token { value } = token;
        value
    }
    
    /// åˆå¹¶ä¸¤ä¸ªä»£å¸
    public fun merge_tokens(token1: Token, token2: Token): Token {
        let value1 = destroy_token(token1);
        let value2 = destroy_token(token2);
        create_token(value1 + value2)
    }
    
    /// åˆ†å‰²ä»£å¸
    public fun split_token(token: Token, amount: u64): (Token, Token) {
        let total = get_value(&token);
        assert!(total >= amount, 1);
        
        destroy_token(token);
        (create_token(amount), create_token(total - amount))
    }
}

// sources/token_logic.move
module 0x1::token_logic {
    use 0x1::token_core::{Self, Token};
    
    friend 0x1::token_api;
    
    const ERROR_INSUFFICIENT_BALANCE: u64 = 1;
    
    /// ä½™é¢èµ„æº
    public struct Balance has key {
        amount: u64,
    }
    
    /// åˆ›å»ºä½™é¢ï¼ˆå‹å…ƒå‡½æ•°ï¼‰
    public(friend) fun create_balance(): Balance {
        Balance { amount: 0 }
    }
    
    /// å­˜æ¬¾ï¼ˆå‹å…ƒå‡½æ•°ï¼‰
    public(friend) fun deposit(balance: &mut Balance, token: Token) {
        let value = token_core::destroy_token(token);
        balance.amount = balance.amount + value;
    }
    
    /// å–æ¬¾ï¼ˆå‹å…ƒå‡½æ•°ï¼‰
    public(friend) fun withdraw(balance: &mut Balance, amount: u64): Token {
        assert!(balance.amount >= amount, ERROR_INSUFFICIENT_BALANCE);
        balance.amount = balance.amount - amount;
        token_core::create_token(amount)
    }
    
    /// è·å–ä½™é¢
    public fun get_balance(balance: &Balance): u64 {
        balance.amount
    }
}

// sources/token_api.move
module 0x1::token_api {
    use 0x1::token_core;
    use 0x1::token_logic::{Self, Balance};
    use std::signer;
    
    const ERROR_ACCOUNT_EXISTS: u64 = 1;
    const ERROR_ACCOUNT_NOT_FOUND: u64 = 2;
    const ERROR_RECIPIENT_NOT_FOUND: u64 = 3;
    
    /// åˆå§‹åŒ–è´¦æˆ·
    public entry fun initialize_account(account: &signer) {
        let addr = signer::address_of(account);
        assert!(!exists<Balance>(addr), ERROR_ACCOUNT_EXISTS);
        
        let balance = token_logic::create_balance();
        move_to(account, balance);
    }
    
    /// é“¸é€ ä»£å¸
    public entry fun mint_tokens(
        account: &signer,
        amount: u64
    ) acquires Balance {
        let addr = signer::address_of(account);
        assert!(exists<Balance>(addr), ERROR_ACCOUNT_NOT_FOUND);
        
        let token = token_core::create_token(amount);
        let balance = borrow_global_mut<Balance>(addr);
        token_logic::deposit(balance, token);
    }
    
    /// è½¬è´¦
    public entry fun transfer(
        from: &signer,
        to: address,
        amount: u64
    ) acquires Balance {
        let from_addr = signer::address_of(from);
        
        // æ£€æŸ¥è´¦æˆ·å­˜åœ¨
        assert!(exists<Balance>(from_addr), ERROR_ACCOUNT_NOT_FOUND);
        assert!(exists<Balance>(to), ERROR_RECIPIENT_NOT_FOUND);
        
        // ä»å‘é€è€…å–æ¬¾
        let from_balance = borrow_global_mut<Balance>(from_addr);
        let token = token_logic::withdraw(from_balance, amount);
        
        // å­˜å…¥æ¥æ”¶è€…
        let to_balance = borrow_global_mut<Balance>(to);
        token_logic::deposit(to_balance, token);
    }
    
    /// æŸ¥è¯¢ä½™é¢
    public fun get_balance(addr: address): u64 acquires Balance {
        assert!(exists<Balance>(addr), ERROR_ACCOUNT_NOT_FOUND);
        let balance = borrow_global<Balance>(addr);
        token_logic::get_balance(balance)
    }
    
    /// é”€æ¯ä»£å¸
    public entry fun burn_tokens(
        account: &signer,
        amount: u64
    ) acquires Balance {
        let addr = signer::address_of(account);
        let balance = borrow_global_mut<Balance>(addr);
        let token = token_logic::withdraw(balance, amount);
        token_core::destroy_token(token);
    }
}
```

**è¯„åˆ†è¦ç‚¹**ï¼š
- âœ… æ¨¡å—åˆ†å±‚æ¸…æ™°ï¼ˆCore â†’ Logic â†’ APIï¼‰
- âœ… å‹å…ƒæœºåˆ¶ä½¿ç”¨æ­£ç¡®
- âœ… ä»£å¸åˆ›å»ºå’Œé”€æ¯é€»è¾‘å®Œæ•´
- âœ… è½¬è´¦åŠŸèƒ½æ­£ç¡®å®ç°
- âœ… å®Œå–„çš„é”™è¯¯å¤„ç†

---

## ğŸ“Š å­¦ä¹ è¯„ä¼°

æ ¹æ®ä½ çš„ç­”é¢˜æƒ…å†µè¯„ä¼°ï¼š

### é€‰æ‹©é¢˜è¯„ä¼°
- **18-20 é¢˜æ­£ç¡®**ï¼ˆ90-100åˆ†ï¼‰ï¼šä¼˜ç§€ï¼å®Œå…¨æŒæ¡
- **15-17 é¢˜æ­£ç¡®**ï¼ˆ75-89åˆ†ï¼‰ï¼šè‰¯å¥½ï¼Œç»§ç»­ä¿æŒ
- **12-14 é¢˜æ­£ç¡®**ï¼ˆ60-74åˆ†ï¼‰ï¼šåŠæ ¼ï¼Œéœ€åŠ å¼º
- **<12 é¢˜**ï¼šéœ€è¦é‡æ–°å­¦ä¹ åŸºç¡€æ¦‚å¿µ

### ç¼–ç¨‹é¢˜è¯„ä¼°
- **èƒ½ç‹¬ç«‹å®Œæˆæ‰€æœ‰é¢˜ç›®**ï¼šä¼˜ç§€
- **å®Œæˆ 2 é¢˜ï¼Œå‚è€ƒç­”æ¡ˆå®Œæˆ 1 é¢˜**ï¼šè‰¯å¥½
- **å‚è€ƒç­”æ¡ˆå®Œæˆå¤§éƒ¨åˆ†**ï¼šéœ€è¦æ›´å¤šå®è·µ
- **éš¾ä»¥ç†è§£ç­”æ¡ˆä»£ç **ï¼šéœ€è¦åŠ å¼ºåŸºç¡€

---

## ğŸ¯ æ”¹è¿›å»ºè®®

### å¦‚æœé€‰æ‹©é¢˜å¾—åˆ†ä¸ç†æƒ³ï¼š
1. é‡æ–°é˜…è¯»æ ¸å¿ƒæ¦‚å¿µæ–‡æ¡£
2. å¯¹æ¯”ä»£ç ç¤ºä¾‹ç†è§£æ¦‚å¿µ
3. ç”»å›¾ç†è§£æ¨¡å—å…³ç³»
4. åšç¬”è®°æ€»ç»“å…³é”®ç‚¹

### å¦‚æœç¼–ç¨‹é¢˜é‡åˆ°å›°éš¾ï¼š
1. ä»ç®€å•ä»»åŠ¡å¼€å§‹
2. å…ˆç†è§£ç­”æ¡ˆä»£ç 
3. å°è¯•ä¿®æ”¹ç­”æ¡ˆä»£ç 
4. ç‹¬ç«‹å®ç°ç±»ä¼¼åŠŸèƒ½
5. å¤šå†™ã€å¤šç»ƒã€å¤šæ€è€ƒ

---

**ç»§ç»­åŠ æ²¹ï¼å®è·µæ˜¯æœ€å¥½çš„è€å¸ˆï¼** ğŸš€

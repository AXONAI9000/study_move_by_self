# Day 21 è€ƒè¯•ç­”æ¡ˆè§£æ

## ğŸ“š é€‰æ‹©é¢˜ç­”æ¡ˆè§£æ

### ç¬¬ 1 é¢˜ï¼šå¥åº·å› å­çš„ç‰©ç†æ„ä¹‰

**æ­£ç¡®ç­”æ¡ˆï¼šB**

**è¯¦ç»†è§£æ**ï¼š

å¥åº·å› å­ï¼ˆHealth Factor, HFï¼‰æ˜¯å€Ÿè´·åè®®ä¸­æœ€é‡è¦çš„é£é™©æŒ‡æ ‡ï¼š

```
å®šä¹‰ï¼š
  HF = (è°ƒæ•´åçš„æŠµæŠ¼å“ä»·å€¼) / (å€ºåŠ¡ä»·å€¼)
  HF = Î£(æŠµæŠ¼å“i Ã— ä»·æ ¼i Ã— æŠµæŠ¼ç‡i) / Î£(å€ºåŠ¡j Ã— ä»·æ ¼j)

ç‰©ç†æ„ä¹‰ï¼š
  - è¡¨ç¤ºæŠµæŠ¼å“è¦†ç›–å€ºåŠ¡çš„èƒ½åŠ›
  - HF = 1.0: æŠµæŠ¼å“æ°å¥½è¦†ç›–å€ºåŠ¡
  - HF > 1.0: æŠµæŠ¼å“è¶³å¤Ÿï¼Œå®‰å…¨
  - HF < 1.0: æŠµæŠ¼å“ä¸è¶³ï¼Œè§¦å‘æ¸…ç®—
```

**é€‰é¡¹åˆ†æ**ï¼š
- Aé”™è¯¯ï¼šä¸æ˜¯ä¿¡ç”¨è¯„åˆ†ï¼Œè€Œæ˜¯æŠµæŠ¼è¦†ç›–ç‡
- Cé”™è¯¯ï¼šåˆ©ç‡ç”±å€Ÿè´·å¸‚åœºå†³å®šï¼Œä¸HFä¸åŒ
- Dé”™è¯¯ï¼šæ¸…ç®—å¥–åŠ±æ˜¯å›ºå®šæ¯”ä¾‹ï¼Œä¸ç­‰äºHF

---

### ç¬¬ 2 é¢˜ï¼šæŠµæŠ¼ç‡ï¼ˆLTVï¼‰çš„å«ä¹‰

**æ­£ç¡®ç­”æ¡ˆï¼šC**

**è¯¦ç»†è§£æ**ï¼š

æŠµæŠ¼ç‡ï¼ˆLoan-to-Value Ratio, LTVï¼‰æ˜¯å€Ÿè´·åè®®çš„æ ¸å¿ƒå‚æ•°ï¼š

```
å®šä¹‰ï¼š
  æŠµæŠ¼ç‡ = å¯å€Ÿé‡‘é¢ / æŠµæŠ¼å“ä»·å€¼

ç¤ºä¾‹ï¼š
  æŠµæŠ¼ç‡ 75% æ„å‘³ç€ï¼š
  - å­˜å…¥ä»·å€¼ $1000 çš„ ETH
  - æœ€å¤šå¯ä»¥å€Ÿ $750
  - å‰©ä½™ $250 æ˜¯å®‰å…¨ç¼“å†²
```

**ä¸åŒèµ„äº§çš„å…¸å‹æŠµæŠ¼ç‡**ï¼š
```
ç¨³å®šå¸(USDC/DAI): 80-85%  (ä»·æ ¼ç¨³å®š)
ä¸»æµå¸(ETH/BTC):  70-75%  (ä¸­ç­‰æ³¢åŠ¨)
å±±å¯¨å¸:           30-50%  (é«˜æ³¢åŠ¨)
NFT:             20-40%  (æµåŠ¨æ€§å·®)
```

---

### ç¬¬ 3 é¢˜ï¼šå¥åº·å› å­è®¡ç®—

**æ­£ç¡®ç­”æ¡ˆï¼šC (1.33)**

**è¯¦ç»†è§£æ**ï¼š

```
å·²çŸ¥ï¼š
  æŠµæŠ¼ï¼š1 ETH
  ä»·æ ¼ï¼š$2000
  æŠµæŠ¼ç‡ï¼š80%
  å€Ÿæ¬¾ï¼š$1200 USDC

è®¡ç®—æ­¥éª¤ï¼š

1. è®¡ç®—æŠµæŠ¼èƒ½åŠ›
   æŠµæŠ¼èƒ½åŠ› = æŠµæŠ¼å“ä»·å€¼ Ã— æŠµæŠ¼ç‡
           = $2000 Ã— 80%
           = $1600

2. è®¡ç®—å¥åº·å› å­
   HF = æŠµæŠ¼èƒ½åŠ› / å€ºåŠ¡
      = $1600 / $1200
      = 1.333...
      â‰ˆ 1.33
```

**éªŒè¯**ï¼š
- HF = 1.33 > 1.0 âœ… å®‰å…¨
- HF = 1.33 < 1.5 ğŸŸ¡ éœ€è¦æ³¨æ„

---

### ç¬¬ 6 é¢˜ï¼šå¤šèµ„äº§å¥åº·å› å­

**æ­£ç¡®ç­”æ¡ˆï¼šC (1.44)** 

**æ³¨ï¼šé¢˜ç›®é€‰é¡¹å¯èƒ½æœ‰è¯¯ï¼Œå®é™…åº”ä¸º 1.28**

**è¯¦ç»†è§£æ**ï¼š

```
å·²çŸ¥ï¼š
  æŠµæŠ¼ï¼š
    - 1 ETH ($2000, 75%)
    - 1000 USDC ($1000, 80%)
  å€Ÿæ¬¾ï¼š$1800

è®¡ç®—æ­¥éª¤ï¼š

1. è®¡ç®—å„æŠµæŠ¼å“çš„æŠµæŠ¼èƒ½åŠ›
   ETH:  $2000 Ã— 75% = $1500
   USDC: $1000 Ã— 80% = $800

2. è®¡ç®—æ€»æŠµæŠ¼èƒ½åŠ›
   æ€»è®¡ = $1500 + $800 = $2300

3. è®¡ç®—å¥åº·å› å­
   HF = $2300 / $1800
      = 1.2777...
      â‰ˆ 1.28
```

**å®é™…åº”ç”¨**ï¼š
```
å¦‚æœè¦å€Ÿæ»¡é¢åº¦ï¼š
  æœ€å¤§å€Ÿæ¬¾ = $2300
  
å¦‚æœè¦ä¿æŒ HF = 1.5:
  å®‰å…¨å€Ÿæ¬¾ = $2300 / 1.5 = $1533
```

---

### ç¬¬ 7 é¢˜ï¼šå­˜æ¬¾ vs æŠµæŠ¼å“

**æ­£ç¡®ç­”æ¡ˆï¼šB**

**è¯¦ç»†è§£æ**ï¼š

```
æ¦‚å¿µå¯¹æ¯”ï¼š

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ç‰¹æ€§     â”‚ å­˜æ¬¾     â”‚ æŠµæŠ¼å“     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ å®šä¹‰     â”‚ åœ¨åè®®ä¸­ â”‚ å·²å¯ç”¨çš„   â”‚
â”‚          â”‚ æœ‰èµ„é‡‘   â”‚ å­˜æ¬¾       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ å€Ÿæ¬¾èƒ½åŠ› â”‚ æ—        â”‚ æœ‰         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ æå–é™åˆ¶ â”‚ æ— é™åˆ¶   â”‚ å—HFé™åˆ¶   â”‚
â”‚          â”‚(æ— å€Ÿæ¬¾æ—¶)â”‚            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ æ”¶ç›Š     â”‚ å­˜æ¬¾åˆ©æ¯ â”‚ å­˜æ¬¾åˆ©æ¯   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ æ¸…ç®—é£é™© â”‚ æ—        â”‚ æœ‰(æœ‰å€Ÿæ¬¾  â”‚
â”‚          â”‚          â”‚ æ—¶)        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**ç”¨æˆ·ç­–ç•¥**ï¼š
1. åªæƒ³èµšå–åˆ©æ¯ â†’ ä»…å­˜æ¬¾ï¼Œä¸å¯ç”¨æŠµæŠ¼
2. éœ€è¦å€Ÿæ¬¾ â†’ å¯ç”¨æŠµæŠ¼å“
3. ä»·æ ¼ä¸‹è·Œæ‹…å¿ƒæ¸…ç®— â†’ ç¦ç”¨éƒ¨åˆ†æŠµæŠ¼å“

---

### ç¬¬ 16 é¢˜ï¼šåŠ æƒå¹³å‡æŠµæŠ¼ç‡

**æ­£ç¡®ç­”æ¡ˆï¼šC (70%)**

**è¯¦ç»†è§£æ**ï¼š

```
å·²çŸ¥ï¼š
  èµ„äº§A: $1000, æŠµæŠ¼ç‡ 60%
  èµ„äº§B: $2000, æŠµæŠ¼ç‡ 70%
  èµ„äº§C: $1000, æŠµæŠ¼ç‡ 80%

åŠ æƒå¹³å‡å…¬å¼ï¼š
  åŠ æƒæŠµæŠ¼ç‡ = Î£(ä»·å€¼i Ã— æŠµæŠ¼ç‡i) / Î£(ä»·å€¼i)

è®¡ç®—ï¼š
  åˆ†å­ = $1000 Ã— 60% + $2000 Ã— 70% + $1000 Ã— 80%
       = $600 + $1400 + $800
       = $2800
  
  åˆ†æ¯ = $1000 + $2000 + $1000
       = $4000
  
  åŠ æƒæŠµæŠ¼ç‡ = $2800 / $4000
             = 0.70
             = 70%
```

**æ„ä¹‰**ï¼š
è™½ç„¶æœ‰èµ„äº§çš„æŠµæŠ¼ç‡é«˜è¾¾ 80%ï¼Œä½†å› ä¸ºå¤§éƒ¨åˆ†ä»·å€¼ï¼ˆ$2000ï¼‰é›†ä¸­åœ¨æŠµæŠ¼ç‡ 70% çš„èµ„äº§ä¸Šï¼Œæ‰€ä»¥æ•´ä½“åŠ æƒæŠµæŠ¼ç‡ä¸º 70%ã€‚

---

## ğŸ’» ç¼–ç¨‹é¢˜å‚è€ƒç­”æ¡ˆ

### ç¬¬ 1 é¢˜ï¼šå¥åº·å› å­è®¡ç®—å™¨

```move
module collateral_exam::health_factor_calculator {
    use std::vector;
    
    // å¸¸é‡
    const PRECISION: u128 = 1_000_000_000_000_000_000; // 1e18
    const PRICE_PRECISION: u128 = 100_000_000; // 1e8
    const FACTOR_PRECISION: u128 = 1_000_000; // 1e6
    const MAX_U128: u128 = 340282366920938463463374607431768211455;
    
    // é”™è¯¯ç 
    const E_OVERFLOW: u64 = 1;
    
    /// æŠµæŠ¼å“ä¿¡æ¯
    struct CollateralInfo has drop {
        amount: u128,
        price: u128,
        collateral_factor: u128,
    }
    
    /// å€Ÿæ¬¾ä¿¡æ¯
    struct BorrowInfo has drop {
        amount: u128,
        price: u128,
    }
    
    /// è®¡ç®—å¥åº·å› å­
    /// è¿”å›ï¼šå¥åº·å› å­ï¼ˆç²¾åº¦ 1e18ï¼‰
    public fun calculate_health_factor(
        collaterals: vector<CollateralInfo>,
        borrows: vector<BorrowInfo>,
    ): u128 {
        let collateral_value = calculate_total_collateral_value(&collaterals);
        let debt_value = calculate_total_debt_value(&borrows);
        
        // æ— å€ºåŠ¡æ—¶ï¼Œå¥åº·å› å­ä¸ºæ— é™å¤§
        if (debt_value == 0) {
            return MAX_U128
        };
        
        // æ— æŠµæŠ¼å“ä½†æœ‰å€ºåŠ¡ï¼Œå¥åº·å› å­ä¸º 0
        if (collateral_value == 0) {
            return 0
        };
        
        // HF = æŠµæŠ¼èƒ½åŠ› / å€ºåŠ¡ï¼ˆä½¿ç”¨1e18ç²¾åº¦ï¼‰
        (collateral_value * PRECISION) / debt_value
    }
    
    /// è®¡ç®—æ€»æŠµæŠ¼èƒ½åŠ›
    fun calculate_total_collateral_value(
        collaterals: &vector<CollateralInfo>
    ): u128 {
        let total: u128 = 0;
        let len = vector::length(collaterals);
        let i = 0;
        
        while (i < len) {
            let col = vector::borrow(collaterals, i);
            
            // è®¡ç®—è¯¥æŠµæŠ¼å“çš„ä»·å€¼
            // value = amount * price * collateral_factor / FACTOR_PRECISION
            let value = (col.amount * col.price * col.collateral_factor) / FACTOR_PRECISION;
            total = total + value;
            
            i = i + 1;
        };
        
        total
    }
    
    /// è®¡ç®—æ€»å€ºåŠ¡ä»·å€¼
    fun calculate_total_debt_value(
        borrows: &vector<BorrowInfo>
    ): u128 {
        let total: u128 = 0;
        let len = vector::length(borrows);
        let i = 0;
        
        while (i < len) {
            let borrow = vector::borrow(borrows, i);
            
            // è®¡ç®—è¯¥å€ºåŠ¡çš„ä»·å€¼
            // value = amount * price
            let value = borrow.amount * borrow.price;
            total = total + value;
            
            i = i + 1;
        };
        
        total
    }
    
    // ==================== æµ‹è¯• ====================
    
    #[test]
    fun test_single_asset() {
        // æŠµæŠ¼ï¼š1 ETH ($2000, 75%)
        // å€Ÿæ¬¾ï¼š$1200
        // é¢„æœŸ HFï¼š1.25
        
        let collaterals = vector[
            CollateralInfo {
                amount: 100_000_000,      // 1 ETH (8ä½å°æ•°)
                price: 200_000_000_000,   // $2000 (ç²¾åº¦1e8)
                collateral_factor: 750_000, // 75% (ç²¾åº¦1e6)
            },
        ];
        
        let borrows = vector[
            BorrowInfo {
                amount: 1200_000_000,     // 1200 USDC (6ä½å°æ•°)
                price: 100_000_000,       // $1 (ç²¾åº¦1e8)
            },
        ];
        
        let hf = calculate_health_factor(collaterals, borrows);
        
        // 1 ETH Ã— $2000 Ã— 75% = $1500
        // HF = $1500 / $1200 = 1.25
        // ç²¾åº¦1e18: 1.25 Ã— 1e18 = 1_250_000_000_000_000_000
        
        assert!(hf == 1_250_000_000_000_000_000, 1);
    }
    
    #[test]
    fun test_multi_asset() {
        // æŠµæŠ¼ï¼š
        //   - 1 ETH ($2000, 75%) = $1500
        //   - 1000 USDC ($1, 80%) = $800
        //   æ€»è®¡ = $2300
        // å€Ÿæ¬¾ï¼š$1500
        // é¢„æœŸ HFï¼š1.533...
        
        let collaterals = vector[
            CollateralInfo {
                amount: 100_000_000,
                price: 200_000_000_000,
                collateral_factor: 750_000,
            },
            CollateralInfo {
                amount: 1000_000_000,
                price: 100_000_000,
                collateral_factor: 800_000,
            },
        ];
        
        let borrows = vector[
            BorrowInfo {
                amount: 1500_000_000,
                price: 100_000_000,
            },
        ];
        
        let hf = calculate_health_factor(collaterals, borrows);
        
        // æ€»æŠµæŠ¼èƒ½åŠ› = $1500 + $800 = $2300
        // HF = $2300 / $1500 = 1.5333...
        // å…è®¸å°è¯¯å·®
        assert!(hf >= 1_533_000_000_000_000_000, 1);
        assert!(hf <= 1_534_000_000_000_000_000, 2);
    }
    
    #[test]
    fun test_no_debt() {
        // æœ‰æŠµæŠ¼ï¼Œæ— å€ºåŠ¡
        // é¢„æœŸ HFï¼šMAX_U128
        
        let collaterals = vector[
            CollateralInfo {
                amount: 100_000_000,
                price: 200_000_000_000,
                collateral_factor: 750_000,
            },
        ];
        
        let borrows = vector::empty<BorrowInfo>();
        
        let hf = calculate_health_factor(collaterals, borrows);
        assert!(hf == MAX_U128, 1);
    }
    
    #[test]
    fun test_no_collateral() {
        // æ— æŠµæŠ¼ï¼Œæœ‰å€ºåŠ¡
        // é¢„æœŸ HFï¼š0
        
        let collaterals = vector::empty<CollateralInfo>();
        
        let borrows = vector[
            BorrowInfo {
                amount: 1000_000_000,
                price: 100_000_000,
            },
        ];
        
        let hf = calculate_health_factor(collaterals, borrows);
        assert!(hf == 0, 1);
    }
}
```

**å…³é”®ç‚¹**ï¼š
1. ä½¿ç”¨ 1e18 ç²¾åº¦è¡¨ç¤ºå¥åº·å› å­
2. æ­£ç¡®å¤„ç†è¾¹ç•Œæƒ…å†µï¼ˆæ— å€ºåŠ¡ã€æ— æŠµæŠ¼ï¼‰
3. é¿å…æº¢å‡ºï¼ˆå…ˆä¹˜åé™¤ï¼‰
4. å®Œæ•´çš„å•å…ƒæµ‹è¯•

---

### ç¬¬ 4 é¢˜ï¼šå¥åº·å› å­é¢„è­¦ç³»ç»Ÿ

```move
module collateral_exam::health_monitor {
    use std::vector;
    use aptos_framework::event;
    use aptos_framework::timestamp;
    
    // å¸¸é‡
    const PRECISION: u128 = 1_000_000_000_000_000_000; // 1e18
    
    // å¥åº·å› å­é˜ˆå€¼
    const HF_SAFE: u128 = 1_500_000_000_000_000_000;      // 1.5
    const HF_NOTICE: u128 = 1_200_000_000_000_000_000;    // 1.2
    const HF_WARNING: u128 = 1_050_000_000_000_000_000;   // 1.05
    const HF_LIQUIDATION: u128 = 1_000_000_000_000_000_000; // 1.0
    
    // å¥åº·å› å­ç­‰çº§
    const LEVEL_SAFE: u8 = 0;
    const LEVEL_NOTICE: u8 = 1;
    const LEVEL_WARNING: u8 = 2;
    const LEVEL_CRITICAL: u8 = 3;
    const LEVEL_LIQUIDATION: u8 = 4;
    
    // æ“ä½œç±»å‹
    const OP_DEPOSIT: u8 = 0;
    const OP_WITHDRAW: u8 = 1;
    const OP_BORROW: u8 = 2;
    const OP_REPAY: u8 = 3;
    
    // äº‹ä»¶
    #[event]
    struct HealthFactorAlert has store, drop {
        user: address,
        health_factor: u128,
        level: u8,
        message: vector<u8>,
        timestamp: u64,
    }
    
    /// è·å–å¥åº·å› å­ç­‰çº§
    public fun get_health_factor_level(health_factor: u128): u8 {
        if (health_factor >= HF_SAFE) {
            LEVEL_SAFE
        } else if (health_factor >= HF_NOTICE) {
            LEVEL_NOTICE
        } else if (health_factor >= HF_WARNING) {
            LEVEL_WARNING
        } else if (health_factor >= HF_LIQUIDATION) {
            LEVEL_CRITICAL
        } else {
            LEVEL_LIQUIDATION
        }
    }
    
    /// æ£€æŸ¥å¹¶å‘å‡ºé¢„è­¦
    public fun check_and_alert(
        user: address,
        health_factor: u128,
    ) {
        let level = get_health_factor_level(health_factor);
        
        // åªæœ‰åœ¨éœ€è¦é¢„è­¦æ—¶æ‰å‘å‡ºäº‹ä»¶
        if (level >= LEVEL_NOTICE) {
            let message = get_alert_message(level);
            let now = timestamp::now_seconds();
            
            event::emit(HealthFactorAlert {
                user,
                health_factor,
                level,
                message,
                timestamp: now,
            });
        };
    }
    
    /// è·å–é¢„è­¦æ¶ˆæ¯
    fun get_alert_message(level: u8): vector<u8> {
        if (level == LEVEL_NOTICE) {
            b"Notice: Your health factor is below 1.5. Consider adding collateral."
        } else if (level == LEVEL_WARNING) {
            b"Warning: Your health factor is below 1.2. You should add collateral or repay debt."
        } else if (level == LEVEL_CRITICAL) {
            b"CRITICAL: Your health factor is below 1.05. Immediate action required!"
        } else if (level == LEVEL_LIQUIDATION) {
            b"LIQUIDATION: Your health factor is below 1.0. You may be liquidated!"
        } else {
            b"Safe"
        }
    }
    
    /// åˆ¤æ–­æ“ä½œæ˜¯å¦å…è®¸
    public fun is_operation_allowed(
        health_factor: u128,
        operation: u8,
    ): bool {
        let level = get_health_factor_level(health_factor);
        
        // SAFE: å…è®¸æ‰€æœ‰æ“ä½œ
        if (level == LEVEL_SAFE) {
            return true
        };
        
        // NOTICE: å…è®¸æ‰€æœ‰æ“ä½œï¼ˆä½†æœ‰è­¦å‘Šï¼‰
        if (level == LEVEL_NOTICE) {
            return true
        };
        
        // WARNING: ç¦æ­¢æ–°å¢å€Ÿæ¬¾
        if (level == LEVEL_WARNING) {
            return operation != OP_BORROW
        };
        
        // CRITICAL: åªå…è®¸å­˜æ¬¾å’Œè¿˜æ¬¾
        if (level == LEVEL_CRITICAL) {
            return operation == OP_DEPOSIT || operation == OP_REPAY
        };
        
        // LIQUIDATION: åªå…è®¸å­˜æ¬¾å’Œè¿˜æ¬¾
        if (level == LEVEL_LIQUIDATION) {
            return operation == OP_DEPOSIT || operation == OP_REPAY
        };
        
        false
    }
    
    // ==================== æµ‹è¯• ====================
    
    #[test]
    fun test_health_factor_levels() {
        // HF = 2.0 => SAFE
        let hf = 2_000_000_000_000_000_000;
        assert!(get_health_factor_level(hf) == LEVEL_SAFE, 1);
        
        // HF = 1.3 => NOTICE
        let hf = 1_300_000_000_000_000_000;
        assert!(get_health_factor_level(hf) == LEVEL_NOTICE, 2);
        
        // HF = 1.1 => WARNING
        let hf = 1_100_000_000_000_000_000;
        assert!(get_health_factor_level(hf) == LEVEL_WARNING, 3);
        
        // HF = 1.02 => CRITICAL
        let hf = 1_020_000_000_000_000_000;
        assert!(get_health_factor_level(hf) == LEVEL_CRITICAL, 4);
        
        // HF = 0.95 => LIQUIDATION
        let hf = 950_000_000_000_000_000;
        assert!(get_health_factor_level(hf) == LEVEL_LIQUIDATION, 5);
    }
    
    #[test]
    fun test_operation_restrictions() {
        // CRITICAL çº§åˆ« (HF = 1.02)
        let hf = 1_020_000_000_000_000_000;
        
        // å…è®¸å­˜æ¬¾
        assert!(is_operation_allowed(hf, OP_DEPOSIT), 1);
        
        // ç¦æ­¢æå–
        assert!(!is_operation_allowed(hf, OP_WITHDRAW), 2);
        
        // ç¦æ­¢å€Ÿæ¬¾
        assert!(!is_operation_allowed(hf, OP_BORROW), 3);
        
        // å…è®¸è¿˜æ¬¾
        assert!(is_operation_allowed(hf, OP_REPAY), 4);
    }
    
    #[test]
    fun test_warning_level_borrow_restriction() {
        // WARNING çº§åˆ« (HF = 1.1)
        let hf = 1_100_000_000_000_000_000;
        
        // å…è®¸å­˜æ¬¾
        assert!(is_operation_allowed(hf, OP_DEPOSIT), 1);
        
        // å…è®¸æå–ï¼ˆä½†æœ‰é™åˆ¶ï¼‰
        assert!(is_operation_allowed(hf, OP_WITHDRAW), 2);
        
        // ç¦æ­¢å€Ÿæ¬¾
        assert!(!is_operation_allowed(hf, OP_BORROW), 3);
        
        // å…è®¸è¿˜æ¬¾
        assert!(is_operation_allowed(hf, OP_REPAY), 4);
    }
}
```

**å®ç°è¦ç‚¹**ï¼š
1. æ¸…æ™°çš„ç­‰çº§åˆ’åˆ†
2. å‡†ç¡®çš„é˜ˆå€¼åˆ¤æ–­
3. åˆç†çš„æ“ä½œé™åˆ¶
4. æœ‰ç”¨çš„è­¦å‘Šæ¶ˆæ¯

---

## ğŸ“Š è¯„åˆ†æ€»ç»“

### é€‰æ‹©é¢˜è¯„åˆ†

20 é¢˜ Ã— 5 åˆ† = 100 åˆ†

### ç¼–ç¨‹é¢˜è¯„åˆ†

| é¢˜ç›® | åŠŸèƒ½å®ç° | è¾¹ç•Œå¤„ç† | æµ‹è¯•è¦†ç›– | ä»£ç è´¨é‡ | æ€»åˆ† |
|------|----------|----------|----------|----------|------|
| ç¬¬1é¢˜ | 10 | 5 | 3 | 2 | 20 |
| ç¬¬2é¢˜ | 15 | 5 | 3 | 2 | 25 |
| ç¬¬3é¢˜ | 15 | 3 | 2 | 0 | 20 |
| ç¬¬4é¢˜ | 12 | 4 | 2 | 2 | 20 |
| ç¬¬5é¢˜ | 10 | 3 | 2 | 0 | 15 |
| **åˆè®¡** | | | | | **100** |

---

## ğŸ¯ å¸¸è§é”™è¯¯åˆ†æ

### é”™è¯¯ 1ï¼šç²¾åº¦å¤„ç†ä¸å½“

```move
// âŒ é”™è¯¯ï¼šç²¾åº¦æŸå¤±
let hf = collateral_value / debt_value;

// âœ… æ­£ç¡®ï¼šä½¿ç”¨é«˜ç²¾åº¦
let hf = (collateral_value * PRECISION) / debt_value;
```

### é”™è¯¯ 2ï¼šæœªå¤„ç†è¾¹ç•Œæƒ…å†µ

```move
// âŒ é”™è¯¯ï¼šé™¤é›¶
let hf = collateral / debt;

// âœ… æ­£ç¡®ï¼šæ£€æŸ¥è¾¹ç•Œ
let hf = if (debt == 0) {
    MAX_U128
} else {
    (collateral * PRECISION) / debt
};
```

### é”™è¯¯ 3ï¼šè®¡ç®—é¡ºåºé”™è¯¯

```move
// âŒ é”™è¯¯ï¼šå…ˆé™¤åä¹˜
let value = (amount / PRECISION) * price;

// âœ… æ­£ç¡®ï¼šå…ˆä¹˜åé™¤
let value = (amount * price) / PRECISION;
```

### é”™è¯¯ 4ï¼šæœªæ£€æŸ¥æº¢å‡º

```move
// âŒ é”™è¯¯ï¼šå¯èƒ½æº¢å‡º
let result = a * b;

// âœ… æ­£ç¡®ï¼šæ£€æŸ¥æº¢å‡º
let result = a * b;
assert!(result / a == b, E_OVERFLOW);
```

---

## ğŸ’¡ å­¦ä¹ å»ºè®®

### 1. æ·±å…¥ç†è§£æ¦‚å¿µ

ä¸è¦åªè®°å…¬å¼ï¼Œè¦ç†è§£ï¼š
- ä¸ºä»€ä¹ˆå¥åº·å› å­ < 1.0 è¦æ¸…ç®—ï¼Ÿ
- ä¸ºä»€ä¹ˆéœ€è¦æŠµæŠ¼ç‡ï¼Ÿ
- ä¸ºä»€ä¹ˆè¦æœ‰æ¸…ç®—æƒ©ç½šï¼Ÿ

### 2. å®è·µä¸ºä¸»

- å¤šå†™ä»£ç ï¼Œå¤šæµ‹è¯•
- å°è¯•ä¸åŒçš„å‚æ•°ç»„åˆ
- æ¨¡æ‹Ÿå„ç§å¸‚åœºæƒ…å†µ

### 3. å…³æ³¨ç»†èŠ‚

- ç²¾åº¦å¤„ç†
- è¾¹ç•Œæ¡ä»¶
- é”™è¯¯å¤„ç†
- äº‹ä»¶å‘å‡º

### 4. å­¦ä¹ ä¼˜ç§€é¡¹ç›®

æ¨èå­¦ä¹ ï¼š
- Aave V3 æºç 
- Compound Finance æ–‡æ¡£
- MakerDAO æ¸…ç®—æœºåˆ¶

---

## ğŸ“š è¿›é˜¶é˜…è¯»

1. **DeFi é£é™©ç®¡ç†**
   - äº†è§£ VaRã€å‹åŠ›æµ‹è¯•
   - å­¦ä¹ é£é™©å‚æ•°è®¾ç½®æ–¹æ³•

2. **æ•°å­¦åŸºç¡€**
   - ç†è§£ç²¾åº¦å’Œæµ®ç‚¹æ•°
   - æŒæ¡æº¢å‡ºæ£€æµ‹æŠ€å·§

3. **å®é™…æ¡ˆä¾‹**
   - ç ”ç©¶å†å²æ¸…ç®—äº‹ä»¶
   - åˆ†æé»‘å¤©é¹…äº‹ä»¶

4. **å‰æ²¿æŠ€æœ¯**
   - åŠ¨æ€é£é™©å‚æ•°
   - AI è¾…åŠ©é£é™©ç®¡ç†
   - è·¨é“¾æŠµæŠ¼å“

---

**æ­å–œå®Œæˆ Day 21 çš„å­¦ä¹ å’Œè€ƒè¯•ï¼ç»§ç»­åŠ æ²¹ï¼** ğŸ‰

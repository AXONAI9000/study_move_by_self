# Day 12 每日考试 - 编程题

**考试时间**：30 分钟  
**总分**：50 分  
**及格分**：35 分

---

## 编程题 1：提案状态管理（15 分）

### 题目描述
实现一个函数，根据当前时间和投票统计自动更新提案状态。

### 要求
```move
/// 更新提案状态
/// - 如果投票未开始，状态为 PENDING
/// - 如果投票进行中，状态为 ACTIVE
/// - 如果投票已结束，根据结果更新为 SUCCEEDED 或 DEFEATED
public fun update_proposal_status(
    proposal: &mut Proposal,
    total_voting_power: u64,
    quorum_percentage: u64,
    approval_threshold: u64
)
```

### 提示
- 使用 `timestamp::now_seconds()` 获取当前时间
- 法定人数 = `total_voting_power * quorum_percentage / 100`
- 通过条件 = `yes_votes >= (total_votes * approval_threshold) / 100`

### 评分标准
- 正确判断时间状态（5 分）
- 正确计算法定人数（5 分）
- 正确判断通过条件（5 分）

---

## 编程题 2：防止重复投票（15 分）

### 题目描述
实现一个完整的投票函数，包括所有必要的验证。

### 要求
```move
/// 投票函数
/// 需要验证：
/// 1. 提案存在
/// 2. 投票时间有效
/// 3. 用户未投过票
/// 4. 投票类型有效
public fun vote(
    voter: &signer,
    proposal_id: u64,
    vote_type: u8,
) acquires VotingSystem {
    // 你的实现
}
```

### 必须包含的检查
1. 提案是否存在
2. 当前时间是否在投票期内
3. 用户是否已经投过票
4. 投票类型是否有效（0, 1, 2）
5. 正确更新提案统计
6. 记录投票

### 评分标准
- 所有验证完整（10 分）
- 正确更新状态（3 分）
- 正确记录投票（2 分）

---

## 编程题 3：投票历史查询（20 分）

### 题目描述
实现一个系统，记录并查询用户的投票历史。

### 要求实现以下功能

#### 3.1 数据结构设计（5 分）
```move
/// 定义存储用户投票历史的数据结构
struct VotingHistory has key {
    // 你的设计
}
```

#### 3.2 记录投票历史（5 分）
```move
/// 在用户投票时，记录到历史中
fun record_vote_history(
    voter: address,
    vote: Vote
) acquires VotingHistory {
    // 你的实现
}
```

#### 3.3 查询用户投票历史（5 分）
```move
/// 查询用户投票过的所有提案
#[view]
public fun get_user_vote_history(
    user: address
): vector<u64> acquires VotingHistory {
    // 返回提案 ID 列表
    // 你的实现
}
```

#### 3.4 查询用户在特定提案的投票（5 分）
```move
/// 查询用户在特定提案的投票详情
#[view]
public fun get_user_vote_on_proposal(
    user: address,
    proposal_id: u64
): Option<Vote> acquires VotingHistory, VotingSystem {
    // 你的实现
}
```

### 评分标准
- 数据结构合理（5 分）
- 记录功能正确（5 分）
- 查询历史功能正确（5 分）
- 查询特定投票功能正确（5 分）

---

## 提交要求

### 文件结构
```
solutions/
├── problem1_status_update.move
├── problem2_vote_function.move
└── problem3_vote_history.move
```

### 每个文件应包含
- 完整的实现代码
- 必要的注释
- 错误处理

### 测试要求
每个函数都应该能够编译通过。可以添加简单的测试：

```move
#[test]
fun test_your_function() {
    // 你的测试代码
}
```

---

## 评分细则

| 项目 | 分数 | 说明 |
|------|------|------|
| **编程题 1** | 15 分 | 状态管理逻辑 |
| **编程题 2** | 15 分 | 完整的投票函数 |
| **编程题 3** | 20 分 | 投票历史系统 |
| **总分** | 50 分 | - |

**及格分数**：35 分  
**建议时间**：
- 编程题 1：10 分钟
- 编程题 2：10 分钟
- 编程题 3：10 分钟

---

## 提示

### 编程题 1 提示
```move
let now = timestamp::now_seconds();

// 判断时间状态
if (now < proposal.voting_start) {
    proposal.status = STATUS_PENDING;
} else if (now < proposal.voting_end) {
    proposal.status = STATUS_ACTIVE;
} else {
    // 计算是否通过
    let total_votes = proposal.yes_votes + proposal.no_votes + proposal.abstain_votes;
    let quorum_required = (total_voting_power * quorum_percentage) / 100;
    
    if (total_votes >= quorum_required) {
        // 继续判断通过条件
    } else {
        proposal.status = STATUS_DEFEATED;
    }
}
```

### 编程题 2 提示
```move
// 1. 获取投票者地址
let voter_addr = signer::address_of(voter);

// 2. 检查提案存在
let system = borrow_global_mut<VotingSystem>(@module_addr);
assert!(smart_table::contains(&system.proposals, proposal_id), ERROR_PROPOSAL_NOT_FOUND);

// 3. 检查投票时间
let now = timestamp::now_seconds();
let proposal = smart_table::borrow_mut(&mut system.proposals, proposal_id);
assert!(now >= proposal.voting_start, ERROR_VOTING_NOT_STARTED);
assert!(now < proposal.voting_end, ERROR_VOTING_ENDED);

// 4. 检查重复投票
let proposal_votes = table::borrow(&system.votes, proposal_id);
assert!(!table::contains(proposal_votes, voter_addr), ERROR_ALREADY_VOTED);

// 5. 继续实现...
```

### 编程题 3 提示
```move
struct VotingHistory has key {
    // 方案 1: 使用 Table 存储用户 -> 投票列表
    user_votes: Table<address, vector<Vote>>,
    
    // 方案 2: 使用嵌套 Table
    user_votes: Table<address, Table<u64, Vote>>,
}

// 初始化
public fun init_history(account: &signer) {
    move_to(account, VotingHistory {
        user_votes: table::new()
    });
}
```

---

**完成后请对照答案解析.md 查看参考答案！**

祝你考试顺利！💪

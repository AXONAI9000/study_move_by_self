````markdown
# Day 02 å®è·µä»»åŠ¡ - åŸºæœ¬æ•°æ®ç±»å‹ä¸å˜é‡

## ä»»åŠ¡æ¦‚è¿°

é€šè¿‡ä¸‰ä¸ªé€’è¿›å¼ç¼–ç¨‹ä»»åŠ¡ï¼Œæ·±å…¥æŒæ¡Moveè¯­è¨€çš„åŸºæœ¬æ•°æ®ç±»å‹ã€å˜é‡æ“ä½œå’Œç±»å‹å®‰å…¨ç‰¹æ€§ã€‚

---

## ä»»åŠ¡ 1ï¼šæ•°å€¼è®¡ç®—å™¨å¢å¼ºç‰ˆï¼ˆ25 åˆ†ï¼‰

### ğŸ“‹ ä»»åŠ¡æè¿°

æ‰©å±•Day 01çš„è®¡ç®—å™¨ï¼Œæ·»åŠ æ›´å¤šæ•°å­¦å‡½æ•°å’Œç±»å‹å®‰å…¨æ£€æŸ¥ã€‚

### ğŸ¯ åŠŸèƒ½è¦æ±‚

åˆ›å»º `sources/advanced_calculator.move` æ–‡ä»¶ï¼Œå®ç°ï¼š

1. **åŸºç¡€è¿ç®—**ï¼ˆå¸¦æº¢å‡ºæ£€æŸ¥ï¼‰
   - `safe_add(a: u64, b: u64): u64` - å®‰å…¨åŠ æ³•
   - `safe_subtract(a: u64, b: u64): u64` - å®‰å…¨å‡æ³•
   - `safe_multiply(a: u64, b: u64): u64` - å®‰å…¨ä¹˜æ³•

2. **é«˜çº§è¿ç®—**
   - `power(base: u64, exponent: u8): u64` - å¹‚è¿ç®—
   - `min(a: u64, b: u64): u64` - æœ€å°å€¼
   - `max(a: u64, b: u64): u64` - æœ€å¤§å€¼
   - `average(a: u64, b: u64): u64` - å¹³å‡å€¼

3. **ç±»å‹è½¬æ¢**
   - `convert_to_u8(value: u64): u8` - å®‰å…¨è½¬æ¢åˆ°u8
   - `convert_to_u128(value: u64): u128` - è½¬æ¢åˆ°u128

### ğŸ“ ä»£ç æ¡†æ¶

```move
module my_addr::advanced_calculator {
    
    // å¸¸é‡å®šä¹‰
    const MAX_U64: u128 = 18446744073709551615;
    const MAX_U8: u64 = 255;
    
    // é”™è¯¯ç 
    const E_OVERFLOW: u64 = 1;
    const E_UNDERFLOW: u64 = 2;
    const E_VALUE_TOO_LARGE: u64 = 3;
    const E_DIVISION_BY_ZERO: u64 = 4;

    /// å®‰å…¨åŠ æ³•ï¼šæ£€æŸ¥æº¢å‡º
    public fun safe_add(a: u64, b: u64): u64 {
        let a_u128 = (a as u128);
        let b_u128 = (b as u128);
        let sum = a_u128 + b_u128;
        assert!(sum <= MAX_U64, E_OVERFLOW);
        (sum as u64)
    }

    /// å®‰å…¨å‡æ³•ï¼šæ£€æŸ¥ä¸‹æº¢
    public fun safe_subtract(a: u64, b: u64): u64 {
        // TODO: å®ç°
        0
    }

    /// å®‰å…¨ä¹˜æ³•ï¼šæ£€æŸ¥æº¢å‡º
    public fun safe_multiply(a: u64, b: u64): u64 {
        // TODO: å®ç°
        0
    }

    /// å¹‚è¿ç®—ï¼šbase^exponent
    public fun power(base: u64, exponent: u8): u64 {
        // TODO: å®ç°
        // æç¤ºï¼šä½¿ç”¨å¾ªç¯
        0
    }

    /// æœ€å°å€¼
    public fun min(a: u64, b: u64): u64 {
        // TODO: å®ç°
        0
    }

    /// æœ€å¤§å€¼
    public fun max(a: u64, b: u64): u64 {
        // TODO: å®ç°
        0
    }

    /// å¹³å‡å€¼ï¼ˆå‘ä¸‹å–æ•´ï¼‰
    public fun average(a: u64, b: u64): u64 {
        // TODO: å®ç°
        0
    }

    /// å®‰å…¨è½¬æ¢åˆ°u8
    public fun convert_to_u8(value: u64): u8 {
        // TODO: å®ç°
        0
    }

    /// è½¬æ¢åˆ°u128
    public fun convert_to_u128(value: u64): u128 {
        // TODO: å®ç°
        0
    }

    // ============================================
    // æµ‹è¯•
    // ============================================

    #[test]
    fun test_safe_add() {
        assert!(safe_add(100, 200) == 300, 0);
        assert!(safe_add(0, 0) == 0, 1);
    }

    #[test]
    #[expected_failure(abort_code = E_OVERFLOW)]
    fun test_safe_add_overflow() {
        safe_add(18446744073709551615, 1);
    }

    #[test]
    fun test_safe_subtract() {
        assert!(safe_subtract(100, 30) == 70, 0);
    }

    #[test]
    #[expected_failure(abort_code = E_UNDERFLOW)]
    fun test_safe_subtract_underflow() {
        safe_subtract(10, 20);
    }

    #[test]
    fun test_power() {
        assert!(power(2, 3) == 8, 0);
        assert!(power(5, 2) == 25, 1);
        assert!(power(10, 0) == 1, 2);
    }

    #[test]
    fun test_min_max() {
        assert!(min(10, 20) == 10, 0);
        assert!(max(10, 20) == 20, 1);
    }

    #[test]
    fun test_average() {
        assert!(average(10, 20) == 15, 0);
        assert!(average(5, 6) == 5, 1);  // å‘ä¸‹å–æ•´
    }

    #[test]
    fun test_convert_to_u8() {
        assert!(convert_to_u8(100) == 100, 0);
    }

    #[test]
    #[expected_failure(abort_code = E_VALUE_TOO_LARGE)]
    fun test_convert_to_u8_fail() {
        convert_to_u8(300);
    }
}
```

### ğŸ’¡ æç¤º

- ä½¿ç”¨u128è¿›è¡Œä¸­é—´è®¡ç®—é¿å…æº¢å‡º
- å¹‚è¿ç®—å¯ä»¥ç”¨å¾ªç¯å®ç°ï¼šresult = base * base * ... (exponentæ¬¡)
- æ³¨æ„0çš„ç‰¹æ®Šæƒ…å†µï¼ˆå¦‚0çš„0æ¬¡æ–¹å®šä¹‰ä¸º1ï¼‰

### âœ… éªŒè¯æ–¹æ³•

```bash
aptos move test --filter advanced_calculator
```

---

## ä»»åŠ¡ 2ï¼šç±»å‹å®‰å…¨çš„è´§å¸ç³»ç»Ÿï¼ˆ35 åˆ†ï¼‰

### ğŸ“‹ ä»»åŠ¡æè¿°

å®ç°ä¸€ä¸ªæ”¯æŒå¤šç§é¢é¢çš„è´§å¸ç³»ç»Ÿï¼Œå±•ç¤ºç±»å‹å®‰å…¨å’Œç²¾ç¡®è®¡ç®—ã€‚

### ğŸ¯ åŠŸèƒ½è¦æ±‚

åˆ›å»º `sources/currency.move` æ–‡ä»¶ï¼Œå®ç°ï¼š

1. **è´§å¸ç»“æ„ä½“**
```move
struct Currency has key, drop, copy {
    major_units: u64,    // ä¸»å•ä½ï¼ˆå…ƒï¼‰
    minor_units: u8,     // è¾…å•ä½ï¼ˆåˆ†ï¼Œ0-99ï¼‰
}
```

2. **åŸºæœ¬æ“ä½œ**
   - `create_currency(major: u64, minor: u8): Currency`
   - `add_currency(a: Currency, b: Currency): Currency`
   - `subtract_currency(a: Currency, b: Currency): Currency`
   - `multiply_by_scalar(c: Currency, multiplier: u64): Currency`
   - `divide_by_scalar(c: Currency, divisor: u64): Currency`

3. **æ¯”è¾ƒæ“ä½œ**
   - `is_greater(a: Currency, b: Currency): bool`
   - `is_equal(a: Currency, b: Currency): bool`

4. **è½¬æ¢æ“ä½œ**
   - `to_minor_units(c: Currency): u64` - è½¬æ¢ä¸ºæœ€å°å•ä½
   - `from_minor_units(total_minor: u64): Currency` - ä»æœ€å°å•ä½åˆ›å»º

### ğŸ“ ä»£ç æ¡†æ¶

```move
module my_addr::currency {
    use std::debug;

    struct Currency has copy, drop, store {
        major_units: u64,
        minor_units: u8
    }

    const MINOR_UNITS_PER_MAJOR: u64 = 100;
    const MAX_MINOR_UNITS: u8 = 99;

    const E_INVALID_MINOR_UNITS: u64 = 1;
    const E_INSUFFICIENT_FUNDS: u64 = 2;
    const E_DIVISION_BY_ZERO: u64 = 3;
    const E_OVERFLOW: u64 = 4;

    /// åˆ›å»ºè´§å¸
    public fun create_currency(major: u64, minor: u8): Currency {
        assert!(minor <= MAX_MINOR_UNITS, E_INVALID_MINOR_UNITS);
        Currency { major_units: major, minor_units: minor }
    }

    /// è½¬æ¢ä¸ºæœ€å°å•ä½ï¼ˆåˆ†ï¼‰
    public fun to_minor_units(c: Currency): u64 {
        c.major_units * MINOR_UNITS_PER_MAJOR + (c.minor_units as u64)
    }

    /// ä»æœ€å°å•ä½åˆ›å»ºè´§å¸
    public fun from_minor_units(total_minor: u64): Currency {
        let major = total_minor / MINOR_UNITS_PER_MAJOR;
        let minor = ((total_minor % MINOR_UNITS_PER_MAJOR) as u8);
        Currency { major_units: major, minor_units: minor }
    }

    /// åŠ æ³•
    public fun add_currency(a: Currency, b: Currency): Currency {
        // TODO: å®ç°
        // æç¤ºï¼šè½¬æ¢ä¸ºæœ€å°å•ä½ç›¸åŠ ï¼Œç„¶åè½¬å›
        create_currency(0, 0)
    }

    /// å‡æ³•
    public fun subtract_currency(a: Currency, b: Currency): Currency {
        // TODO: å®ç°
        // éœ€è¦æ£€æŸ¥æ˜¯å¦æœ‰è¶³å¤Ÿçš„é‡‘é¢
        create_currency(0, 0)
    }

    /// ä¹˜ä»¥æ ‡é‡
    public fun multiply_by_scalar(c: Currency, multiplier: u64): Currency {
        // TODO: å®ç°
        create_currency(0, 0)
    }

    /// é™¤ä»¥æ ‡é‡
    public fun divide_by_scalar(c: Currency, divisor: u64): Currency {
        // TODO: å®ç°
        create_currency(0, 0)
    }

    /// æ¯”è¾ƒï¼šå¤§äº
    public fun is_greater(a: Currency, b: Currency): bool {
        // TODO: å®ç°
        false
    }

    /// æ¯”è¾ƒï¼šç­‰äº
    public fun is_equal(a: Currency, b: Currency): bool {
        // TODO: å®ç°
        false
    }

    /// æ ¼å¼åŒ–è¾“å‡ºï¼ˆç”¨äºè°ƒè¯•ï¼‰
    public fun format_currency(c: Currency) {
        debug::print(&c.major_units);
        debug::print(&c.minor_units);
    }

    // ============================================
    // æµ‹è¯•
    // ============================================

    #[test]
    fun test_create() {
        let c = create_currency(10, 50);
        assert!(c.major_units == 10, 0);
        assert!(c.minor_units == 50, 1);
    }

    #[test]
    fun test_to_minor_units() {
        let c = create_currency(10, 50);
        assert!(to_minor_units(c) == 1050, 0);
    }

    #[test]
    fun test_from_minor_units() {
        let c = from_minor_units(1050);
        assert!(c.major_units == 10, 0);
        assert!(c.minor_units == 50, 1);
    }

    #[test]
    fun test_add() {
        let a = create_currency(10, 50);
        let b = create_currency(5, 30);
        let sum = add_currency(a, b);
        assert!(sum.major_units == 15, 0);
        assert!(sum.minor_units == 80, 1);
    }

    #[test]
    fun test_add_with_carry() {
        let a = create_currency(10, 60);
        let b = create_currency(5, 50);
        let sum = add_currency(a, b);
        assert!(sum.major_units == 16, 0);
        assert!(sum.minor_units == 10, 1);
    }

    #[test]
    fun test_subtract() {
        let a = create_currency(10, 50);
        let b = create_currency(5, 30);
        let diff = subtract_currency(a, b);
        assert!(diff.major_units == 5, 0);
        assert!(diff.minor_units == 20, 1);
    }

    #[test]
    #[expected_failure(abort_code = E_INSUFFICIENT_FUNDS)]
    fun test_subtract_insufficient() {
        let a = create_currency(5, 0);
        let b = create_currency(10, 0);
        subtract_currency(a, b);
    }

    #[test]
    fun test_multiply() {
        let c = create_currency(10, 50);
        let result = multiply_by_scalar(c, 3);
        assert!(result.major_units == 31, 0);
        assert!(result.minor_units == 50, 1);
    }

    #[test]
    fun test_divide() {
        let c = create_currency(10, 0);
        let result = divide_by_scalar(c, 3);
        assert!(result.major_units == 3, 0);
        assert!(result.minor_units == 33, 1);  // 10.00 / 3 = 3.33
    }

    #[test]
    fun test_comparison() {
        let a = create_currency(10, 50);
        let b = create_currency(5, 30);
        let c = create_currency(10, 50);
        
        assert!(is_greater(a, b) == true, 0);
        assert!(is_equal(a, c) == true, 1);
    }
}
```

### ğŸ’¡ æç¤º

- æ‰€æœ‰è¿ç®—éƒ½è½¬æ¢ä¸ºæœ€å°å•ä½è¿›è¡Œï¼Œé¿å…ç²¾åº¦æŸå¤±
- åŠ æ³•å¯èƒ½äº§ç”Ÿè¿›ä½ï¼š60åˆ† + 50åˆ† = 1å…ƒ10åˆ†
- å‡æ³•è¦æ£€æŸ¥é‡‘é¢æ˜¯å¦å……è¶³
- é™¤æ³•ä¼šæœ‰ä½™æ•°ï¼Œå‘ä¸‹å–æ•´

---

## ä»»åŠ¡ 3ï¼šå˜é‡ä¸å¼•ç”¨ç»¼åˆç»ƒä¹ ï¼ˆ40 åˆ†ï¼‰

### ğŸ“‹ ä»»åŠ¡æè¿°

å®ç°ä¸€ä¸ªæ•°æ®å®¹å™¨ç³»ç»Ÿï¼Œæ·±å…¥ç†è§£Moveçš„æ‰€æœ‰æƒã€å¼•ç”¨å’Œå¯å˜æ€§ã€‚

### ğŸ¯ åŠŸèƒ½è¦æ±‚

åˆ›å»º `sources/data_container.move` æ–‡ä»¶ï¼Œå®ç°ï¼š

1. **å®¹å™¨ç»“æ„ä½“**
```move
struct DataContainer has key {
    values: vector<u64>,
    max_size: u64,
    is_locked: bool,
    owner: address
}
```

2. **åŸºæœ¬æ“ä½œ**
   - `create_container(account: &signer, max_size: u64)`
   - `push_value(account: &signer, value: u64)`
   - `pop_value(account: &signer): u64`
   - `get_value_at(addr: address, index: u64): u64`
   - `update_value_at(account: &signer, index: u64, new_value: u64)`

3. **å¼•ç”¨æ“ä½œ**
   - `borrow_value_ref(addr: address, index: u64): &u64`
   - `borrow_value_mut_ref(account: &signer, index: u64): &mut u64`

4. **æ‰¹é‡æ“ä½œ**
   - `push_multiple(account: &signer, values: vector<u64>)`
   - `sum_all_values(addr: address): u64`
   - `find_max(addr: address): u64`
   - `find_min(addr: address): u64`

5. **é”å®šæœºåˆ¶**
   - `lock_container(account: &signer)`
   - `unlock_container(account: &signer)`

### ğŸ“ ä»£ç æ¡†æ¶

```move
module my_addr::data_container {
    use std::signer;
    use std::vector;

    struct DataContainer has key {
        values: vector<u64>,
        max_size: u64,
        is_locked: bool,
        owner: address
    }

    const E_CONTAINER_EXISTS: u64 = 1;
    const E_CONTAINER_NOT_FOUND: u64 = 2;
    const E_CONTAINER_FULL: u64 = 3;
    const E_CONTAINER_EMPTY: u64 = 4;
    const E_INDEX_OUT_OF_BOUNDS: u64 = 5;
    const E_CONTAINER_LOCKED: u64 = 6;
    const E_NOT_OWNER: u64 = 7;
    const E_INVALID_SIZE: u64 = 8;

    /// åˆ›å»ºå®¹å™¨
    public fun create_container(account: &signer, max_size: u64) {
        let addr = signer::address_of(account);
        assert!(!exists<DataContainer>(addr), E_CONTAINER_EXISTS);
        assert!(max_size > 0, E_INVALID_SIZE);
        
        move_to(account, DataContainer {
            values: vector::empty<u64>(),
            max_size,
            is_locked: false,
            owner: addr
        });
    }

    /// æ£€æŸ¥æ˜¯å¦æ˜¯æ‹¥æœ‰è€…
    fun check_owner(account: &signer) acquires DataContainer {
        let addr = signer::address_of(account);
        let container = borrow_global<DataContainer>(addr);
        assert!(container.owner == addr, E_NOT_OWNER);
    }

    /// æ£€æŸ¥æ˜¯å¦é”å®š
    fun check_not_locked(account: &signer) acquires DataContainer {
        let addr = signer::address_of(account);
        let container = borrow_global<DataContainer>(addr);
        assert!(!container.is_locked, E_CONTAINER_LOCKED);
    }

    /// æ·»åŠ å•ä¸ªå€¼
    public fun push_value(account: &signer, value: u64) acquires DataContainer {
        let addr = signer::address_of(account);
        check_not_locked(account);
        
        let container = borrow_global_mut<DataContainer>(addr);
        assert!(vector::length(&container.values) < container.max_size, E_CONTAINER_FULL);
        
        vector::push_back(&mut container.values, value);
    }

    /// å¼¹å‡ºæœ€åä¸€ä¸ªå€¼
    public fun pop_value(account: &signer): u64 acquires DataContainer {
        // TODO: å®ç°
        0
    }

    /// è·å–æŒ‡å®šä½ç½®çš„å€¼
    public fun get_value_at(addr: address, index: u64): u64 acquires DataContainer {
        // TODO: å®ç°
        0
    }

    /// æ›´æ–°æŒ‡å®šä½ç½®çš„å€¼
    public fun update_value_at(account: &signer, index: u64, new_value: u64) acquires DataContainer {
        // TODO: å®ç°
    }

    /// å€Ÿç”¨ä¸å¯å˜å¼•ç”¨
    public fun borrow_value_ref(addr: address, index: u64): &u64 acquires DataContainer {
        let container = borrow_global<DataContainer>(addr);
        assert!(index < vector::length(&container.values), E_INDEX_OUT_OF_BOUNDS);
        vector::borrow(&container.values, index)
    }

    /// æ·»åŠ å¤šä¸ªå€¼
    public fun push_multiple(account: &signer, values: vector<u64>) acquires DataContainer {
        // TODO: å®ç°
        // æç¤ºï¼šéå†vectorï¼Œé€ä¸ªpush
    }

    /// è®¡ç®—æ‰€æœ‰å€¼çš„å’Œ
    public fun sum_all_values(addr: address): u64 acquires DataContainer {
        // TODO: å®ç°
        0
    }

    /// æ‰¾æœ€å¤§å€¼
    public fun find_max(addr: address): u64 acquires DataContainer {
        // TODO: å®ç°
        0
    }

    /// æ‰¾æœ€å°å€¼
    public fun find_min(addr: address): u64 acquires DataContainer {
        // TODO: å®ç°
        0
    }

    /// é”å®šå®¹å™¨
    public fun lock_container(account: &signer) acquires DataContainer {
        // TODO: å®ç°
    }

    /// è§£é”å®¹å™¨
    public fun unlock_container(account: &signer) acquires DataContainer {
        // TODO: å®ç°
    }

    /// è·å–å®¹å™¨å¤§å°
    public fun get_size(addr: address): u64 acquires DataContainer {
        let container = borrow_global<DataContainer>(addr);
        vector::length(&container.values)
    }

    /// æ£€æŸ¥æ˜¯å¦å·²é”å®š
    public fun is_locked(addr: address): bool acquires DataContainer {
        borrow_global<DataContainer>(addr).is_locked
    }

    // ============================================
    // æµ‹è¯•
    // ============================================

    #[test(account = @0x1)]
    fun test_create(account: &signer) {
        create_container(account, 10);
        let addr = signer::address_of(account);
        assert!(exists<DataContainer>(addr), 0);
    }

    #[test(account = @0x1)]
    fun test_push_pop(account: &signer) acquires DataContainer {
        create_container(account, 5);
        
        push_value(account, 10);
        push_value(account, 20);
        push_value(account, 30);
        
        let addr = signer::address_of(account);
        assert!(get_size(addr) == 3, 0);
        
        let val = pop_value(account);
        assert!(val == 30, 1);
        assert!(get_size(addr) == 2, 2);
    }

    #[test(account = @0x1)]
    fun test_get_update(account: &signer) acquires DataContainer {
        create_container(account, 5);
        push_value(account, 10);
        push_value(account, 20);
        
        let addr = signer::address_of(account);
        assert!(get_value_at(addr, 0) == 10, 0);
        
        update_value_at(account, 0, 100);
        assert!(get_value_at(addr, 0) == 100, 1);
    }

    #[test(account = @0x1)]
    fun test_push_multiple(account: &signer) acquires DataContainer {
        create_container(account, 10);
        
        let values = vector::empty<u64>();
        vector::push_back(&mut values, 1);
        vector::push_back(&mut values, 2);
        vector::push_back(&mut values, 3);
        
        push_multiple(account, values);
        
        let addr = signer::address_of(account);
        assert!(get_size(addr) == 3, 0);
    }

    #[test(account = @0x1)]
    fun test_sum(account: &signer) acquires DataContainer {
        create_container(account, 5);
        push_value(account, 10);
        push_value(account, 20);
        push_value(account, 30);
        
        let addr = signer::address_of(account);
        assert!(sum_all_values(addr) == 60, 0);
    }

    #[test(account = @0x1)]
    fun test_min_max(account: &signer) acquires DataContainer {
        create_container(account, 5);
        push_value(account, 30);
        push_value(account, 10);
        push_value(account, 50);
        push_value(account, 20);
        
        let addr = signer::address_of(account);
        assert!(find_min(addr) == 10, 0);
        assert!(find_max(addr) == 50, 1);
    }

    #[test(account = @0x1)]
    fun test_lock(account: &signer) acquires DataContainer {
        create_container(account, 5);
        push_value(account, 10);
        
        lock_container(account);
        let addr = signer::address_of(account);
        assert!(is_locked(addr) == true, 0);
        
        unlock_container(account);
        assert!(is_locked(addr) == false, 1);
    }

    #[test(account = @0x1)]
    #[expected_failure(abort_code = E_CONTAINER_LOCKED)]
    fun test_locked_push(account: &signer) acquires DataContainer {
        create_container(account, 5);
        lock_container(account);
        push_value(account, 10);  // åº”è¯¥å¤±è´¥
    }

    #[test(account = @0x1)]
    #[expected_failure(abort_code = E_CONTAINER_FULL)]
    fun test_full_container(account: &signer) acquires DataContainer {
        create_container(account, 2);
        push_value(account, 10);
        push_value(account, 20);
        push_value(account, 30);  // åº”è¯¥å¤±è´¥
    }
}
```

### ğŸ’¡ æç¤º

- ä½¿ç”¨ `vector::borrow` å’Œ `vector::borrow_mut` è·å–å¼•ç”¨
- éå†vectoræ—¶ä½¿ç”¨å¾ªç¯å’Œç´¢å¼•
- è®°å¾—åœ¨ä¿®æ”¹æ“ä½œå‰æ£€æŸ¥é”å®šçŠ¶æ€
- ç©ºå®¹å™¨æ—¶ find_max/find_min åº”è¯¥ abort

---

## æäº¤è¦æ±‚

### ğŸ“‚ æ–‡ä»¶ç»“æ„

```
Day_02_åŸºæœ¬æ•°æ®ç±»å‹ä¸å˜é‡/
â””â”€â”€ 02_å®è·µä»»åŠ¡/
    â””â”€â”€ ä½ çš„ç­”æ¡ˆ/
        â”œâ”€â”€ Move.toml
        â””â”€â”€ sources/
            â”œâ”€â”€ advanced_calculator.move
            â”œâ”€â”€ currency.move
            â””â”€â”€ data_container.move
```

### ğŸ“‹ Move.toml é…ç½®

```toml
[package]
name = "day02_practice"
version = "1.0.0"

[addresses]
my_addr = "_"

[dependencies.AptosFramework]
git = "https://github.com/aptos-labs/aptos-core.git"
rev = "mainnet"
subdir = "aptos-move/framework/aptos-framework"
```

### âœ… éªŒè¯æ–¹æ³•

```bash
# è¿›å…¥ä»»åŠ¡ç›®å½•
cd Day_02_åŸºæœ¬æ•°æ®ç±»å‹ä¸å˜é‡/02_å®è·µä»»åŠ¡/ä½ çš„ç­”æ¡ˆ

# ç¼–è¯‘
aptos move compile

# æµ‹è¯•æ‰€æœ‰ä»»åŠ¡
aptos move test

# æµ‹è¯•å•ä¸ªä»»åŠ¡
aptos move test --filter advanced_calculator
aptos move test --filter currency
aptos move test --filter data_container
```

---

## è¯„åˆ†æ ‡å‡†

| ä»»åŠ¡ | åˆ†æ•° | è¯„åˆ†è¦ç‚¹ |
|------|------|----------|
| **ä»»åŠ¡ 1** | 25 | æ‰€æœ‰å‡½æ•°æ­£ç¡®å®ç° (15åˆ†) + å®‰å…¨æ£€æŸ¥å®Œæ•´ (5åˆ†) + æµ‹è¯•é€šè¿‡ (5åˆ†) |
| **ä»»åŠ¡ 2** | 35 | è´§å¸è¿ç®—æ­£ç¡® (20åˆ†) + ç²¾åº¦å¤„ç†æ­£ç¡® (10åˆ†) + æµ‹è¯•é€šè¿‡ (5åˆ†) |
| **ä»»åŠ¡ 3** | 40 | åŸºæœ¬æ“ä½œæ­£ç¡® (15åˆ†) + å¼•ç”¨ä½¿ç”¨æ­£ç¡® (10åˆ†) + é”å®šæœºåˆ¶ (10åˆ†) + æµ‹è¯•é€šè¿‡ (5åˆ†) |

**æ€»åˆ†**ï¼š100 åˆ†  
**åŠæ ¼çº¿**ï¼š70 åˆ†  
**ä¼˜ç§€çº¿**ï¼š85 åˆ†

---

## ğŸ’¡ å­¦ä¹ é‡ç‚¹

### ä»»åŠ¡ 1 é‡ç‚¹

- âœ… ç†è§£æ•´æ•°æº¢å‡ºå’Œä¸‹æº¢
- âœ… ä½¿ç”¨æ›´å¤§ç±»å‹è¿›è¡Œä¸­é—´è®¡ç®—
- âœ… ç±»å‹è½¬æ¢çš„å®‰å…¨æ€§

### ä»»åŠ¡ 2 é‡ç‚¹

- âœ… å®šç‚¹æ•°çš„è¡¨ç¤ºå’Œè¿ç®—
- âœ… ç²¾åº¦å’Œèˆå…¥é—®é¢˜
- âœ… ç»“æ„ä½“çš„Copyèƒ½åŠ›

### ä»»åŠ¡ 3 é‡ç‚¹

- âœ… å¯å˜å¼•ç”¨ vs ä¸å¯å˜å¼•ç”¨
- âœ… å‘é‡çš„å€Ÿç”¨è§„åˆ™
- âœ… çŠ¶æ€ç®¡ç†ï¼ˆé”å®šæœºåˆ¶ï¼‰

---

## å¸¸è§é”™è¯¯

### âŒ é”™è¯¯ 1ï¼šå¿˜è®°æº¢å‡ºæ£€æŸ¥

```move
// é”™è¯¯
public fun add(a: u64, b: u64): u64 {
    a + b  // å¯èƒ½æº¢å‡º
}

// æ­£ç¡®
public fun safe_add(a: u64, b: u64): u64 {
    let sum = (a as u128) + (b as u128);
    assert!(sum <= MAX_U64, E_OVERFLOW);
    (sum as u64)
}
```

### âŒ é”™è¯¯ 2ï¼šç±»å‹è½¬æ¢æˆªæ–­

```move
// é”™è¯¯
let big: u64 = 300;
let small: u8 = (big as u8);  // æˆªæ–­ä¸º44

// æ­£ç¡®
assert!(big <= 255, E_VALUE_TOO_LARGE);
let small: u8 = (big as u8);
```

### âŒ é”™è¯¯ 3ï¼šå¼•ç”¨å†²çª

```move
// é”™è¯¯
let container = borrow_global_mut<Container>(addr);
let val1 = vector::borrow(&container.values, 0);
let val2 = vector::borrow_mut(&mut container.values, 1);  // å†²çª

// æ­£ç¡®ï¼šåˆ†å¼€æ“ä½œ
let val1 = {
    let container = borrow_global<Container>(addr);
    *vector::borrow(&container.values, 0)
};
let container = borrow_global_mut<Container>(addr);
let val2 = vector::borrow_mut(&mut container.values, 1);
```

---

## ğŸ¯ å®Œæˆæ£€æŸ¥æ¸…å•

- [ ] ä»»åŠ¡ 1ï¼šæ‰€æœ‰æµ‹è¯•é€šè¿‡
- [ ] ä»»åŠ¡ 2ï¼šæ‰€æœ‰æµ‹è¯•é€šè¿‡
- [ ] ä»»åŠ¡ 3ï¼šæ‰€æœ‰æµ‹è¯•é€šè¿‡
- [ ] ä»£ç ç¬¦åˆMoveç¼–ç è§„èŒƒ
- [ ] é”™è¯¯å¤„ç†å®Œæ•´
- [ ] æ³¨é‡Šæ¸…æ™°

**é¢„è®¡å®Œæˆæ—¶é—´**ï¼š3-4 å°æ—¶

åŠ æ²¹ï¼å®Œæˆè¿™äº›ä»»åŠ¡åï¼Œä½ å°†å½»åº•æŒæ¡Moveçš„ç±»å‹ç³»ç»Ÿï¼ğŸ’ª

````

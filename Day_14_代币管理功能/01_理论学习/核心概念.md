# ä»£å¸ç®¡ç†åŠŸèƒ½ï¼šæ ¸å¿ƒæ¦‚å¿µ

## ç¬¬ä¸€éƒ¨åˆ†ï¼šæƒé™èƒ½åŠ›ç³»ç»Ÿæ·±å…¥

### 1.1 ä¸‰å¤§æƒé™èƒ½åŠ›

Aptos Coin Framework æä¾›ä¸‰ç§ç‹¬ç«‹çš„æƒé™èƒ½åŠ›ï¼ˆCapabilityï¼‰ï¼Œæ¯ç§æ§åˆ¶ä¸åŒçš„ç‰¹æƒæ“ä½œï¼š

```move
/// é“¸é€ æƒé™ - åˆ›å»ºæ–°ä»£å¸
struct MintCapability<phantom CoinType> has key, store {}

/// é”€æ¯æƒé™ - æ°¸ä¹…ç§»é™¤ä»£å¸  
struct BurnCapability<phantom CoinType> has key, store {}

/// å†»ç»“æƒé™ - å†»ç»“/è§£å†»è´¦æˆ·
struct FreezeCapability<phantom CoinType> has key, store {}
```

**å…³é”®ç‰¹ç‚¹**ï¼š
- **phantom ç±»å‹å‚æ•°**ï¼šåªç”¨äºç±»å‹æ ‡è¯†ï¼Œä¸å­˜å‚¨æ•°æ®
- **has key, store**ï¼šå¯ä»¥å­˜å‚¨åœ¨å…¨å±€å’Œå±€éƒ¨
- **ç‹¬ç«‹åˆ†ç¦»**ï¼šå¯ä»¥åˆ†åˆ«æˆäºˆä¸åŒçš„è´¦æˆ·/è§’è‰²

### 1.2 æƒé™èƒ½åŠ›çš„ç”Ÿå‘½å‘¨æœŸ

```
åˆå§‹åŒ–ä»£å¸
     â†“
coin::initialize() è¿”å›ä¸‰ä¸ª capability
     â†“
  â”Œâ”€â”€â”´â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”
  â†“     â†“      â†“     â†“
å­˜å‚¨  è½¬ç§»  ä½¿ç”¨  é”€æ¯
```

**ç¤ºä¾‹**ï¼š
```move
fun init_module(account: &signer) {
    let (burn_cap, freeze_cap, mint_cap) = coin::initialize<MyCoin>(
        account,
        string::utf8(b"My Coin"),
        string::utf8(b"MYC"),
        8,
        true,
    );
    
    // é€‰é¡¹ 1ï¼šå­˜å‚¨åœ¨åˆ›å»ºè€…è´¦æˆ·
    move_to(account, Capabilities {
        mint_cap,
        burn_cap,
        freeze_cap,
    });
    
    // é€‰é¡¹ 2ï¼šåˆ†ç¦»å­˜å‚¨
    move_to(account, MintCap { mint_cap });
    move_to(&treasury_signer, BurnCap { burn_cap });
    move_to(&compliance_signer, FreezeCap { freeze_cap });
    
    // é€‰é¡¹ 3ï¼šé”€æ¯æŸäº›æƒé™
    coin::destroy_mint_cap(mint_cap);  // å›ºå®šä¾›åº”é‡
    coin::destroy_freeze_cap(freeze_cap);  // ä¸æ”¯æŒå†»ç»“
    move_to(account, BurnCap { burn_cap });  // åªä¿ç•™é”€æ¯
}
```

---

## ç¬¬äºŒéƒ¨åˆ†ï¼šé“¸é€ æœºåˆ¶ï¼ˆMintingï¼‰

### 2.1 åŸºç¡€é“¸é€ 

```move
use aptos_framework::coin;

/// é“¸é€ ä»£å¸
public fun mint_tokens(
    amount: u64,
    mint_cap: &MintCapability<MyCoin>
): Coin<MyCoin> {
    coin::mint(amount, mint_cap)
}
```

**å·¥ä½œåŸç†**ï¼š
1. è°ƒç”¨ `coin::mint()` åˆ›å»ºæ–°çš„ `Coin<CoinType>` å¯¹è±¡
2. å¦‚æœè¿½è¸ªä¾›åº”é‡ï¼Œè‡ªåŠ¨æ›´æ–° `CoinInfo.supply`
3. è¿”å› `Coin` å¯¹è±¡ï¼Œéœ€è¦å­˜å…¥æŸä¸ªè´¦æˆ·

**å®Œæ•´æµç¨‹**ï¼š
```move
public entry fun mint_and_deposit(
    admin: &signer,
    recipient: address,
    amount: u64
) acquires MintCap {
    // 1. éªŒè¯æƒé™
    let admin_addr = signer::address_of(admin);
    assert!(admin_addr == @admin, ERROR_NOT_ADMIN);
    
    // 2. è·å– capability
    let caps = borrow_global<MintCap>(@admin);
    
    // 3. é“¸é€ 
    let coins = coin::mint(amount, &caps.mint_cap);
    
    // 4. å­˜å…¥è´¦æˆ·
    coin::deposit(recipient, coins);
}
```

### 2.2 é™é¢é“¸é€ 

é˜²æ­¢æ— é™åˆ¶é“¸é€ ï¼Œä¿æŠ¤ç»æµå®‰å…¨ï¼š

```move
struct MintLimit has key {
    daily_limit: u64,
    minted_today: u64,
    last_reset_timestamp: u64,
}

public fun mint_with_limit(
    amount: u64,
    mint_cap: &MintCapability<MyCoin>
) acquires MintLimit {
    let limit = borrow_global_mut<MintLimit>(@admin);
    
    // æ£€æŸ¥æ˜¯å¦éœ€è¦é‡ç½®ï¼ˆæ–°çš„ä¸€å¤©ï¼‰
    let now = timestamp::now_seconds();
    let current_day = now / 86400;  // 86400 ç§’ = 1 å¤©
    let last_day = limit.last_reset_timestamp / 86400;
    
    if (current_day > last_day) {
        limit.minted_today = 0;
        limit.last_reset_timestamp = now;
    };
    
    // æ£€æŸ¥é™é¢
    assert!(
        limit.minted_today + amount <= limit.daily_limit,
        ERROR_EXCEED_DAILY_LIMIT
    );
    
    // é“¸é€ 
    let coins = coin::mint(amount, mint_cap);
    limit.minted_today = limit.minted_today + amount;
    
    coins
}
```

### 2.3 åˆ†é˜¶æ®µé‡Šæ”¾ï¼ˆVestingï¼‰

æŒ‰æ—¶é—´é€æ­¥é‡Šæ”¾ä»£å¸ï¼š

```move
struct VestingSchedule has key {
    beneficiary: address,
    total_amount: u64,
    released_amount: u64,
    start_time: u64,
    cliff_duration: u64,     // é”å®šæœŸ
    vesting_duration: u64,   // é‡Šæ”¾æœŸ
    mint_cap: MintCapability<MyCoin>,
}

public fun release_vested_tokens() acquires VestingSchedule {
    let schedule = borrow_global_mut<VestingSchedule>(@admin);
    let now = timestamp::now_seconds();
    
    // æ£€æŸ¥æ˜¯å¦è¿‡äº†é”å®šæœŸ
    assert!(now >= schedule.start_time + schedule.cliff_duration, ERROR_CLIFF_NOT_REACHED);
    
    // è®¡ç®—åº”é‡Šæ”¾çš„æ•°é‡
    let elapsed = now - schedule.start_time;
    if (elapsed > schedule.vesting_duration) {
        elapsed = schedule.vesting_duration;
    };
    
    let should_release = (schedule.total_amount * elapsed) / schedule.vesting_duration;
    let to_release = should_release - schedule.released_amount;
    
    if (to_release > 0) {
        let coins = coin::mint(to_release, &schedule.mint_cap);
        coin::deposit(schedule.beneficiary, coins);
        schedule.released_amount = should_release;
    }
}
```

---

## ç¬¬ä¸‰éƒ¨åˆ†ï¼šé”€æ¯æœºåˆ¶ï¼ˆBurningï¼‰

### 3.1 åŸºç¡€é”€æ¯

```move
/// é”€æ¯ä»£å¸
public fun burn_tokens(
    coin: Coin<MyCoin>,
    burn_cap: &BurnCapability<MyCoin>
) {
    coin::burn(coin, burn_cap);
}
```

**å·¥ä½œåŸç†**ï¼š
1. æ¥å—ä¸€ä¸ª `Coin<CoinType>` å¯¹è±¡
2. æ°¸ä¹…é”€æ¯ä»£å¸
3. æ›´æ–°æ€»ä¾›åº”é‡ï¼ˆå¦‚æœè¿½è¸ªï¼‰
4. ä»£å¸ä¸å¯æ¢å¤

**ä»è´¦æˆ·é”€æ¯**ï¼š
```move
public entry fun burn_from_account(
    account: &signer,
    amount: u64
) acquires BurnCap {
    let account_addr = signer::address_of(account);
    
    // 1. ä»è´¦æˆ·æå–
    let coins = coin::withdraw<MyCoin>(account, amount);
    
    // 2. è·å–é”€æ¯æƒé™
    let caps = borrow_global<BurnCap>(@admin);
    
    // 3. é”€æ¯
    coin::burn(coins, &caps.burn_cap);
}
```

### 3.2 é€šç¼©æ¨¡å‹ï¼šè½¬è´¦é”€æ¯

æ¯æ¬¡è½¬è´¦è‡ªåŠ¨é”€æ¯ä¸€å®šæ¯”ä¾‹ä½œä¸ºæ‰‹ç»­è´¹ï¼š

```move
const BURN_RATE_BASIS_POINTS: u64 = 100;  // 1% = 100 åŸºç‚¹
const BASIS_POINTS_DIVISOR: u64 = 10000;

public entry fun transfer_with_burn(
    from: &signer,
    to: address,
    amount: u64
) acquires BurnCap {
    // 1. è®¡ç®—é”€æ¯æ•°é‡
    let burn_amount = (amount * BURN_RATE_BASIS_POINTS) / BASIS_POINTS_DIVISOR;
    let transfer_amount = amount - burn_amount;
    
    // 2. æå–å…¨éƒ¨
    let all_coins = coin::withdraw<MyCoin>(from, amount);
    
    // 3. åˆ†ç¦»è¦é”€æ¯çš„éƒ¨åˆ†
    let burn_coins = coin::extract(&mut all_coins, burn_amount);
    
    // 4. é”€æ¯
    let caps = borrow_global<BurnCap>(@admin);
    coin::burn(burn_coins, &caps.burn_cap);
    
    // 5. è½¬è´¦å‰©ä½™
    coin::deposit(to, all_coins);
}
```

### 3.3 å›è´­é”€æ¯

ä½¿ç”¨åè®®æ”¶å…¥å›è´­å¹¶é”€æ¯ä»£å¸ï¼š

```move
struct BuybackConfig has key {
    treasury: Coin<AptosCoin>,  // ç”¨äºå›è´­çš„èµ„é‡‘
    burn_cap: BurnCapability<MyCoin>,
    total_burned: u64,
}

public fun execute_buyback(
    buyback_amount: u64,  // APT æ•°é‡
) acquires BuybackConfig {
    let config = borrow_global_mut<BuybackConfig>(@admin);
    
    // 1. ä»é‡‘åº“æå– APT
    let payment = coin::extract(&mut config.treasury, buyback_amount);
    
    // 2. åœ¨ DEX ä¸Šç”¨ APT ä¹°å…¥ MyCoin
    let bought_coins = swap_apt_for_mycoin(payment);
    
    // 3. é”€æ¯ä¹°å…¥çš„ä»£å¸
    let burn_amount = coin::value(&bought_coins);
    coin::burn(bought_coins, &config.burn_cap);
    
    // 4. æ›´æ–°ç»Ÿè®¡
    config.total_burned = config.total_burned + burn_amount;
}
```

---

## ç¬¬å››éƒ¨åˆ†ï¼šå†»ç»“æœºåˆ¶ï¼ˆFreezingï¼‰

### 4.1 åŸºç¡€å†»ç»“

```move
/// å†»ç»“è´¦æˆ·
public fun freeze_account(
    account_addr: address,
    freeze_cap: &FreezeCapability<MyCoin>
) {
    coin::freeze_coin_store<MyCoin>(account_addr, freeze_cap);
}

/// è§£å†»è´¦æˆ·
public fun unfreeze_account(
    account_addr: address,
    freeze_cap: &FreezeCapability<MyCoin>
) {
    coin::unfreeze_coin_store<MyCoin>(account_addr, freeze_cap);
}
```

**æ•ˆæœ**ï¼š
- å†»ç»“åï¼Œè´¦æˆ·**ä¸èƒ½æ¥æ”¶**æˆ–**å‘é€**ä»£å¸
- æŸ¥è¯¢ä½™é¢ä»ç„¶å¯ä»¥
- åªå½±å“ç‰¹å®šä»£å¸ç±»å‹

### 4.2 åˆè§„å†»ç»“ç³»ç»Ÿ

ç”¨äºæ»¡è¶³ç›‘ç®¡è¦æ±‚ï¼ˆå¦‚ USDCï¼‰ï¼š

```move
struct ComplianceManager has key {
    freeze_cap: FreezeCapability<MyCoin>,
    compliance_admin: address,
    frozen_accounts: Table<address, FreezeReason>,
    freeze_history: vector<FreezeRecord>,
}

struct FreezeReason has store {
    reason_code: u8,        // 1=æ³•å¾‹è¦æ±‚, 2=å¯ç–‘æ´»åŠ¨, 3=å…¶ä»–
    description: String,
    frozen_at: u64,
    frozen_by: address,
}

struct FreezeRecord has store, drop {
    account: address,
    action: u8,             // 0=å†»ç»“, 1=è§£å†»
    timestamp: u64,
    operator: address,
}

public entry fun freeze_for_compliance(
    admin: &signer,
    account_addr: address,
    reason_code: u8,
    description: vector<u8>
) acquires ComplianceManager {
    let manager = borrow_global_mut<ComplianceManager>(@admin);
    
    // éªŒè¯æƒé™
    assert!(
        signer::address_of(admin) == manager.compliance_admin,
        ERROR_NOT_COMPLIANCE_ADMIN
    );
    
    // æ‰§è¡Œå†»ç»“
    coin::freeze_coin_store<MyCoin>(account_addr, &manager.freeze_cap);
    
    // è®°å½•åŸå› 
    table::add(&mut manager.frozen_accounts, account_addr, FreezeReason {
        reason_code,
        description: string::utf8(description),
        frozen_at: timestamp::now_seconds(),
        frozen_by: signer::address_of(admin),
    });
    
    // è®°å½•å†å²
    vector::push_back(&mut manager.freeze_history, FreezeRecord {
        account: account_addr,
        action: 0,  // å†»ç»“
        timestamp: timestamp::now_seconds(),
        operator: signer::address_of(admin),
    });
}
```

### 4.3 æŸ¥è¯¢å†»ç»“çŠ¶æ€

```move
#[view]
public fun is_frozen(account_addr: address): bool {
    coin::is_coin_store_frozen<MyCoin>(account_addr)
}

#[view]
public fun get_freeze_reason(account_addr: address): (u8, String, u64) 
acquires ComplianceManager {
    let manager = borrow_global<ComplianceManager>(@admin);
    if (table::contains(&manager.frozen_accounts, account_addr)) {
        let reason = table::borrow(&manager.frozen_accounts, account_addr);
        (reason.reason_code, reason.description, reason.frozen_at)
    } else {
        (0, string::utf8(b""), 0)
    }
}
```

---

## ç¬¬äº”éƒ¨åˆ†ï¼šæƒé™ç®¡ç†æœ€ä½³å®è·µ

### 5.1 æƒé™åˆ†ç¦»æ¶æ„

```move
/// ä¸åŒè§’è‰²æŒæœ‰ä¸åŒæƒé™
module my_coin::roles {
    struct Treasurer has key {
        mint_cap: MintCapability<MyCoin>,
    }
    
    struct Auditor has key {
        burn_cap: BurnCapability<MyCoin>,
    }
    
    struct ComplianceOfficer has key {
        freeze_cap: FreezeCapability<MyCoin>,
    }
}
```

### 5.2 å¤šç­¾åæ§åˆ¶

é‡è¦æ“ä½œéœ€è¦å¤šä¸ªç­¾åï¼š

```move
struct MultiSigMint has key {
    pending_mints: Table<u64, PendingMint>,
    next_id: u64,
    signers: vector<address>,
    required_sigs: u64,
    mint_cap: MintCapability<MyCoin>,
}

struct PendingMint has store {
    recipient: address,
    amount: u64,
    signatures: vector<address>,
    executed: bool,
}

public entry fun propose_mint(
    proposer: &signer,
    recipient: address,
    amount: u64
) acquires MultiSigMint {
    let multisig = borrow_global_mut<MultiSigMint>(@admin);
    
    // éªŒè¯æ˜¯ç­¾åè€…ä¹‹ä¸€
    let proposer_addr = signer::address_of(proposer);
    assert!(vector::contains(&multisig.signers, &proposer_addr), ERROR_NOT_SIGNER);
    
    // åˆ›å»ºææ¡ˆ
    let id = multisig.next_id;
    table::add(&mut multisig.pending_mints, id, PendingMint {
        recipient,
        amount,
        signatures: vector[proposer_addr],  // ææ¡ˆè€…è‡ªåŠ¨ç­¾å
        executed: false,
    });
    
    multisig.next_id = id + 1;
}

public entry fun sign_mint_proposal(
    signer: &signer,
    proposal_id: u64
) acquires MultiSigMint {
    let multisig = borrow_global_mut<MultiSigMint>(@admin);
    let proposal = table::borrow_mut(&mut multisig.pending_mints, proposal_id);
    
    let signer_addr = signer::address_of(signer);
    
    // éªŒè¯æ˜¯ç­¾åè€…ä¸”æœªç­¾å
    assert!(vector::contains(&multisig.signers, &signer_addr), ERROR_NOT_SIGNER);
    assert!(!vector::contains(&proposal.signatures, &signer_addr), ERROR_ALREADY_SIGNED);
    
    // æ·»åŠ ç­¾å
    vector::push_back(&mut proposal.signatures, signer_addr);
}

public entry fun execute_mint_proposal(
    executor: &signer,
    proposal_id: u64
) acquires MultiSigMint {
    let multisig = borrow_global_mut<MultiSigMint>(@admin);
    let proposal = table::borrow_mut(&mut multisig.pending_mints, proposal_id);
    
    // æ£€æŸ¥ç­¾åæ•°é‡
    assert!(
        vector::length(&proposal.signatures) >= multisig.required_sigs,
        ERROR_INSUFFICIENT_SIGNATURES
    );
    assert!(!proposal.executed, ERROR_ALREADY_EXECUTED);
    
    // æ‰§è¡Œé“¸é€ 
    let coins = coin::mint(proposal.amount, &multisig.mint_cap);
    coin::deposit(proposal.recipient, coins);
    
    proposal.executed = true;
}
```

### 5.3 æ—¶é—´é”

ä¸ºå…³é”®æ“ä½œæ·»åŠ å»¶è¿Ÿï¼š

```move
struct TimeLockMint has key {
    pending_mints: Table<u64, TimedMint>,
    delay: u64,  // å»¶è¿Ÿæ—¶é—´ï¼ˆç§’ï¼‰
    mint_cap: MintCapability<MyCoin>,
}

struct TimedMint has store {
    recipient: address,
    amount: u64,
    unlock_time: u64,
    executed: bool,
}

public entry fun schedule_mint(
    admin: &signer,
    recipient: address,
    amount: u64,
    id: u64
) acquires TimeLockMint {
    let timelock = borrow_global_mut<TimeLockMint>(@admin);
    let now = timestamp::now_seconds();
    
    table::add(&mut timelock.pending_mints, id, TimedMint {
        recipient,
        amount,
        unlock_time: now + timelock.delay,
        executed: false,
    });
}

public entry fun execute_scheduled_mint(
    executor: &signer,
    id: u64
) acquires TimeLockMint {
    let timelock = borrow_global_mut<TimeLockMint>(@admin);
    let timed_mint = table::borrow_mut(&mut timelock.pending_mints, id);
    
    let now = timestamp::now_seconds();
    assert!(now >= timed_mint.unlock_time, ERROR_TIMELOCK_NOT_EXPIRED);
    assert!(!timed_mint.executed, ERROR_ALREADY_EXECUTED);
    
    let coins = coin::mint(timed_mint.amount, &timelock.mint_cap);
    coin::deposit(timed_mint.recipient, coins);
    
    timed_mint.executed = true;
}
```

---

## ç¬¬å…­éƒ¨åˆ†ï¼šä¾›åº”é‡ç®¡ç†ç­–ç•¥

### 6.1 å›ºå®šä¾›åº”é‡

```move
fun init_module(account: &signer) {
    let (burn_cap, freeze_cap, mint_cap) = coin::initialize<FixedCoin>(...);
    
    // é“¸é€ å…¨éƒ¨ä¾›åº”é‡
    let total_supply = 1000000 * 100000000;  // 100ä¸‡ä¸ªå¸
    let all_coins = coin::mint(total_supply, &mint_cap);
    
    // å­˜å…¥é‡‘åº“
    coin::deposit(@treasury, all_coins);
    
    // é”€æ¯é“¸é€ æƒé™ - ä¸å¯å†é“¸é€ 
    coin::destroy_mint_cap(mint_cap);
    
    // å¯é€‰æ‹©ä¿ç•™é”€æ¯æƒé™
    move_to(account, Capabilities {
        burn_cap,
        freeze_cap,
    });
}
```

### 6.2 é€šèƒ€æ¨¡å‹

å®šæœŸé“¸é€ æ–°ä»£å¸ä½œä¸ºå¥–åŠ±ï¼š

```move
struct InflationConfig has key {
    mint_cap: MintCapability<InflationCoin>,
    annual_rate: u64,        // å¹´é€šèƒ€ç‡ï¼ˆåŸºç‚¹ï¼‰
    last_mint_time: u64,
    rewards_pool: address,
}

const SECONDS_PER_YEAR: u64 = 31536000;

public fun mint_inflation_rewards() acquires InflationConfig {
    let config = borrow_global_mut<InflationConfig>(@admin);
    let now = timestamp::now_seconds();
    let elapsed = now - config.last_mint_time;
    
    // è®¡ç®—åº”é“¸é€ çš„æ•°é‡
    let current_supply = option::extract(&mut coin::supply<InflationCoin>());
    let annual_inflation = (current_supply * config.annual_rate) / 10000;
    let to_mint = (annual_inflation * elapsed) / SECONDS_PER_YEAR;
    
    if (to_mint > 0) {
        let coins = coin::mint(to_mint, &config.mint_cap);
        coin::deposit(config.rewards_pool, coins);
        config.last_mint_time = now;
    }
}
```

### 6.3 ç®—æ³•ç¨³å®šå¸ï¼ˆé«˜çº§ï¼‰

åŠ¨æ€è°ƒæ•´ä¾›åº”é‡ç»´æŒä»·æ ¼ç¨³å®šï¼š

```move
struct StablecoinController has key {
    mint_cap: MintCapability<StableCoin>,
    burn_cap: BurnCapability<StableCoin>,
    target_price: u64,       // ç›®æ ‡ä»·æ ¼ï¼ˆå¦‚ $1.00ï¼‰
    price_tolerance: u64,    // ä»·æ ¼å®¹å¿åº¦
}

public fun rebase() acquires StablecoinController {
    let controller = borrow_global_mut<StablecoinController>(@admin);
    
    // è·å–å½“å‰ä»·æ ¼ï¼ˆä»é¢„è¨€æœºï¼‰
    let current_price = get_price_from_oracle();
    
    if (current_price > controller.target_price + controller.price_tolerance) {
        // ä»·æ ¼è¿‡é«˜ â†’ å¢åŠ ä¾›åº”ï¼ˆé“¸é€ ï¼‰
        let supply_increase = calculate_supply_adjustment(current_price);
        let coins = coin::mint(supply_increase, &controller.mint_cap);
        // é€šè¿‡ DEX æˆ–ç©ºæŠ•åˆ†å‘...
    } else if (current_price < controller.target_price - controller.price_tolerance) {
        // ä»·æ ¼è¿‡ä½ â†’ å‡å°‘ä¾›åº”ï¼ˆå›è´­é”€æ¯ï¼‰
        let supply_decrease = calculate_supply_adjustment(current_price);
        // ä»é‡‘åº“æˆ– DEX å›è´­...
        // coin::burn(bought_coins, &controller.burn_cap);
    }
}
```

---

## ğŸ’¡ å…³é”®è¦ç‚¹æ€»ç»“

### æƒé™ç®¡ç†
- âœ… åˆ†ç¦»å­˜å‚¨ä¸åŒæƒé™
- âœ… ä½¿ç”¨å¤šç­¾æ§åˆ¶é‡è¦æ“ä½œ
- âœ… æ·»åŠ æ—¶é—´é”ä¿æŠ¤
- âœ… é™åˆ¶æƒé™ä½¿ç”¨é¢‘ç‡å’Œé¢åº¦

### é“¸é€ ç­–ç•¥
- âœ… è®¾ç½®æ—¥é™é¢
- âœ… å®ç°åˆ†é˜¶æ®µé‡Šæ”¾
- âœ… è®°å½•é“¸é€ å†å²
- âœ… å‘å°„äº‹ä»¶é€šçŸ¥

### é”€æ¯ç­–ç•¥
- âœ… è½¬è´¦é”€æ¯å®ç°é€šç¼©
- âœ… å›è´­é”€æ¯æå‡ä»·å€¼
- âœ… ç»Ÿè®¡ç´¯è®¡é”€æ¯é‡
- âœ… è®¾è®¡åˆç†çš„é”€æ¯ç‡

### å†»ç»“ç®¡ç†
- âœ… è®°å½•å†»ç»“åŸå› 
- âœ… ç»´æŠ¤å†»ç»“å†å²
- âœ… ä¸¥æ ¼æ§åˆ¶å†»ç»“æƒé™
- âœ… æä¾›æŸ¥è¯¢æ¥å£

---

**ä¸‹ä¸€æ­¥**ï¼šå­¦ä¹ ä»£ç ç¤ºä¾‹ï¼Œç„¶åå®Œæˆå®è·µä»»åŠ¡ï¼ğŸš€

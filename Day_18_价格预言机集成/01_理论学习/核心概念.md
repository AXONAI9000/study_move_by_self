# æ ¸å¿ƒæ¦‚å¿µï¼šä»·æ ¼é¢„è¨€æœºé›†æˆ

## ğŸ“š ç›®å½•

1. [é¢„è¨€æœºåŸºç¡€](#1-é¢„è¨€æœºåŸºç¡€)
2. [Pyth Network æ·±å…¥](#2-pyth-network-æ·±å…¥)
3. [Switchboard åŸç†](#3-switchboard-åŸç†)
4. [ä»·æ ¼èšåˆç­–ç•¥](#4-ä»·æ ¼èšåˆç­–ç•¥)
5. [å®‰å…¨æœ€ä½³å®è·µ](#5-å®‰å…¨æœ€ä½³å®è·µ)
6. [å®é™…åº”ç”¨åœºæ™¯](#6-å®é™…åº”ç”¨åœºæ™¯)

---

## 1. é¢„è¨€æœºåŸºç¡€

### 1.1 ä»€ä¹ˆæ˜¯é¢„è¨€æœºï¼Ÿ

**é¢„è¨€æœºï¼ˆOracleï¼‰** æ˜¯åŒºå—é“¾ä¸å¤–éƒ¨ä¸–ç•Œä¹‹é—´çš„æ¡¥æ¢ï¼Œå®ƒè§£å†³äº†"é¢„è¨€æœºé—®é¢˜"ï¼š

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   åŒºå—é“¾ä¸–ç•Œ                         â”‚
â”‚                                                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚
â”‚  â”‚       æ™ºèƒ½åˆçº¦                        â”‚          â”‚
â”‚  â”‚  - éœ€è¦å¤–éƒ¨æ•°æ®                       â”‚          â”‚
â”‚  â”‚  - æ— æ³•ä¸»åŠ¨è·å–é“¾ä¸‹ä¿¡æ¯                â”‚          â”‚
â”‚  â”‚  - éœ€è¦å¯ä¿¡çš„æ•°æ®æº                   â”‚          â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚
â”‚                 â”‚                                   â”‚
â”‚                 â”‚  é¢„è¨€æœº                            â”‚
â”‚                 â”‚  â†“                                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                  â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                 â†“                                   â”‚
â”‚           â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                              â”‚
â”‚           â”‚ é¢„è¨€æœº    â”‚                              â”‚
â”‚           â”‚  èŠ‚ç‚¹     â”‚                              â”‚
â”‚           â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜                              â”‚
â”‚                 â”‚                                   â”‚
â”‚        ç°å®ä¸–ç•Œæ•°æ®æº                                â”‚
â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”           â”‚
â”‚    â”‚ äº¤æ˜“æ‰€  â”‚ API    â”‚ ä¼ æ„Ÿå™¨ â”‚ å…¶ä»–   â”‚           â”‚
â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”˜           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 1.2 é¢„è¨€æœºçš„ç±»å‹

#### 1.2.1 æŒ‰ä¸­å¿ƒåŒ–ç¨‹åº¦åˆ†ç±»

**ä¸­å¿ƒåŒ–é¢„è¨€æœº**
- **ä¼˜ç‚¹**ï¼š
  - å»¶è¿Ÿä½ï¼Œæ›´æ–°å¿«
  - å®ç°ç®€å•
  - æˆæœ¬ä½
- **ç¼ºç‚¹**ï¼š
  - å•ç‚¹æ•…éšœé£é™©
  - å¯èƒ½è¢«æ“çºµ
  - ä¿¡ä»»é—®é¢˜

**å»ä¸­å¿ƒåŒ–é¢„è¨€æœº**
- **ä¼˜ç‚¹**ï¼š
  - æ›´å®‰å…¨å¯é 
  - æŠ—å®¡æŸ¥
  - å¤šæºéªŒè¯
- **ç¼ºç‚¹**ï¼š
  - å»¶è¿Ÿè¾ƒé«˜
  - æˆæœ¬è¾ƒé«˜
  - å¤æ‚åº¦é«˜

#### 1.2.2 æŒ‰æ›´æ–°æ¨¡å¼åˆ†ç±»

**æ¨é€æ¨¡å¼ï¼ˆPush-basedï¼‰**
```move
// é¢„è¨€æœºä¸»åŠ¨å°†æ•°æ®æ¨é€åˆ°é“¾ä¸Š
// ç‰¹ç‚¹ï¼šå®æ—¶æ€§å¼ºï¼Œä½†æˆæœ¬é«˜

module pyth_oracle {
    // é¢„è¨€æœºèŠ‚ç‚¹å®šæœŸæ¨é€ä»·æ ¼
    public entry fun update_price(
        oracle: &signer,
        price_feed_id: vector<u8>,
        price: u64,
        confidence: u64,
        timestamp: u64
    ) {
        // éªŒè¯ oracle èº«ä»½
        // å­˜å‚¨ä»·æ ¼æ•°æ®
        // å‘å‡ºæ›´æ–°äº‹ä»¶
    }
}
```

**æ‹‰å–æ¨¡å¼ï¼ˆPull-basedï¼‰**
```move
// ç”¨æˆ·éœ€è¦æ—¶ä¸»åŠ¨è·å–æ•°æ®
// ç‰¹ç‚¹ï¼šæŒ‰éœ€è·å–ï¼Œæˆæœ¬å¯æ§

module oracle_consumer {
    // ç”¨æˆ·åœ¨éœ€è¦æ—¶æŸ¥è¯¢ä»·æ ¼
    public fun get_current_price(
        price_feed_id: vector<u8>
    ): u64 {
        // ä»é¢„è¨€æœºåˆçº¦è¯»å–ä»·æ ¼
        pyth::get_price(price_feed_id)
    }
}
```

### 1.3 ä»·æ ¼é¢„è¨€æœºçš„å…³é”®å±æ€§

#### 1.3.1 æ–°é²œåº¦ï¼ˆFreshnessï¼‰

```move
struct PriceData has store {
    price: u64,           // ä»·æ ¼å€¼
    timestamp: u64,       // æ•°æ®æ—¶é—´æˆ³
    confidence: u64,      // ç½®ä¿¡åŒºé—´
}

// æ£€æŸ¥ä»·æ ¼æ–°é²œåº¦
public fun is_price_fresh(
    price_data: &PriceData,
    max_age: u64
): bool {
    let current_time = timestamp::now_seconds();
    (current_time - price_data.timestamp) <= max_age
}
```

**æ–°é²œåº¦è¦æ±‚**ï¼š
- **é«˜é¢‘äº¤æ˜“**ï¼š< 1 ç§’
- **DEX å±•ç¤º**ï¼š< 60 ç§’
- **å€Ÿè´·æ¸…ç®—**ï¼š< 120 ç§’
- **ç»Ÿè®¡åˆ†æ**ï¼š< 3600 ç§’

#### 1.3.2 å‡†ç¡®æ€§ï¼ˆAccuracyï¼‰

```move
// ç½®ä¿¡åŒºé—´è¡¨ç¤ºä»·æ ¼çš„ä¸ç¡®å®šæ€§
struct PriceWithConfidence has store {
    price: u64,           // ä¸­é—´ä»·æ ¼
    confidence: u64,      // ç½®ä¿¡åŒºé—´ï¼ˆ95%ï¼‰
}

// å®é™…ä»·æ ¼èŒƒå›´ï¼š[price - confidence, price + confidence]
// ä¾‹å¦‚ï¼š
// price = 100_000_000 (100 USD, 6 decimals)
// confidence = 500_000 (0.5 USD)
// å®é™…ä»·æ ¼ï¼š99.5 - 100.5 USD
```

**ç½®ä¿¡åº¦è¦æ±‚**ï¼š
- **æ¸…ç®—æ“ä½œ**ï¼šç½®ä¿¡åº¦ < 0.5%
- **ä»·æ ¼å±•ç¤º**ï¼šç½®ä¿¡åº¦ < 1%
- **ç»Ÿè®¡ç”¨é€”**ï¼šç½®ä¿¡åº¦ < 5%

#### 1.3.3 å¯ç”¨æ€§ï¼ˆAvailabilityï¼‰

```move
// é¢„è¨€æœºåº”è¯¥å§‹ç»ˆå¯ç”¨
public fun get_price_with_fallback(
    primary_feed_id: vector<u8>,
    fallback_feed_id: vector<u8>
): u64 {
    // å°è¯•ä¸»é¢„è¨€æœº
    if (pyth::is_available(primary_feed_id)) {
        let (price, timestamp) = pyth::get_price_with_timestamp(primary_feed_id);
        if (is_fresh(timestamp)) {
            return price
        }
    };
    
    // ä½¿ç”¨å¤‡ç”¨é¢„è¨€æœº
    switchboard::get_price(fallback_feed_id)
}
```

---

## 2. Pyth Network æ·±å…¥

### 2.1 Pyth æ¶æ„

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    æ•°æ®å‘å¸ƒè€…å±‚                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”     â”‚
â”‚  â”‚Binanceâ”‚ â”‚Coinbaseâ”‚ â”‚OKX  â”‚  â”‚åšå¸‚å•†â”‚  â”‚ ...  â”‚     â”‚
â”‚  â””â”€â”€â”€â”¬â”€â”€â”˜  â””â”€â”€â”€â”¬â”€â”€â”˜  â””â”€â”€â”€â”¬â”€â”€â”˜  â””â”€â”€â”€â”¬â”€â”€â”˜  â””â”€â”€â”€â”¬â”€â”€â”˜     â”‚
â”‚      â”‚         â”‚         â”‚         â”‚         â”‚         â”‚
â””â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚         â”‚         â”‚         â”‚         â”‚
       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                 â”‚         â”‚         â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                â–¼         â–¼         â–¼                     â”‚
â”‚           Pyth èšåˆå™¨ï¼ˆé“¾ä¸‹ï¼‰                             â”‚
â”‚  - æ”¶é›†å¤šæºä»·æ ¼æ•°æ®                                       â”‚
â”‚  - è®¡ç®—ä¸­ä½æ•°/åŠ æƒå¹³å‡                                    â”‚
â”‚  - ç”Ÿæˆç½®ä¿¡åŒºé—´                                          â”‚
â”‚  - ç­¾åä»·æ ¼æ•°æ®ï¼ˆVAAï¼‰                                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                 â”‚
                 â”‚ VAA (Verified Action Approval)
                 â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              Wormhole è·¨é“¾æ¡¥                              â”‚
â”‚  - éªŒè¯ç­¾å                                              â”‚
â”‚  - è·¨é“¾ä¼ è¾“                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                 â”‚
                 â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚            Aptos é“¾ä¸Š Pyth åˆçº¦                          â”‚
â”‚  - å­˜å‚¨ä»·æ ¼æ•°æ®                                          â”‚
â”‚  - æä¾›æŸ¥è¯¢æ¥å£                                          â”‚
â”‚  - éªŒè¯æ•°æ®æœ‰æ•ˆæ€§                                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2.2 Pyth ä»·æ ¼æ•°æ®ç»“æ„

```move
module pyth {
    /// ä»·æ ¼æ•°æ®ç»“æ„
    struct Price has copy, drop, store {
        /// ä»·æ ¼å€¼ï¼ˆå¸¦ç¬¦å·æ•´æ•°ï¼‰
        price: I64,
        
        /// ç½®ä¿¡åŒºé—´ï¼ˆæ— ç¬¦å·æ•´æ•°ï¼‰
        conf: u64,
        
        /// æŒ‡æ•°ï¼ˆ10çš„å¹‚ï¼‰
        /// å®é™…ä»·æ ¼ = price * 10^expo
        expo: I64,
        
        /// å‘å¸ƒæ—¶é—´æˆ³ï¼ˆç§’ï¼‰
        timestamp: u64,
    }
    
    /// ç¤ºä¾‹ï¼šBTC/USD ä»·æ ¼
    /// price = 4500000000000 (45000 * 10^8)
    /// expo = -8
    /// å®é™…ä»·æ ¼ = 4500000000000 * 10^(-8) = 45,000 USD
    
    struct PriceFeed has key {
        /// ä»·æ ¼ Feed ID
        id: vector<u8>,
        
        /// å½“å‰ä»·æ ¼
        price: Price,
        
        /// EMA ä»·æ ¼ï¼ˆæŒ‡æ•°ç§»åŠ¨å¹³å‡ï¼‰
        ema_price: Price,
    }
}
```

### 2.3 åœ¨ Aptos ä¸Šä½¿ç”¨ Pyth

#### 2.3.1 è·å–ä»·æ ¼

```move
use pyth::pyth;
use pyth::price;
use pyth::i64;

/// è·å– BTC/USD ä»·æ ¼
public fun get_btc_price(): (u64, u64) {
    // BTC/USD Price Feed ID
    let price_feed_id = x"e62df6c8b4a85fe1a67db44dc12de5db330f7ac66b72dc658afedf0f4a415b43";
    
    // è·å–ä»·æ ¼æ•°æ®
    let price_struct = pyth::get_price(price_feed_id);
    
    // æå–ä»·æ ¼å’Œç½®ä¿¡åŒºé—´
    let price_value = price::get_price(&price_struct);
    let confidence = price::get_conf(&price_struct);
    let expo = price::get_expo(&price_struct);
    let timestamp = price::get_timestamp(&price_struct);
    
    // æ£€æŸ¥æ–°é²œåº¦
    let current_time = timestamp::now_seconds();
    assert!(current_time - timestamp < 60, ERROR_STALE_PRICE);
    
    // è½¬æ¢ä¸ºæ ‡å‡†æ ¼å¼ï¼ˆ6 decimalsï¼‰
    let price_i64 = i64::get_magnitude_if_positive(&price_value);
    let expo_i64 = i64::get_magnitude_if_negative(&expo);
    
    // price_i64 * 10^(-expo_i64) è½¬æ¢ä¸º 6 decimals
    let final_price = adjust_decimals(price_i64, expo_i64, 6);
    let final_confidence = adjust_decimals(confidence, expo_i64, 6);
    
    (final_price, final_confidence)
}
```

#### 2.3.2 æ›´æ–°ä»·æ ¼

```move
/// æ›´æ–°ä»·æ ¼ Feed
public entry fun update_btc_price(
    user: &signer,
    vaa: vector<u8>  // Verified Action Approval
) {
    // VAA åŒ…å«ç­¾åçš„ä»·æ ¼æ•°æ®
    // Pyth åˆçº¦ä¼šéªŒè¯ç­¾å
    pyth::update_price_feeds(vector[vaa]);
    
    // å‘å‡ºæ›´æ–°äº‹ä»¶
    event::emit(PriceUpdatedEvent {
        feed_id: x"e62df6...",
        timestamp: timestamp::now_seconds(),
    });
}
```

### 2.4 Pyth çš„ä¼˜åŠ¿

1. **é«˜é¢‘æ›´æ–°**
   - äºšç§’çº§å»¶è¿Ÿ
   - æŒç»­çš„ä»·æ ¼æµ

2. **é«˜è´¨é‡æ•°æ®æº**
   - 80+ ä¸€æµäº¤æ˜“æ‰€
   - é¡¶çº§åšå¸‚å•†
   - æœºæ„çº§æ•°æ®

3. **ç½®ä¿¡åŒºé—´**
   - é‡åŒ–ä¸ç¡®å®šæ€§
   - é£é™©ç®¡ç†å·¥å…·
   - å¼‚å¸¸æ£€æµ‹

4. **è·¨é“¾æ”¯æŒ**
   - é€šè¿‡ Wormhole
   - å¤šé“¾ä¸€è‡´æ€§
   - ç»Ÿä¸€æ¥å£

5. **æˆæœ¬æ•ˆç›Š**
   - æŒ‰éœ€æ›´æ–°
   - æ‰¹é‡æ›´æ–°å¤šä¸ª Feed
   - Gas ä¼˜åŒ–

---

## 3. Switchboard åŸç†

### 3.1 Switchboard æ¶æ„

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  æ•°æ®æºé…ç½®å±‚                            â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”           â”‚
â”‚  â”‚  Aggregator Configuration                â”‚           â”‚
â”‚  â”‚  - å®šä¹‰æ•°æ®æºï¼ˆAPI endpointsï¼‰            â”‚           â”‚
â”‚  â”‚  - è®¾ç½®èšåˆç­–ç•¥ï¼ˆä¸­ä½æ•°/å¹³å‡å€¼ï¼‰          â”‚           â”‚
â”‚  â”‚  - é…ç½®æ›´æ–°æ¡ä»¶ï¼ˆåå·®/å¿ƒè·³ï¼‰              â”‚           â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                         â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   Oracle èŠ‚ç‚¹å±‚                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”     â”‚
â”‚  â”‚Oracleâ”‚  â”‚Oracleâ”‚  â”‚Oracleâ”‚  â”‚Oracleâ”‚  â”‚Oracleâ”‚     â”‚
â”‚  â”‚ #1   â”‚  â”‚ #2   â”‚  â”‚ #3   â”‚  â”‚ #4   â”‚  â”‚ #5   â”‚     â”‚
â”‚  â””â”€â”€â”€â”¬â”€â”€â”˜  â””â”€â”€â”€â”¬â”€â”€â”˜  â””â”€â”€â”€â”¬â”€â”€â”˜  â””â”€â”€â”€â”¬â”€â”€â”˜  â””â”€â”€â”€â”¬â”€â”€â”˜     â”‚
â”‚      â”‚         â”‚         â”‚         â”‚         â”‚         â”‚
â”‚      â”‚ è·å–æ•°æ® â”‚         â”‚         â”‚         â”‚         â”‚
â”‚      â–¼         â–¼         â–¼         â–¼         â–¼         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚CoinGeckoâ”‚Binanceâ”‚ â”‚Coinbaseâ”‚ â”‚Krakenâ”‚ â”‚Customâ”‚   â”‚
â”‚  â”‚  API  â”‚  â”‚  API  â”‚ â”‚  API  â”‚ â”‚  API â”‚ â”‚ API  â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                         â”‚
                         â”‚ æäº¤æ•°æ®
                         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              Aptos é“¾ä¸Šèšåˆå™¨                            â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”           â”‚
â”‚  â”‚  Aggregator Contract                     â”‚           â”‚
â”‚  â”‚  - æ”¶é›† Oracle æäº¤çš„æ•°æ®                â”‚           â”‚
â”‚  â”‚  - æ‰§è¡Œèšåˆç®—æ³•                          â”‚           â”‚
â”‚  â”‚  - å­˜å‚¨æœ€ç»ˆç»“æœ                          â”‚           â”‚
â”‚  â”‚  - æä¾›æŸ¥è¯¢æ¥å£                          â”‚           â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 3.2 Switchboard èšåˆå™¨é…ç½®

```move
module switchboard {
    /// èšåˆå™¨é…ç½®
    struct AggregatorConfig has store {
        /// æœ€å° Oracle å“åº”æ•°
        min_oracle_results: u64,
        
        /// æœ€å¤§ Oracle å“åº”æ•°
        max_oracle_results: u64,
        
        /// æœ€å°æ›´æ–°å»¶è¿Ÿï¼ˆç§’ï¼‰
        min_update_delay: u64,
        
        /// å¿ƒè·³é—´éš”ï¼ˆç§’ï¼‰
        /// å³ä½¿ä»·æ ¼ä¸å˜ä¹Ÿè¦æ›´æ–°
        heartbeat_interval: u64,
        
        /// åå·®é˜ˆå€¼ï¼ˆbasis pointsï¼‰
        /// ä»·æ ¼å˜åŒ–è¶…è¿‡æ­¤å€¼æ—¶è§¦å‘æ›´æ–°
        deviation_threshold: u64,
        
        /// èšåˆæ–¹æ³•
        aggregation_method: u8,  // 0=ä¸­ä½æ•°, 1=å¹³å‡å€¼, 2=åŠ æƒå¹³å‡
    }
    
    /// èšåˆå™¨æ•°æ®
    struct Aggregator has key {
        /// é…ç½®
        config: AggregatorConfig,
        
        /// å½“å‰å€¼
        current_value: u128,
        
        /// æœ€åæ›´æ–°æ—¶é—´
        last_update_timestamp: u64,
        
        /// Oracle åœ°å€åˆ—è¡¨
        oracles: vector<address>,
        
        /// æ•°æ®æºé…ç½®
        jobs: vector<Job>,
    }
    
    /// æ•°æ®æºï¼ˆJobï¼‰
    struct Job has store {
        /// API URL
        url: vector<u8>,
        
        /// JSON è·¯å¾„
        json_path: vector<u8>,
        
        /// æƒé‡
        weight: u64,
    }
}
```

### 3.3 ä½¿ç”¨ Switchboard

#### 3.3.1 è¯»å–èšåˆå™¨å€¼

```move
use switchboard::aggregator;

/// è·å– BTC/USD ä»·æ ¼
public fun get_btc_price_from_switchboard(): (u128, u64) {
    // Switchboard BTC/USD Aggregator åœ°å€
    let aggregator_addr = @0x123...;
    
    // è¯»å–èšåˆå™¨å€¼
    let value = aggregator::get_value(aggregator_addr);
    let timestamp = aggregator::get_timestamp(aggregator_addr);
    
    // æ£€æŸ¥æ–°é²œåº¦
    let current_time = timestamp::now_seconds();
    assert!(current_time - timestamp < 300, ERROR_STALE_PRICE);
    
    // æ£€æŸ¥èšåˆå™¨çŠ¶æ€
    assert!(aggregator::is_active(aggregator_addr), ERROR_AGGREGATOR_INACTIVE);
    
    (value, timestamp)
}
```

#### 3.3.2 è§¦å‘æ›´æ–°

```move
/// è§¦å‘èšåˆå™¨æ›´æ–°
public entry fun update_aggregator(
    user: &signer,
    aggregator_addr: address
) {
    // æ£€æŸ¥æ˜¯å¦æ»¡è¶³æ›´æ–°æ¡ä»¶
    let should_update = aggregator::should_update(aggregator_addr);
    assert!(should_update, ERROR_UPDATE_NOT_NEEDED);
    
    // è§¦å‘æ›´æ–°ï¼ˆOracle èŠ‚ç‚¹ä¼šå“åº”ï¼‰
    aggregator::request_update(aggregator_addr);
}
```

### 3.4 Switchboard çš„ä¼˜åŠ¿

1. **é«˜åº¦å¯å®šåˆ¶**
   - è‡ªå®šä¹‰æ•°æ®æº
   - çµæ´»çš„èšåˆç­–ç•¥
   - å¯é…ç½®æ›´æ–°æ¡ä»¶

2. **å»ä¸­å¿ƒåŒ–**
   - å¤šä¸ªç‹¬ç«‹ Oracle èŠ‚ç‚¹
   - æ— å•ç‚¹æ•…éšœ
   - æŠ—å®¡æŸ¥

3. **æˆæœ¬å¯æ§**
   - æŒ‰éœ€æ›´æ–°
   - å¯è®¾ç½®å¿ƒè·³é—´éš”
   - é˜ˆå€¼è§¦å‘æ›´æ–°

4. **å¹¿æ³›æ”¯æŒ**
   - ä¸ä»…æ˜¯ä»·æ ¼æ•°æ®
   - æ”¯æŒä»»æ„ API æ•°æ®
   - é“¾ä¸‹è®¡ç®—ç»“æœ

---

## 4. ä»·æ ¼èšåˆç­–ç•¥

### 4.1 ä¸ºä»€ä¹ˆéœ€è¦èšåˆï¼Ÿ

```
å•ä¸€é¢„è¨€æœºçš„é£é™©ï¼š
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  é£é™©ç±»å‹          â”‚  å½±å“              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  é¢„è¨€æœºå¤±è´¥        â”‚  æ— æ³•è·å–ä»·æ ¼       â”‚
â”‚  æ¶æ„æ•°æ®          â”‚  é”™è¯¯çš„æ¸…ç®—/äº¤æ˜“    â”‚
â”‚  ä»·æ ¼å»¶è¿Ÿ          â”‚  å¥—åˆ©æœºä¼š/æŸå¤±      â”‚
â”‚  æ“çºµæ”»å‡»          â”‚  åè®®è¢«ç›—å–èµ„é‡‘     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

å¤šæºèšåˆçš„å¥½å¤„ï¼š
âœ… æé«˜å¯é æ€§
âœ… æ£€æµ‹å¼‚å¸¸å€¼
âœ… æŠ—å•ç‚¹æ•…éšœ
âœ… å¢å¼ºå®‰å…¨æ€§
```

### 4.2 èšåˆç®—æ³•

#### 4.2.1 ä¸­ä½æ•°ï¼ˆMedianï¼‰

```move
/// ä¸­ä½æ•°èšåˆï¼ˆæœ€æ¨èç”¨äºä»·æ ¼ï¼‰
public fun aggregate_median(prices: vector<u64>): u64 {
    let len = vector::length(&prices);
    assert!(len > 0, ERROR_EMPTY_PRICES);
    
    // æ’åº
    sort_ascending(&mut prices);
    
    // è®¡ç®—ä¸­ä½æ•°
    if (len % 2 == 1) {
        // å¥‡æ•°ä¸ªï¼šå–ä¸­é—´å€¼
        *vector::borrow(&prices, len / 2)
    } else {
        // å¶æ•°ä¸ªï¼šå–ä¸­é—´ä¸¤ä¸ªçš„å¹³å‡å€¼
        let mid1 = *vector::borrow(&prices, len / 2 - 1);
        let mid2 = *vector::borrow(&prices, len / 2);
        (mid1 + mid2) / 2
    }
}

// ç¤ºä¾‹ï¼š
// prices = [100, 105, 102, 1000, 103]  // æ³¨æ„ 1000 æ˜¯å¼‚å¸¸å€¼
// æ’åºå = [100, 102, 103, 105, 1000]
// ä¸­ä½æ•° = 103  // å¼‚å¸¸å€¼è¢«è‡ªåŠ¨è¿‡æ»¤ï¼
```

**ä¼˜ç‚¹**ï¼š
- âœ… æŠ—å¼‚å¸¸å€¼
- âœ… ä¸å—æç«¯å€¼å½±å“
- âœ… é€‚åˆå®‰å…¨å…³é”®åœºæ™¯

**ç¼ºç‚¹**ï¼š
- âŒ éœ€è¦æ’åºï¼ˆGas è¾ƒé«˜ï¼‰
- âŒ ä¸¢å¤±éƒ¨åˆ†ä¿¡æ¯

#### 4.2.2 å¹³å‡å€¼ï¼ˆMeanï¼‰

```move
/// ç®—æœ¯å¹³å‡å€¼
public fun aggregate_mean(prices: vector<u64>): u64 {
    let len = vector::length(&prices);
    assert!(len > 0, ERROR_EMPTY_PRICES);
    
    let sum = 0u128;
    let i = 0;
    while (i < len) {
        sum = sum + (*vector::borrow(&prices, i) as u128);
        i = i + 1;
    };
    
    ((sum / (len as u128)) as u64)
}

// ç¤ºä¾‹ï¼š
// prices = [100, 105, 102, 1000, 103]
// å¹³å‡å€¼ = (100 + 105 + 102 + 1000 + 103) / 5 = 282
// âš ï¸ è¢«å¼‚å¸¸å€¼ 1000 ä¸¥é‡å½±å“ï¼
```

**ä¼˜ç‚¹**ï¼š
- âœ… å®ç°ç®€å•
- âœ… Gas æ¶ˆè€—ä½
- âœ… åˆ©ç”¨æ‰€æœ‰æ•°æ®

**ç¼ºç‚¹**ï¼š
- âŒ æ˜“å—å¼‚å¸¸å€¼å½±å“
- âŒ ä¸é€‚åˆæœ‰æ“çºµé£é™©çš„åœºæ™¯

#### 4.2.3 åŠ æƒå¹³å‡ï¼ˆWeighted Averageï¼‰

```move
/// åŠ æƒå¹³å‡ï¼ˆæ ¹æ®æ•°æ®æºå¯ä¿¡åº¦ï¼‰
public fun aggregate_weighted_average(
    prices: vector<u64>,
    weights: vector<u64>
): u64 {
    let len = vector::length(&prices);
    assert!(len == vector::length(&weights), ERROR_LENGTH_MISMATCH);
    assert!(len > 0, ERROR_EMPTY_PRICES);
    
    let weighted_sum = 0u128;
    let weight_sum = 0u128;
    
    let i = 0;
    while (i < len) {
        let price = *vector::borrow(&prices, i);
        let weight = *vector::borrow(&weights, i);
        weighted_sum = weighted_sum + (price as u128) * (weight as u128);
        weight_sum = weight_sum + (weight as u128);
        i = i + 1;
    };
    
    ((weighted_sum / weight_sum) as u64)
}

// ç¤ºä¾‹ï¼š
// prices =  [100,  105,  102]
// weights = [50,   30,   20]  // Pyth æƒé‡æ›´é«˜
// åŠ æƒå¹³å‡ = (100*50 + 105*30 + 102*20) / (50+30+20)
//         = (5000 + 3150 + 2040) / 100
//         = 101.9
```

**ä¼˜ç‚¹**ï¼š
- âœ… è€ƒè™‘æ•°æ®æºè´¨é‡
- âœ… çµæ´»å¯é…ç½®
- âœ… ç²¾ç¡®åº¦é«˜

**ç¼ºç‚¹**ï¼š
- âŒ éœ€è¦ç»´æŠ¤æƒé‡
- âŒ ä»å—å¼‚å¸¸å€¼å½±å“
- âŒ å®ç°å¤æ‚

#### 4.2.4 æ—¶é—´åŠ æƒå¹³å‡ä»·æ ¼ï¼ˆTWAPï¼‰

```move
/// TWAP å®ç°ï¼ˆé˜²é—ªç”µè´·æ”»å‡»ï¼‰
struct TWAPOracle has key {
    /// ç´¯ç§¯ä»·æ ¼
    cumulative_price: u128,
    
    /// ä¸Šæ¬¡æ›´æ–°æ—¶é—´
    last_update_timestamp: u64,
    
    /// ä¸Šæ¬¡ä»·æ ¼
    last_price: u64,
}

/// æ›´æ–° TWAP
public fun update_twap(
    oracle: &mut TWAPOracle,
    new_price: u64
) {
    let current_time = timestamp::now_seconds();
    let time_elapsed = current_time - oracle.last_update_timestamp;
    
    // ç´¯ç§¯ä»·æ ¼ += ä¸Šæ¬¡ä»·æ ¼ * æ—¶é—´é—´éš”
    oracle.cumulative_price = oracle.cumulative_price + 
        (oracle.last_price as u128) * (time_elapsed as u128);
    
    oracle.last_update_timestamp = current_time;
    oracle.last_price = new_price;
}

/// è·å– TWAPï¼ˆè¿‡å» N ç§’ï¼‰
public fun get_twap(
    oracle: &TWAPOracle,
    period: u64  // ä¾‹å¦‚ 3600 ç§’ = 1 å°æ—¶
): u64 {
    let current_time = timestamp::now_seconds();
    let start_time = current_time - period;
    
    // ç®€åŒ–ç‰ˆï¼šå®é™…éœ€è¦å­˜å‚¨å†å²ç´¯ç§¯ä»·æ ¼
    // TWAP = (ç´¯ç§¯ä»·æ ¼å˜åŒ–) / æ—¶é—´é—´éš”
    // è¿™é‡Œå‡è®¾å·²æœ‰å†å²æ•°æ®
    
    // è¿”å›å¹³å‡ä»·æ ¼
    oracle.last_price  // å®é™…å®ç°æ›´å¤æ‚
}
```

**ä¼˜ç‚¹**ï¼š
- âœ… æŠ—é—ªç”µè´·æ”»å‡»
- âœ… å¹³æ»‘ä»·æ ¼æ³¢åŠ¨
- âœ… é€‚åˆæ¸…ç®—åœºæ™¯

**ç¼ºç‚¹**ï¼š
- âŒ ä»·æ ¼æ»å
- âŒ å­˜å‚¨æˆæœ¬é«˜
- âŒ å®ç°å¤æ‚

### 4.3 å¼‚å¸¸å€¼æ£€æµ‹

```move
/// æ£€æµ‹å¹¶ç§»é™¤å¼‚å¸¸å€¼ï¼ˆåŸºäºæ ‡å‡†å·®ï¼‰
public fun filter_outliers(
    prices: vector<u64>,
    std_dev_threshold: u64  // ä¾‹å¦‚ 2 è¡¨ç¤º 2 ä¸ªæ ‡å‡†å·®
): vector<u64> {
    let len = vector::length(&prices);
    if (len < 3) {
        return prices  // æ•°æ®å¤ªå°‘ï¼Œä¸è¿‡æ»¤
    };
    
    // 1. è®¡ç®—å¹³å‡å€¼
    let mean = aggregate_mean(&prices);
    
    // 2. è®¡ç®—æ ‡å‡†å·®
    let variance_sum = 0u128;
    let i = 0;
    while (i < len) {
        let price = *vector::borrow(&prices, i);
        let diff = if (price > mean) {
            price - mean
        } else {
            mean - price
        };
        variance_sum = variance_sum + (diff as u128) * (diff as u128);
        i = i + 1;
    };
    let variance = variance_sum / (len as u128);
    let std_dev = sqrt(variance);  // éœ€è¦å®ç°å¹³æ–¹æ ¹
    
    // 3. è¿‡æ»¤è¶…è¿‡é˜ˆå€¼çš„å€¼
    let filtered = vector::empty<u64>();
    i = 0;
    while (i < len) {
        let price = *vector::borrow(&prices, i);
        let diff = if (price > mean) {
            price - mean
        } else {
            mean - price
        };
        
        // ä¿ç•™åœ¨é˜ˆå€¼å†…çš„å€¼
        if ((diff as u128) <= (std_dev * (std_dev_threshold as u128))) {
            vector::push_back(&mut filtered, price);
        };
        i = i + 1;
    };
    
    filtered
}
```

### 4.4 å®é™…èšåˆå®ç°

```move
module price_aggregator {
    use std::vector;
    use pyth::pyth;
    use switchboard::aggregator;
    
    /// ä»·æ ¼æ¥æº
    struct PriceSource has store {
        source_type: u8,  // 0=Pyth, 1=Switchboard
        identifier: vector<u8>,
        weight: u64,
    }
    
    /// èšåˆå™¨é…ç½®
    struct AggregatorConfig has key {
        sources: vector<PriceSource>,
        aggregation_method: u8,  // 0=ä¸­ä½æ•°, 1=åŠ æƒå¹³å‡
        max_deviation: u64,  // æœ€å¤§åå·®ï¼ˆbasis pointsï¼‰
        min_sources: u64,  // æœ€å°‘æ•°æ®æºæ•°é‡
    }
    
    /// è·å–èšåˆä»·æ ¼
    public fun get_aggregated_price(
        asset: vector<u8>
    ): (u64, u64) acquires AggregatorConfig {
        let config = borrow_global<AggregatorConfig>(@aggregator);
        
        // 1. ä»æ‰€æœ‰æºè·å–ä»·æ ¼
        let prices = vector::empty<u64>();
        let weights = vector::empty<u64>();
        let timestamps = vector::empty<u64>();
        
        let i = 0;
        let sources = &config.sources;
        while (i < vector::length(sources)) {
            let source = vector::borrow(sources, i);
            
            let (price, timestamp) = if (source.source_type == 0) {
                // Pyth
                get_pyth_price(source.identifier)
            } else {
                // Switchboard
                get_switchboard_price(source.identifier)
            };
            
            vector::push_back(&mut prices, price);
            vector::push_back(&mut weights, source.weight);
            vector::push_back(&mut timestamps, timestamp);
            
            i = i + 1;
        };
        
        // 2. æ£€æŸ¥æœ€å°‘æºæ•°é‡
        assert!(
            vector::length(&prices) >= config.min_sources,
            ERROR_INSUFFICIENT_SOURCES
        );
        
        // 3. æ£€æŸ¥æ‰€æœ‰ä»·æ ¼æ–°é²œåº¦
        let oldest_timestamp = *vector::borrow(&timestamps, 0);
        i = 1;
        while (i < vector::length(&timestamps)) {
            let ts = *vector::borrow(&timestamps, i);
            if (ts < oldest_timestamp) {
                oldest_timestamp = ts;
            };
            i = i + 1;
        };
        
        let current_time = timestamp::now_seconds();
        assert!(
            current_time - oldest_timestamp < 300,
            ERROR_STALE_PRICE
        );
        
        // 4. æ£€æµ‹å¼‚å¸¸å€¼
        let filtered_prices = filter_outliers(prices, 2);
        
        // 5. èšåˆ
        let final_price = if (config.aggregation_method == 0) {
            aggregate_median(filtered_prices)
        } else {
            aggregate_weighted_average(filtered_prices, weights)
        };
        
        // 6. éªŒè¯ä»·æ ¼åå·®
        verify_price_deviation(&prices, final_price, config.max_deviation);
        
        (final_price, oldest_timestamp)
    }
    
    /// éªŒè¯ä»·æ ¼åå·®
    fun verify_price_deviation(
        prices: vector<u64>,
        final_price: u64,
        max_deviation_bp: u64
    ) {
        let i = 0;
        while (i < vector::length(prices)) {
            let price = *vector::borrow(prices, i);
            let deviation = if (price > final_price) {
                ((price - final_price) as u128) * 10000 / (final_price as u128)
            } else {
                ((final_price - price) as u128) * 10000 / (final_price as u128)
            };
            
            assert!(
                deviation <= (max_deviation_bp as u128),
                ERROR_PRICE_DEVIATION_TOO_HIGH
            );
            
            i = i + 1;
        };
    }
}
```

---

## 5. å®‰å…¨æœ€ä½³å®è·µ

### 5.1 é¢„è¨€æœºæ”»å‡»å‘é‡

#### 5.1.1 ä»·æ ¼æ“çºµæ”»å‡»

```
æ”»å‡»åœºæ™¯ï¼š
1. æ”»å‡»è€…åœ¨ DEX ä¸Šå¤§é‡ä¹°å…¥ä»£å¸ A
2. ä»£å¸ A ä»·æ ¼æš´æ¶¨
3. é¢„è¨€æœºè¯»å–è¢«æ“çºµçš„ä»·æ ¼
4. æ”»å‡»è€…åœ¨å€Ÿè´·åè®®ä¸­ç”¨é«˜ä»·æŠµæŠ¼
5. æ”»å‡»è€…å€Ÿå‡ºå¤§é‡èµ„é‡‘
6. æ”»å‡»è€…å–å‡ºä»£å¸ Aï¼Œä»·æ ¼å´©ç›˜
7. å€Ÿè´·åè®®é­å—æŸå¤±
```

**é˜²æŠ¤æªæ–½**ï¼š

```move
/// ä½¿ç”¨ TWAP è€Œéå³æ—¶ä»·æ ¼
public fun get_safe_price_for_collateral(
    asset: vector<u8>
): u64 {
    // âŒ ä¸è¦ä½¿ç”¨å³æ—¶ä»·æ ¼
    // let price = get_spot_price(asset);
    
    // âœ… ä½¿ç”¨ TWAPï¼ˆå¦‚ 1 å°æ—¶å¹³å‡ï¼‰
    let twap_price = get_twap_price(asset, 3600);
    
    // âœ… é¢å¤–æ£€æŸ¥ï¼šå³æ—¶ä»·æ ¼ä¸åº”åç¦» TWAP å¤ªå¤š
    let spot_price = get_spot_price(asset);
    let deviation = calculate_deviation(spot_price, twap_price);
    assert!(deviation < 1000, ERROR_PRICE_MANIPULATION);  // < 10%
    
    twap_price
}
```

#### 5.1.2 é¢„è¨€æœºå‰ç½®äº¤æ˜“

```
æ”»å‡»åœºæ™¯ï¼š
1. æ”»å‡»è€…ç›‘æ§é¢„è¨€æœºæ›´æ–°äº¤æ˜“
2. æ”»å‡»è€…æŠ¢å…ˆæäº¤äº¤æ˜“
3. åœ¨æ–°ä»·æ ¼ç”Ÿæ•ˆå‰è·åˆ©
```

**é˜²æŠ¤æªæ–½**ï¼š

```move
/// ä»·æ ¼æ›´æ–°å†·å´æœŸ
struct PriceOracle has key {
    pending_price: u64,
    pending_timestamp: u64,
    active_price: u64,
    activation_delay: u64,  // ä¾‹å¦‚ 60 ç§’
}

public entry fun submit_price_update(
    oracle: &signer,
    new_price: u64
) acquires PriceOracle {
    let oracle_data = borrow_global_mut<PriceOracle>(@oracle);
    
    // æ–°ä»·æ ¼è¿›å…¥å¾…å®šçŠ¶æ€
    oracle_data.pending_price = new_price;
    oracle_data.pending_timestamp = timestamp::now_seconds();
}

public entry fun activate_price_update() acquires PriceOracle {
    let oracle_data = borrow_global_mut<PriceOracle>(@oracle);
    let current_time = timestamp::now_seconds();
    
    // æ£€æŸ¥æ˜¯å¦è¿‡äº†æ¿€æ´»å»¶è¿Ÿ
    assert!(
        current_time - oracle_data.pending_timestamp >= oracle_data.activation_delay,
        ERROR_ACTIVATION_DELAY_NOT_MET
    );
    
    // æ¿€æ´»æ–°ä»·æ ¼
    oracle_data.active_price = oracle_data.pending_price;
}
```

#### 5.1.3 é—ªç”µè´·æ”»å‡»

```
æ”»å‡»åœºæ™¯ï¼š
1. æ”»å‡»è€…å€Ÿé—ªç”µè´·
2. æ“çºµ DEX ä»·æ ¼
3. é¢„è¨€æœºè¯»å–è¢«æ“çºµçš„ä»·æ ¼
4. åœ¨å…¶ä»–åè®®ä¸­è·åˆ©
5. è¿˜é—ªç”µè´·
```

**é˜²æŠ¤æªæ–½**ï¼š

```move
/// ç¦æ­¢åœ¨åŒä¸€äº¤æ˜“ä¸­ä½¿ç”¨æ–°ä»·æ ¼
struct PriceUsageTracker has key {
    last_price_update_block: u64,
    last_usage_block: u64,
}

public fun get_price_for_critical_operation(
    asset: vector<u8>
): u64 acquires PriceUsageTracker {
    let tracker = borrow_global_mut<PriceUsageTracker>(@tracker);
    let current_block = block::get_current_block_height();
    
    // ç¡®ä¿ä»·æ ¼æ›´æ–°å’Œä½¿ç”¨ä¸åœ¨åŒä¸€åŒºå—
    assert!(
        current_block > tracker.last_price_update_block,
        ERROR_SAME_BLOCK_USAGE
    );
    
    tracker.last_usage_block = current_block;
    
    get_current_price(asset)
}
```

### 5.2 å®‰å…¨æ£€æŸ¥æ¸…å•

```move
/// å®Œæ•´çš„é¢„è¨€æœºå®‰å…¨æ£€æŸ¥
public fun safe_get_price(
    asset: vector<u8>,
    use_case: u8  // 0=å±•ç¤º, 1=äº¤æ˜“, 2=æ¸…ç®—
): u64 {
    // 1. è·å–å¤šæºä»·æ ¼
    let pyth_price = pyth::get_price(get_pyth_feed_id(asset));
    let sb_price = switchboard::get_price(get_sb_feed_id(asset));
    
    // 2. æ£€æŸ¥æ–°é²œåº¦
    assert!(is_price_fresh(pyth_price), ERROR_STALE_PYTH);
    assert!(is_price_fresh(sb_price), ERROR_STALE_SWITCHBOARD);
    
    // 3. æ£€æŸ¥ä»·æ ¼åå·®
    let deviation = calculate_deviation(pyth_price, sb_price);
    assert!(deviation < 500, ERROR_PRICE_DEVIATION);  // < 5%
    
    // 4. èšåˆä»·æ ¼
    let aggregated_price = (pyth_price + sb_price) / 2;
    
    // 5. æ£€æŸ¥ç½®ä¿¡åº¦ï¼ˆå¦‚æœæ˜¯å…³é”®æ“ä½œï¼‰
    if (use_case == 2) {  // æ¸…ç®—
        let confidence = pyth::get_confidence(get_pyth_feed_id(asset));
        assert!(
            confidence < aggregated_price / 200,  // < 0.5%
            ERROR_LOW_CONFIDENCE
        );
    };
    
    // 6. æ£€æŸ¥ä»·æ ¼åˆç†æ€§
    assert!(aggregated_price > 0, ERROR_INVALID_PRICE);
    assert!(aggregated_price < MAX_REASONABLE_PRICE, ERROR_PRICE_TOO_HIGH);
    
    // 7. æ–­è·¯å™¨æ£€æŸ¥
    check_circuit_breaker(asset, aggregated_price);
    
    aggregated_price
}

/// æ–­è·¯å™¨ï¼ˆä»·æ ¼å‰§çƒˆå˜åŒ–æ—¶æš‚åœï¼‰
fun check_circuit_breaker(
    asset: vector<u8>,
    new_price: u64
) {
    let last_price = get_last_validated_price(asset);
    
    let change_ratio = if (new_price > last_price) {
        ((new_price - last_price) as u128) * 10000 / (last_price as u128)
    } else {
        ((last_price - new_price) as u128) * 10000 / (last_price as u128)
    };
    
    // å•æ¬¡æ›´æ–°ä»·æ ¼å˜åŒ–ä¸åº”è¶…è¿‡ 20%
    assert!(change_ratio < 2000, ERROR_CIRCUIT_BREAKER_TRIGGERED);
}
```

---

## 6. å®é™…åº”ç”¨åœºæ™¯

### 6.1 åœ¨ DEX ä¸­ä½¿ç”¨é¢„è¨€æœº

```move
module dex_with_oracle {
    use price_aggregator;
    
    /// è·å–äº¤æ˜“å¯¹çš„ç¾å…ƒä»·å€¼
    public fun get_pool_tvl<X, Y>(): u64 {
        let (reserve_x, reserve_y) = pool::get_reserves<X, Y>();
        
        // è·å–ä»·æ ¼ï¼ˆUSDï¼Œ6 decimalsï¼‰
        let price_x = price_aggregator::get_aggregated_price(type_name<X>());
        let price_y = price_aggregator::get_aggregated_price(type_name<Y>());
        
        // è®¡ç®—æ€»ä»·å€¼
        let value_x = (reserve_x as u128) * (price_x as u128) / 1_000_000;
        let value_y = (reserve_y as u128) * (price_y as u128) / 1_000_000;
        
        ((value_x + value_y) as u64)
    }
    
    /// æ˜¾ç¤ºå®æ—¶æ±‡ç‡
    #[view]
    public fun get_exchange_rate_in_usd<X, Y>(): u64 {
        let price_x = price_aggregator::get_aggregated_price(type_name<X>());
        let price_y = price_aggregator::get_aggregated_price(type_name<Y>());
        
        // X/Y æ±‡ç‡
        (price_x as u128) * 1_000_000 / (price_y as u128) as u64
    }
}
```

### 6.2 åœ¨å€Ÿè´·åè®®ä¸­ä½¿ç”¨é¢„è¨€æœº

```move
module lending_with_oracle {
    use price_aggregator;
    
    /// è®¡ç®—æŠµæŠ¼å“ä»·å€¼
    public fun calculate_collateral_value(
        user: address
    ): u64 {
        let deposits = get_user_deposits(user);
        let total_value = 0u128;
        
        let i = 0;
        while (i < vector::length(&deposits)) {
            let deposit = vector::borrow(&deposits, i);
            
            // ä½¿ç”¨ TWAP é˜²æ­¢æ“çºµ
            let price = price_aggregator::get_twap_price(
                deposit.asset,
                3600  // 1 å°æ—¶ TWAP
            );
            
            let value = (deposit.amount as u128) * (price as u128);
            total_value = total_value + value;
            
            i = i + 1;
        };
        
        (total_value / 1_000_000 as u64)
    }
    
    /// æ£€æŸ¥æ˜¯å¦éœ€è¦æ¸…ç®—
    public fun should_liquidate(user: address): bool {
        let collateral_value = calculate_collateral_value(user);
        let debt_value = calculate_debt_value(user);
        
        // å¥åº·å› å­ = æŠµæŠ¼å“ä»·å€¼ / å€ºåŠ¡ä»·å€¼
        let health_factor = (collateral_value as u128) * 10000 / (debt_value as u128);
        
        // å¥åº·å› å­ < 1.2 æ—¶è§¦å‘æ¸…ç®—
        health_factor < 12000
    }
}
```

### 6.3 åœ¨æœŸæƒåè®®ä¸­ä½¿ç”¨é¢„è¨€æœº

```move
module option_with_oracle {
    use price_aggregator;
    
    /// æœŸæƒåˆçº¦
    struct Option has key {
        strike_price: u64,      // è¡Œæƒä»·
        expiry: u64,            // åˆ°æœŸæ—¶é—´
        is_call: bool,          // true=çœ‹æ¶¨, false=çœ‹è·Œ
        asset: vector<u8>,      // æ ‡çš„èµ„äº§
    }
    
    /// è®¡ç®—æœŸæƒä»·å€¼ï¼ˆç®€åŒ–ç‰ˆï¼‰
    public fun calculate_option_value(
        option_addr: address
    ): u64 acquires Option {
        let option = borrow_global<Option>(option_addr);
        
        // è·å–å½“å‰å¸‚åœºä»·æ ¼
        let current_price = price_aggregator::get_aggregated_price(option.asset);
        
        if (option.is_call) {
            // çœ‹æ¶¨æœŸæƒï¼šmax(0, ç°ä»· - è¡Œæƒä»·)
            if (current_price > option.strike_price) {
                current_price - option.strike_price
            } else {
                0
            }
        } else {
            // çœ‹è·ŒæœŸæƒï¼šmax(0, è¡Œæƒä»· - ç°ä»·)
            if (option.strike_price > current_price) {
                option.strike_price - current_price
            } else {
                0
            }
        }
    }
}
```

---

## ğŸ“š æ€»ç»“

### å…³é”®è¦ç‚¹

1. **é¢„è¨€æœºæ˜¯ DeFi çš„å…³é”®åŸºç¡€è®¾æ–½**
   - è¿æ¥é“¾ä¸Šå’Œé“¾ä¸‹ä¸–ç•Œ
   - æä¾›å¯ä¿¡çš„ä»·æ ¼æ•°æ®
   - æ”¯æ’‘å€Ÿè´·ã€DEXã€è¡ç”Ÿå“ç­‰åè®®

2. **ä¸»æµé¢„è¨€æœºæ–¹æ¡ˆ**
   - **Pyth**: é«˜é¢‘æ›´æ–°ï¼Œæœºæ„çº§æ•°æ®
   - **Switchboard**: é«˜åº¦å¯å®šåˆ¶ï¼Œå»ä¸­å¿ƒåŒ–

3. **ä»·æ ¼èšåˆè‡³å…³é‡è¦**
   - æé«˜å¯é æ€§
   - æ£€æµ‹å¼‚å¸¸å€¼
   - é˜²èŒƒæ“çºµæ”»å‡»

4. **å®‰å…¨æ€§æ°¸è¿œæ˜¯ç¬¬ä¸€ä½çš„**
   - å¤šæºéªŒè¯
   - æ–°é²œåº¦æ£€æŸ¥
   - TWAP é˜²é—ªç”µè´·
   - æ–­è·¯å™¨æœºåˆ¶

### ä¸‹ä¸€æ­¥

- å®è·µé›†æˆ Pyth å’Œ Switchboard
- å®ç°ä»·æ ¼èšåˆå™¨
- åœ¨å®é™…é¡¹ç›®ä¸­åº”ç”¨é¢„è¨€æœº
- å­¦ä¹ æ›´å¤šå®‰å…¨æœ€ä½³å®è·µ

---

**è®°ä½**ï¼šé¢„è¨€æœºçš„å¯é æ€§ç›´æ¥å†³å®šäº† DeFi åè®®çš„å®‰å…¨æ€§ã€‚æ°¸è¿œä¸è¦åœ¨ç”Ÿäº§ç¯å¢ƒä¸­ä¾èµ–å•ä¸€æ•°æ®æºï¼

**ç‰ˆæƒå£°æ˜**: æœ¬æ–‡æ¡£ä»…ä¾›å­¦ä¹ ä½¿ç”¨ã€‚

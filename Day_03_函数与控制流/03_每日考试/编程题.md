# Day 03 æ¯æ—¥è€ƒè¯• - ç¼–ç¨‹é¢˜

**æ€»åˆ†ï¼š50 åˆ†**  
**æ—¶é—´ï¼š40 åˆ†é’Ÿ**

---

## ç¼–ç¨‹é¢˜ 1ï¼šé€’å½’å‡½æ•°å®ç°ï¼ˆ15 åˆ†ï¼‰

### é¢˜ç›®æè¿°

è™½ç„¶Moveæ¨èä½¿ç”¨å¾ªç¯è€Œéé€’å½’ï¼ˆå› ä¸ºåŒºå—é“¾ç¯å¢ƒçš„gasé™åˆ¶ï¼‰ï¼Œä½†ç†è§£é€’å½’æ€æƒ³å¾ˆé‡è¦ã€‚å®ç°ä»¥ä¸‹é€’å½’å‡½æ•°ã€‚

### è¦æ±‚å®ç°çš„å‡½æ•°

```move
module my_addr::recursion {
    
    const E_OVERFLOW: u64 = 1;
    const E_INVALID_INPUT: u64 = 2;

    /// é€’å½’è®¡ç®—é˜¶ä¹˜
    /// n! = n * (n-1) * ... * 1
    /// 0! = 1
    public fun factorial(n: u64): u64 {
        // TODO: ä½¿ç”¨é€’å½’å®ç°
        // æç¤ºï¼šåŸºç¡€æƒ…å†µ n == 0 æˆ– n == 1
        0
    }

    /// é€’å½’è®¡ç®—æ–æ³¢é‚£å¥‘æ•°åˆ—
    /// fib(0) = 0, fib(1) = 1
    /// fib(n) = fib(n-1) + fib(n-2)
    public fun fibonacci(n: u64): u64 {
        // TODO: ä½¿ç”¨é€’å½’å®ç°
        0
    }

    /// é€’å½’è®¡ç®—ä¸¤ä¸ªæ•°çš„æœ€å¤§å…¬çº¦æ•°
    /// ä½¿ç”¨æ¬§å‡ é‡Œå¾—ç®—æ³•
    public fun gcd(a: u64, b: u64): u64 {
        // TODO: é€’å½’å®ç°
        // æç¤ºï¼šgcd(a, 0) = a
        //       gcd(a, b) = gcd(b, a % b)
        0
    }

    /// é€’å½’è®¡ç®—å¹‚è¿ç®—
    /// power(base, 0) = 1
    /// power(base, exp) = base * power(base, exp-1)
    public fun power(base: u64, exp: u64): u64 {
        // TODO: ä½¿ç”¨é€’å½’å®ç°
        0
    }

    /// é€’å½’æ±‚æ•°ç»„å…ƒç´ ä¹‹å’Œ
    /// ä½¿ç”¨å‘é‡ç´¢å¼•é€’å½’
    public fun sum_vector_recursive(vec: &vector<u64>, index: u64): u64 {
        use std::vector;
        
        // TODO: é€’å½’å®ç°
        // æç¤ºï¼šåŸºç¡€æƒ…å†µ index >= length
        0
    }

    // ============================================
    // æµ‹è¯•ç”¨ä¾‹
    // ============================================

    #[test]
    fun test_factorial() {
        assert!(factorial(0) == 1, 0);
        assert!(factorial(1) == 1, 1);
        assert!(factorial(5) == 120, 2);
        assert!(factorial(10) == 3628800, 3);
    }

    #[test]
    fun test_fibonacci() {
        assert!(fibonacci(0) == 0, 0);
        assert!(fibonacci(1) == 1, 1);
        assert!(fibonacci(10) == 55, 2);
    }

    #[test]
    fun test_gcd() {
        assert!(gcd(48, 18) == 6, 0);
        assert!(gcd(100, 50) == 50, 1);
    }

    #[test]
    fun test_power() {
        assert!(power(2, 0) == 1, 0);
        assert!(power(2, 10) == 1024, 1);
        assert!(power(5, 3) == 125, 2);
    }
}
```

### è¯„åˆ†æ ‡å‡†

- factorial æ­£ç¡®ï¼ˆ3åˆ†ï¼‰
- fibonacci æ­£ç¡®ï¼ˆ3åˆ†ï¼‰
- gcd æ­£ç¡®ï¼ˆ3åˆ†ï¼‰
- power æ­£ç¡®ï¼ˆ3åˆ†ï¼‰
- sum_vector_recursive æ­£ç¡®ï¼ˆ3åˆ†ï¼‰

---

## ç¼–ç¨‹é¢˜ 2ï¼šæ§åˆ¶æµç»¼åˆåº”ç”¨ï¼ˆ20 åˆ†ï¼‰

### é¢˜ç›®æè¿°

å®ç°ä¸€ä¸ªå®Œæ•´çš„æ•°å­—æ¸¸æˆç³»ç»Ÿï¼ŒåŒ…å«å„ç§æ§åˆ¶æµæ¨¡å¼ã€‚

### è¦æ±‚å®ç°çš„å‡½æ•°

```move
module my_addr::number_game {
    use std::vector;

    const E_EMPTY_RANGE: u64 = 1;
    const E_INVALID_INPUT: u64 = 2;

    /// æ‰¾å‡ºèŒƒå›´å†…æ‰€æœ‰è´¨æ•°
    /// è¿”å›ï¼š[start, end]èŒƒå›´å†…çš„æ‰€æœ‰è´¨æ•°
    public fun find_primes_in_range(start: u64, end: u64): vector<u64> {
        // TODO: å®ç°
        // æç¤ºï¼šå¤–å±‚å¾ªç¯éå†èŒƒå›´ï¼Œå†…å±‚åˆ¤æ–­æ˜¯å¦ä¸ºè´¨æ•°
        vector::empty()
    }

    /// è®¡ç®—å®Œå…¨æ•°
    /// å®Œå…¨æ•°ï¼šç­‰äºå…¶æ‰€æœ‰çœŸå› æ•°ä¹‹å’Œï¼ˆ6 = 1+2+3ï¼‰
    public fun is_perfect_number(n: u64): bool {
        // TODO: å®ç°
        // æç¤ºï¼šæ‰¾å‡ºæ‰€æœ‰å› æ•°ï¼Œæ±‚å’Œå¹¶æ¯”è¾ƒ
        false
    }

    /// æ‰¾å‡ºèŒƒå›´å†…çš„æ‰€æœ‰å®Œå…¨æ•°
    public fun find_perfect_numbers(max: u64): vector<u64> {
        // TODO: å®ç°
        vector::empty()
    }

    /// åˆ¤æ–­æ˜¯å¦ä¸ºé˜¿å§†æ–¯ç‰¹æœ—æ•°ï¼ˆæ°´ä»™èŠ±æ•°ï¼‰
    /// ä¾‹ï¼š153 = 1Â³ + 5Â³ + 3Â³
    public fun is_armstrong_number(n: u64): bool {
        // TODO: å®ç°
        // æç¤ºï¼šè®¡ç®—ä½æ•°ï¼Œç„¶åæ¯ä½çš„næ¬¡æ–¹ä¹‹å’Œ
        false
    }

    /// è®¡ç®—æ•°å­—çš„å„ä½æ•°å­—ä¹‹ç§¯
    /// ç¤ºä¾‹ï¼š123 -> 1 * 2 * 3 = 6
    public fun digit_product(n: u64): u64 {
        // TODO: å®ç°
        0
    }

    /// æ‰¾å‡ºèŒƒå›´å†…æ•°å­—å„ä½ä¹‹ç§¯æœ€å¤§çš„æ•°å­—
    public fun max_digit_product_in_range(start: u64, end: u64): u64 {
        // TODO: å®ç°
        0
    }

    /// ç”Ÿæˆæ¨è¾‰ä¸‰è§’çš„å‰nè¡Œ
    /// è¿”å›ï¼šäºŒç»´å‘é‡è¡¨ç¤ºçš„æ¨è¾‰ä¸‰è§’
    public fun generate_pascals_triangle(n: u64): vector<vector<u64>> {
        // TODO: å®ç°
        // æç¤ºï¼šæ¯ä¸ªå…ƒç´  = ä¸Šä¸€è¡Œçš„ä¸¤ä¸ªå…ƒç´ ä¹‹å’Œ
        vector::empty()
    }

    /// æ‰¾å‡ºä¸¤ä¸ªæ•°ä¹‹é—´çš„æ‰€æœ‰å­ªç”Ÿè´¨æ•°å¯¹
    /// å­ªç”Ÿè´¨æ•°ï¼šç›¸å·®2çš„è´¨æ•°å¯¹ï¼Œå¦‚(3,5), (5,7), (11,13)
    public fun find_twin_primes(start: u64, end: u64): vector<vector<u64>> {
        // TODO: å®ç°
        vector::empty()
    }

    // ============================================
    // è¾…åŠ©å‡½æ•°ï¼ˆå¯ä»¥ä½¿ç”¨ï¼‰
    // ============================================

    /// åˆ¤æ–­æ˜¯å¦ä¸ºè´¨æ•°
    fun is_prime(n: u64): bool {
        if (n < 2) return false;
        if (n == 2) return true;
        if (n % 2 == 0) return false;
        
        let mut i = 3;
        while (i * i <= n) {
            if (n % i == 0) return false;
            i = i + 2;
        };
        true
    }

    /// è®¡ç®—æ•°å­—çš„ä½æ•°
    fun count_digits(n: u64): u64 {
        if (n == 0) return 1;
        let mut count = 0;
        let mut temp = n;
        while (temp > 0) {
            count = count + 1;
            temp = temp / 10;
        };
        count
    }

    /// å¹‚è¿ç®—
    fun power(base: u64, exp: u64): u64 {
        if (exp == 0) return 1;
        let mut result = 1;
        let mut i = 0;
        while (i < exp) {
            result = result * base;
            i = i + 1;
        };
        result
    }

    // ============================================
    // æµ‹è¯•ç”¨ä¾‹
    // ============================================

    #[test]
    fun test_find_primes_in_range() {
        let primes = find_primes_in_range(10, 20);
        // åº”è¯¥è¿”å›: [11, 13, 17, 19]
        assert!(vector::length(&primes) == 4, 0);
    }

    #[test]
    fun test_is_perfect_number() {
        assert!(is_perfect_number(6), 0);
        assert!(is_perfect_number(28), 1);
        assert!(!is_perfect_number(12), 2);
    }

    #[test]
    fun test_is_armstrong_number() {
        assert!(is_armstrong_number(153), 0);
        assert!(is_armstrong_number(9474), 1);
        assert!(!is_armstrong_number(123), 2);
    }

    #[test]
    fun test_digit_product() {
        assert!(digit_product(123) == 6, 0);
        assert!(digit_product(999) == 729, 1);
    }

    #[test]
    fun test_pascals_triangle() {
        let triangle = generate_pascals_triangle(5);
        assert!(vector::length(&triangle) == 5, 0);
        // ç¬¬3è¡Œåº”è¯¥æ˜¯ [1, 2, 1]
        let row2 = vector::borrow(&triangle, 2);
        assert!(vector::length(row2) == 3, 1);
    }
}
```

### è¯„åˆ†æ ‡å‡†

- find_primes_in_rangeï¼ˆ3åˆ†ï¼‰
- is_perfect_numberï¼ˆ3åˆ†ï¼‰
- is_armstrong_numberï¼ˆ3åˆ†ï¼‰
- digit_productï¼ˆ2åˆ†ï¼‰
- max_digit_product_in_rangeï¼ˆ3åˆ†ï¼‰
- generate_pascals_triangleï¼ˆ4åˆ†ï¼‰
- find_twin_primesï¼ˆ2åˆ†ï¼‰

---

## ç¼–ç¨‹é¢˜ 3ï¼šå®ç”¨ç®—æ³•å®ç°ï¼ˆ15 åˆ†ï¼‰

### é¢˜ç›®æè¿°

å®ç°ä¸€äº›å®ç”¨çš„ç®—æ³•å’Œæ•°æ®å¤„ç†å‡½æ•°ã€‚

### è¦æ±‚å®ç°çš„å‡½æ•°

```move
module my_addr::algorithms {
    use std::vector;

    const E_EMPTY_VECTOR: u64 = 1;
    const E_INVALID_INPUT: u64 = 2;

    /// å†’æ³¡æ’åºï¼ˆå‡åºï¼‰
    /// ä¿®æ”¹åŸå‘é‡
    public fun bubble_sort(vec: &mut vector<u64>) {
        // TODO: å®ç°å†’æ³¡æ’åº
        // æç¤ºï¼šåŒå±‚å¾ªç¯ï¼Œç›¸é‚»å…ƒç´ æ¯”è¾ƒå’Œäº¤æ¢
    }

    /// é€‰æ‹©æ’åºï¼ˆå‡åºï¼‰
    /// è¿”å›æ–°å‘é‡
    public fun selection_sort(vec: &vector<u64>): vector<u64> {
        // TODO: å®ç°é€‰æ‹©æ’åº
        // æç¤ºï¼šæ¯æ¬¡æ‰¾æœ€å°å€¼ï¼Œæ”¾åˆ°å‰é¢
        vector::empty()
    }

    /// äºŒåˆ†æŸ¥æ‰¾
    /// è¿”å›ï¼šå…ƒç´ ç´¢å¼•ï¼Œä¸å­˜åœ¨è¿”å›å‘é‡é•¿åº¦
    /// å‰æï¼šå‘é‡å·²æ’åº
    public fun binary_search(vec: &vector<u64>, target: u64): u64 {
        // TODO: å®ç°äºŒåˆ†æŸ¥æ‰¾
        0
    }

    /// å»é‡ï¼šè¿”å›å»é™¤é‡å¤å…ƒç´ çš„æ–°å‘é‡
    /// ä¿æŒåŸé¡ºåºï¼Œä¿ç•™ç¬¬ä¸€æ¬¡å‡ºç°
    public fun remove_duplicates(vec: &vector<u64>): vector<u64> {
        // TODO: å®ç°
        vector::empty()
    }

    /// åˆå¹¶ä¸¤ä¸ªæœ‰åºå‘é‡
    /// è¿”å›ï¼šåˆå¹¶åçš„æœ‰åºå‘é‡
    public fun merge_sorted_vectors(vec1: &vector<u64>, vec2: &vector<u64>): vector<u64> {
        // TODO: å®ç°
        // æç¤ºï¼šåŒæŒ‡é’ˆæ³•
        vector::empty()
    }

    /// æ‰¾å‡ºç¬¬kå°çš„å…ƒç´ 
    /// kä»1å¼€å§‹ï¼ˆk=1è¡¨ç¤ºæœ€å°å€¼ï¼‰
    public fun find_kth_smallest(vec: &vector<u64>, k: u64): u64 {
        // TODO: å®ç°
        // æç¤ºï¼šå¯ä»¥å…ˆæ’åºå†å–ç¬¬kä¸ª
        0
    }

    /// è®¡ç®—ä¸­ä½æ•°
    /// å¶æ•°ä¸ªå…ƒç´ æ—¶è¿”å›ä¸­é—´ä¸¤æ•°çš„å¹³å‡å€¼
    public fun median(vec: &vector<u64>): u64 {
        // TODO: å®ç°
        0
    }

    /// æ‰¾å‡ºä¼—æ•°ï¼ˆå‡ºç°æ¬¡æ•°æœ€å¤šçš„å…ƒç´ ï¼‰
    /// å¦‚æœæœ‰å¤šä¸ªï¼Œè¿”å›ä»»æ„ä¸€ä¸ª
    public fun mode(vec: &vector<u64>): u64 {
        assert!(vector::length(vec) > 0, E_EMPTY_VECTOR);
        // TODO: å®ç°
        0
    }

    /// æ—‹è½¬å‘é‡
    /// å‘å³æ—‹è½¬kä¸ªä½ç½®
    /// ä¾‹ï¼š[1,2,3,4,5] æ—‹è½¬2ä½ -> [4,5,1,2,3]
    public fun rotate_right(vec: &vector<u64>, k: u64): vector<u64> {
        // TODO: å®ç°
        vector::empty()
    }

    /// æ‰¾å‡ºæœ€é•¿é€’å¢å­åºåˆ—çš„é•¿åº¦
    public fun longest_increasing_subsequence_length(vec: &vector<u64>): u64 {
        // TODO: å®ç°
        // æç¤ºï¼šå¯ä»¥ä½¿ç”¨åŠ¨æ€è§„åˆ’æ€æƒ³ï¼ˆä½†ç”¨å¾ªç¯å®ç°ï¼‰
        0
    }

    // ============================================
    // è¾…åŠ©å‡½æ•°
    // ============================================

    /// äº¤æ¢å‘é‡ä¸­çš„ä¸¤ä¸ªå…ƒç´ 
    fun swap(vec: &mut vector<u64>, i: u64, j: u64) {
        let temp = *vector::borrow(vec, i);
        *vector::borrow_mut(vec, i) = *vector::borrow(vec, j);
        *vector::borrow_mut(vec, j) = temp;
    }

    // ============================================
    // æµ‹è¯•ç”¨ä¾‹
    // ============================================

    #[test]
    fun test_bubble_sort() {
        let mut vec = vector[5, 2, 8, 1, 9];
        bubble_sort(&mut vec);
        assert!(*vector::borrow(&vec, 0) == 1, 0);
        assert!(*vector::borrow(&vec, 4) == 9, 1);
    }

    #[test]
    fun test_binary_search() {
        let vec = vector[1, 3, 5, 7, 9];
        assert!(binary_search(&vec, 5) == 2, 0);
        assert!(binary_search(&vec, 6) == 5, 1);
    }

    #[test]
    fun test_remove_duplicates() {
        let vec = vector[1, 2, 2, 3, 3, 3, 4];
        let unique = remove_duplicates(&vec);
        assert!(vector::length(&unique) == 4, 0);
    }

    #[test]
    fun test_merge_sorted_vectors() {
        let vec1 = vector[1, 3, 5];
        let vec2 = vector[2, 4, 6];
        let merged = merge_sorted_vectors(&vec1, &vec2);
        assert!(vector::length(&merged) == 6, 0);
        assert!(*vector::borrow(&merged, 0) == 1, 1);
    }

    #[test]
    fun test_median() {
        let vec1 = vector[1, 2, 3];
        assert!(median(&vec1) == 2, 0);
        
        let vec2 = vector[1, 2, 3, 4];
        assert!(median(&vec2) == 2, 1);  // (2+3)/2 = 2
    }

    #[test]
    fun test_rotate_right() {
        let vec = vector[1, 2, 3, 4, 5];
        let rotated = rotate_right(&vec, 2);
        assert!(*vector::borrow(&rotated, 0) == 4, 0);
        assert!(*vector::borrow(&rotated, 4) == 3, 1);
    }
}
```

### è¯„åˆ†æ ‡å‡†

- bubble_sortï¼ˆ2åˆ†ï¼‰
- binary_searchï¼ˆ2åˆ†ï¼‰
- remove_duplicatesï¼ˆ2åˆ†ï¼‰
- merge_sorted_vectorsï¼ˆ3åˆ†ï¼‰
- find_kth_smallestï¼ˆ2åˆ†ï¼‰
- medianï¼ˆ2åˆ†ï¼‰
- rotate_rightï¼ˆ2åˆ†ï¼‰

---

## æäº¤è¦æ±‚

### ğŸ“¦ é¡¹ç›®ç»“æ„

```
exam/
â”œâ”€â”€ Move.toml
â””â”€â”€ sources/
    â”œâ”€â”€ recursion.move
    â”œâ”€â”€ number_game.move
    â””â”€â”€ algorithms.move
```

### ğŸ“„ Move.toml é…ç½®

```toml
[package]
name = "day03_exam"
version = "1.0.0"

[addresses]
my_addr = "0x42"

[dependencies]
AptosFramework = { git = "https://github.com/aptos-labs/aptos-core.git", subdir = "aptos-move/framework/aptos-framework", rev = "main" }
```

### âœ… éªŒè¯æ­¥éª¤

1. **ç¼–è¯‘**
```bash
aptos move compile
```

2. **è¿è¡Œæµ‹è¯•**
```bash
aptos move test
```

3. **ç¡®ä¿æ‰€æœ‰æµ‹è¯•é€šè¿‡**

---

## è¯„åˆ†æ€»ç»“

| é¢˜ç›® | åˆ†å€¼ | è¯´æ˜ |
|------|------|------|
| ç¼–ç¨‹é¢˜1ï¼šé€’å½’å‡½æ•° | 15åˆ† | é€’å½’æ€æƒ³ç†è§£ |
| ç¼–ç¨‹é¢˜2ï¼šæ§åˆ¶æµåº”ç”¨ | 20åˆ† | ç»¼åˆæ§åˆ¶æµä½¿ç”¨ |
| ç¼–ç¨‹é¢˜3ï¼šå®ç”¨ç®—æ³• | 15åˆ† | ç®—æ³•å®ç°èƒ½åŠ› |
| **æ€»åˆ†** | **50åˆ†** | |

---

## æç¤º

### ğŸ’¡ é€’å½’æ¨¡æ¿

```move
public fun recursive_function(n: u64): u64 {
    // åŸºç¡€æƒ…å†µ
    if (n == 0) {
        return base_value
    };
    
    // é€’å½’æƒ…å†µ
    recursive_function(n - 1) + something
}
```

### ğŸ’¡ åŒå±‚å¾ªç¯æ¨¡æ¿

```move
let mut i = 0;
while (i < n) {
    let mut j = 0;
    while (j < m) {
        // å¤„ç† (i, j)
        j = j + 1;
    };
    i = i + 1;
}
```

### ğŸ’¡ æŸ¥æ‰¾æ¨¡æ¿

```move
let mut i = 0;
while (i < len) {
    if (condition) {
        return i  // æ‰¾åˆ°
    };
    i = i + 1;
};
return not_found_value
```

ç¥è€ƒè¯•é¡ºåˆ©ï¼ğŸ“

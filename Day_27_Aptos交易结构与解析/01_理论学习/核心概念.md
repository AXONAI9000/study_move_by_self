# æ ¸å¿ƒæ¦‚å¿µï¼šAptos äº¤æ˜“ç»“æ„ä¸è§£æ

## ğŸ“š ç›®å½•

1. [Aptos äº¤æ˜“ç”Ÿå‘½å‘¨æœŸ](#1-aptos-äº¤æ˜“ç”Ÿå‘½å‘¨æœŸ)
2. [UserTransaction è¯¦è§£](#2-usertransaction-è¯¦è§£)
3. [Payload ç±»å‹åˆ†æ](#3-payload-ç±»å‹åˆ†æ)
4. [äº‹ä»¶ç³»ç»Ÿæ·±å…¥](#4-äº‹ä»¶ç³»ç»Ÿæ·±å…¥)
5. [ç­¾åå’ŒéªŒè¯](#5-ç­¾åå’ŒéªŒè¯)
6. [BCS ç¼–ç è¯¦è§£](#6-bcs-ç¼–ç è¯¦è§£)
7. [å®é™…åº”ç”¨åœºæ™¯](#7-å®é™…åº”ç”¨åœºæ™¯)

---

## 1. Aptos äº¤æ˜“ç”Ÿå‘½å‘¨æœŸ

### 1.1 äº¤æ˜“ç”Ÿå‘½å‘¨æœŸæ¦‚è§ˆ

Aptos äº¤æ˜“ä»åˆ›å»ºåˆ°ç¡®è®¤ç»å†ä»¥ä¸‹å…­ä¸ªé˜¶æ®µï¼š

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    äº¤æ˜“ç”Ÿå‘½å‘¨æœŸ                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

1. æ„é€ ï¼ˆConstructionï¼‰
   â†“
   ç”¨æˆ·æˆ–åº”ç”¨åˆ›å»ºäº¤æ˜“å¯¹è±¡
   - æŒ‡å®š senderã€payloadã€gas å‚æ•°ç­‰
   - è®¾ç½®è¿‡æœŸæ—¶é—´
   
2. ç­¾åï¼ˆSigningï¼‰
   â†“
   ä½¿ç”¨ç§é’¥å¯¹äº¤æ˜“ç­¾å
   - Ed25519 å•ç­¾
   - MultiEd25519 å¤šç­¾
   - ç”Ÿæˆç­¾åæ•°æ®
   
3. æäº¤ï¼ˆSubmissionï¼‰
   â†“
   å°†ç­¾ååçš„äº¤æ˜“æäº¤åˆ°èŠ‚ç‚¹
   - é€šè¿‡ REST API æˆ– SDK
   - è¿›å…¥ Mempool
   
4. éªŒè¯ï¼ˆValidationï¼‰
   â†“
   èŠ‚ç‚¹éªŒè¯äº¤æ˜“æœ‰æ•ˆæ€§
   - ç­¾åéªŒè¯
   - sequence_number æ£€æŸ¥
   - gas å‚æ•°éªŒè¯
   - è´¦æˆ·ä½™é¢æ£€æŸ¥
   
5. æ‰§è¡Œï¼ˆExecutionï¼‰
   â†“
   VM æ‰§è¡Œäº¤æ˜“
   - æ‰§è¡Œ Payloadï¼ˆå‡½æ•°è°ƒç”¨/è„šæœ¬ï¼‰
   - ä¿®æ”¹çŠ¶æ€
   - æ¶ˆè€— gas
   - å‘å‡ºäº‹ä»¶
   
6. ç¡®è®¤ï¼ˆConfirmationï¼‰
   â†“
   äº¤æ˜“è¢«åŒ…å«åœ¨åŒºå—ä¸­
   - çŠ¶æ€æœ€ç»ˆåŒ–
   - äº‹ä»¶è¢«ç´¢å¼•
   - å¯ä»¥æŸ¥è¯¢ç»“æœ
```

### 1.2 çŠ¶æ€è½¬æ¢è¯¦è§£

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Pending   â”‚  äº¤æ˜“åœ¨ Mempool ä¸­ç­‰å¾…
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â”œâ”€â”€â”€â”€â”€â–º [éªŒè¯å¤±è´¥] â”€â”€â–º Rejected
       â”‚
       â”œâ”€â”€â”€â”€â”€â–º [ç­‰å¾…è¶…æ—¶] â”€â”€â–º Expired
       â”‚
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Executing  â”‚  VM æ­£åœ¨æ‰§è¡Œäº¤æ˜“
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â”œâ”€â”€â”€â”€â”€â–º [æ‰§è¡Œå¤±è´¥] â”€â”€â–º Failed (ä»ç„¶æ¶ˆè€— gas)
       â”‚
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Success   â”‚  äº¤æ˜“æˆåŠŸæ‰§è¡Œ
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 1.3 äº¤æ˜“æ± ï¼ˆMempoolï¼‰

**Mempool çš„ä½œç”¨**ï¼š
- å­˜å‚¨å¾…å¤„ç†çš„äº¤æ˜“
- æ’åºå’Œä¼˜å…ˆçº§ç®¡ç†
- é˜²æ­¢åŒèŠ±
- åƒåœ¾äº¤æ˜“è¿‡æ»¤

**Mempool ä¸­çš„äº¤æ˜“çŠ¶æ€**ï¼š
```move
enum MempoolStatus {
    Accepted,          // æ¥å—å¹¶ç­‰å¾…æ‰§è¡Œ
    MempoolFull,       // Mempool å·²æ»¡
    TooManyTransactions, // æ¥è‡ªåŒä¸€è´¦æˆ·çš„äº¤æ˜“è¿‡å¤š
    InvalidSeqNumber,  // sequence_number æ— æ•ˆ
    InsufficientBalance, // ä½™é¢ä¸è¶³
    TransactionExpired, // å·²è¿‡æœŸ
}
```

---

## 2. UserTransaction è¯¦è§£

### 2.1 å®Œæ•´ç»“æ„å®šä¹‰

```rust
pub struct UserTransaction {
    /// äº¤æ˜“å‘é€è€…çš„è´¦æˆ·åœ°å€
    pub sender: AccountAddress,
    
    /// è´¦æˆ·çš„åºåˆ—å·ï¼ˆnonceï¼‰
    /// æ¯ä¸ªè´¦æˆ·çš„åºåˆ—å·ä» 0 å¼€å§‹ï¼Œæ¯æ¬¡äº¤æ˜“é€’å¢
    pub sequence_number: u64,
    
    /// äº¤æ˜“è½½è·ï¼ˆå®é™…è¦æ‰§è¡Œçš„å†…å®¹ï¼‰
    pub payload: TransactionPayload,
    
    /// æœ€å¤§ gas æ•°é‡ï¼ˆå•ä½ï¼šgas unitsï¼‰
    pub max_gas_amount: u64,
    
    /// gas å•ä»·ï¼ˆå•ä½ï¼šOctasï¼Œ1 APT = 10^8 Octasï¼‰
    pub gas_unit_price: u64,
    
    /// äº¤æ˜“è¿‡æœŸæ—¶é—´ï¼ˆUnix æ—¶é—´æˆ³ï¼Œç§’ï¼‰
    pub expiration_timestamp_secs: u64,
    
    /// é“¾ IDï¼ˆä¸»ç½‘=1ï¼Œæµ‹è¯•ç½‘=2ï¼Œå¼€å‘ç½‘=å…¶ä»–ï¼‰
    pub chain_id: ChainId,
    
    /// äº¤æ˜“ç­¾å
    pub signature: Signature,
}
```

### 2.2 å­—æ®µè¯¦è§£

#### 2.2.1 senderï¼ˆå‘é€è€…åœ°å€ï¼‰

```move
// AccountAddress æ˜¯ 32 å­—èŠ‚çš„åœ°å€
// ç¤ºä¾‹ï¼š0x1 (æ ‡å‡†åº“), 0xa (Aptos Framework)

let sender: address = @0x1234...5678;

// ä»åå…­è¿›åˆ¶å­—ç¬¦ä¸²åˆ›å»º
let addr = account::create_address_from_hex(
    b"0x1234567890abcdef1234567890abcdef12345678"
);
```

**è¦ç‚¹**ï¼š
- 32 å­—èŠ‚å›ºå®šé•¿åº¦
- é€šå¸¸ç”¨åå…­è¿›åˆ¶è¡¨ç¤º
- 0x0 æ˜¯æ— æ•ˆåœ°å€
- 0x1 åˆ° 0xa æ˜¯ç³»ç»Ÿä¿ç•™åœ°å€

#### 2.2.2 sequence_numberï¼ˆåºåˆ—å·ï¼‰

```
è´¦æˆ·åºåˆ—å·çš„ä½œç”¨ï¼š
1. é˜²æ­¢é‡æ”¾æ”»å‡»
2. ç¡®ä¿äº¤æ˜“é¡ºåº
3. æ£€æµ‹äº¤æ˜“ä¸¢å¤±

ç¤ºä¾‹ï¼š
è´¦æˆ· 0xAlice çš„äº¤æ˜“åºåˆ—ï¼š
  Txn #0: sequence_number = 0
  Txn #1: sequence_number = 1
  Txn #2: sequence_number = 2
  ...

å¦‚æœæäº¤ sequence_number = 5ï¼Œä½†å½“å‰è´¦æˆ·åºåˆ—å·æ˜¯ 3ï¼š
  â†’ é”™è¯¯ï¼šè·³è¿‡äº† sequence_number = 4
```

**é‡è¦è§„åˆ™**ï¼š
- å¿…é¡»ä» 0 å¼€å§‹
- å¿…é¡»è¿ç»­é€’å¢ï¼ˆä¸èƒ½è·³è¿‡ï¼‰
- åŒä¸€è´¦æˆ·çš„äº¤æ˜“æŒ‰åºåˆ—å·é¡ºåºæ‰§è¡Œ
- æäº¤æ—¶åºåˆ—å·å¿…é¡»ç­‰äºè´¦æˆ·å½“å‰åºåˆ—å·

```move
// è·å–è´¦æˆ·å½“å‰åºåˆ—å·
#[view]
public fun get_sequence_number(addr: address): u64 {
    account::get_sequence_number(addr)
}

// éªŒè¯åºåˆ—å·
assert!(
    txn.sequence_number == account::get_sequence_number(txn.sender),
    ERROR_INVALID_SEQUENCE_NUMBER
);
```

#### 2.2.3 payloadï¼ˆäº¤æ˜“è½½è·ï¼‰

Payload æ˜¯äº¤æ˜“çš„æ ¸å¿ƒå†…å®¹ï¼Œåé¢ä¼šè¯¦ç»†è®²è§£ã€‚ç±»å‹åŒ…æ‹¬ï¼š
- **EntryFunction**: è°ƒç”¨æ¨¡å—çš„ public entry å‡½æ•°
- **Script**: æ‰§è¡Œè‡ªå®šä¹‰å­—èŠ‚ç 
- **Multisig**: å¤šç­¾äº¤æ˜“
- **ModuleBundle**: å‘å¸ƒæ¨¡å—ï¼ˆå·²åºŸå¼ƒï¼‰

#### 2.2.4 max_gas_amountï¼ˆæœ€å¤§ gas æ•°é‡ï¼‰

```
Gas é™åˆ¶çš„ä½œç”¨ï¼š
1. é˜²æ­¢æ— é™å¾ªç¯
2. æ§åˆ¶äº¤æ˜“æˆæœ¬ä¸Šé™
3. ä¿æŠ¤ç½‘ç»œèµ„æº

è®¡ç®—æ–¹å¼ï¼š
  æœ€å¤§è´¹ç”¨ = max_gas_amount Ã— gas_unit_price
  
ç¤ºä¾‹ï¼š
  max_gas_amount = 100,000 gas units
  gas_unit_price = 100 Octas
  æœ€å¤§è´¹ç”¨ = 10,000,000 Octas = 0.1 APT
```

**å¸¸è§ gas æ¶ˆè€—**ï¼š
```
ç®€å•è½¬è´¦ï¼š           ~500 gas units
ä»£å¸äº¤æ¢ï¼š           ~5,000 gas units
æµåŠ¨æ€§æ·»åŠ ï¼š         ~10,000 gas units
NFT é“¸é€ ï¼š          ~15,000 gas units
å¤æ‚åˆçº¦äº¤äº’ï¼š       ~50,000+ gas units
```

**è®¾ç½®å»ºè®®**ï¼š
```move
// ä¿å®ˆä¼°è®¡ï¼ˆå»ºè®®å®é™… gas çš„ 1.5-2 å€ï¼‰
let max_gas = estimated_gas * 2;

// å¸¸è§è®¾ç½®
let simple_transfer_max_gas = 1_000;
let complex_defi_max_gas = 100_000;
```

#### 2.2.5 gas_unit_priceï¼ˆgas å•ä»·ï¼‰

```
Gas å®šä»·æœºåˆ¶ï¼š
- ç”±å¸‚åœºä¾›éœ€å†³å®š
- èŠ‚ç‚¹å¯è®¾ç½®æœ€ä½ gas ä»·æ ¼
- é«˜ gas ä»·æ ¼ä¼˜å…ˆå¤„ç†

ä¸»ç½‘å…¸å‹ä»·æ ¼ï¼š
  ä½ä¼˜å…ˆçº§ï¼š  100 Octas/gas unit
  æ­£å¸¸ä¼˜å…ˆçº§ï¼š200-500 Octas/gas unit
  é«˜ä¼˜å…ˆçº§ï¼š  1,000+ Octas/gas unit
```

**åŠ¨æ€è°ƒæ•´ç­–ç•¥**ï¼š
```move
// è·å–å»ºè®® gas ä»·æ ¼
#[view]
public fun get_suggested_gas_price(): u64 {
    // é€šè¿‡ REST API æˆ– Indexer æŸ¥è¯¢
    // è¿”å›å½“å‰ç½‘ç»œçš„ä¸­ä½æ•° gas ä»·æ ¼
}

// å¿«é€Ÿç¡®è®¤ç­–ç•¥
let gas_price = get_suggested_gas_price() * 2;

// èŠ‚çœæˆæœ¬ç­–ç•¥
let gas_price = get_suggested_gas_price() / 2;
```

#### 2.2.6 expiration_timestamp_secsï¼ˆè¿‡æœŸæ—¶é—´ï¼‰

```
è¿‡æœŸæœºåˆ¶çš„ä½œç”¨ï¼š
1. é˜²æ­¢äº¤æ˜“æ°¸ä¹…åœç•™åœ¨ Mempool
2. å…è®¸ç”¨æˆ·é‡æ–°æäº¤äº¤æ˜“
3. èŠ‚çœç½‘ç»œèµ„æº

è¿‡æœŸæ—¶é—´è®¾ç½®ï¼š
  å½“å‰æ—¶é—´ + æœ‰æ•ˆæœŸ
  
ç¤ºä¾‹ï¼š
  current_time = 1700000000 (2023-11-14 22:13:20 UTC)
  expiration = current_time + 600 (10åˆ†é’Ÿ)
            = 1700000600
```

**æœ€ä½³å®è·µ**ï¼š
```move
use aptos_framework::timestamp;

// çŸ­æœŸäº¤æ˜“ï¼ˆ10åˆ†é’Ÿï¼‰
let expiration = timestamp::now_seconds() + 600;

// æ ‡å‡†äº¤æ˜“ï¼ˆ1å°æ—¶ï¼‰
let expiration = timestamp::now_seconds() + 3600;

// é•¿æœŸäº¤æ˜“ï¼ˆ24å°æ—¶ï¼Œä¸æ¨èï¼‰
let expiration = timestamp::now_seconds() + 86400;

// éªŒè¯æœªè¿‡æœŸ
public fun is_transaction_valid(txn: &UserTransaction): bool {
    let current_time = timestamp::now_seconds();
    txn.expiration_timestamp_secs > current_time
}
```

#### 2.2.7 chain_idï¼ˆé“¾ IDï¼‰

```
Chain ID çš„ä½œç”¨ï¼š
- é˜²æ­¢è·¨é“¾é‡æ”¾æ”»å‡»
- æ ‡è¯†ä¸åŒçš„ Aptos ç½‘ç»œ

å¸¸ç”¨ Chain IDï¼š
  1  = Mainnetï¼ˆä¸»ç½‘ï¼‰
  2  = Testnetï¼ˆæµ‹è¯•ç½‘ï¼‰
  4  = Devnetï¼ˆå¼€å‘ç½‘ï¼‰
  å…¶ä»– = è‡ªå®šä¹‰ç½‘ç»œ
```

```move
// éªŒè¯ chain_id
const MAINNET_CHAIN_ID: u8 = 1;
const TESTNET_CHAIN_ID: u8 = 2;

public fun verify_chain_id(chain_id: u8) {
    assert!(
        chain_id == MAINNET_CHAIN_ID,
        ERROR_INVALID_CHAIN_ID
    );
}
```

### 2.3 äº¤æ˜“å¤§å°é™åˆ¶

```
äº¤æ˜“å¤§å°é™åˆ¶ï¼š
- æœ€å¤§äº¤æ˜“å¤§å°ï¼š~64 KB
- å®é™…å»ºè®®ï¼š< 32 KB

å¤§å°ç»„æˆï¼š
  - åŸºç¡€ç»“æ„ï¼š~200 bytes
  - Payloadï¼šå¯å˜ï¼ˆä¸»è¦éƒ¨åˆ†ï¼‰
  - ç­¾åï¼š64 bytes (Ed25519)
```

---

## 3. Payload ç±»å‹åˆ†æ

### 3.1 Payload ç±»å‹æ¦‚è§ˆ

```rust
pub enum TransactionPayload {
    /// è°ƒç”¨ entry å‡½æ•°ï¼ˆæœ€å¸¸ç”¨ï¼‰
    EntryFunction(EntryFunction),
    
    /// æ‰§è¡Œè„šæœ¬ï¼ˆè¾ƒå°‘ä½¿ç”¨ï¼‰
    Script(Script),
    
    /// å¤šç­¾äº¤æ˜“
    Multisig(Multisig),
    
    /// å‘å¸ƒæ¨¡å—ï¼ˆå·²åºŸå¼ƒï¼Œæ”¹ç”¨ entry functionï¼‰
    ModuleBundle(ModuleBundle),
}
```

### 3.2 EntryFunction è¯¦è§£

**æœ€å¸¸ç”¨çš„ Payload ç±»å‹**ï¼Œç”¨äºè°ƒç”¨æ¨¡å—çš„ public entry å‡½æ•°ã€‚

```rust
pub struct EntryFunction {
    /// æ¨¡å—æ ‡è¯†ç¬¦
    pub module: ModuleId,
    
    /// å‡½æ•°å
    pub function: Identifier,
    
    /// ç±»å‹å‚æ•°ï¼ˆæ³›å‹ï¼‰
    pub ty_args: Vec<TypeTag>,
    
    /// å‡½æ•°å‚æ•°ï¼ˆBCS ç¼–ç ï¼‰
    pub args: Vec<Vec<u8>>,
}
```

**ç¤ºä¾‹ 1ï¼šç®€å•è½¬è´¦**

```move
// åˆçº¦å‡½æ•°
module 0x1::coin {
    public entry fun transfer<CoinType>(
        from: &signer,
        to: address,
        amount: u64
    ) { ... }
}

// å¯¹åº”çš„ EntryFunction
EntryFunction {
    module: ModuleId {
        address: 0x1,
        name: "coin"
    },
    function: "transfer",
    ty_args: [
        TypeTag::Struct(StructTag {
            address: 0x1,
            module: "aptos_coin",
            name: "AptosCoin",
            type_params: []
        })
    ],
    args: [
        bcs::to_bytes(&to_address),    // address
        bcs::to_bytes(&1000000u64),     // u64
    ]
}
```

**ç¤ºä¾‹ 2ï¼šDEX äº¤æ¢**

```move
// åˆçº¦å‡½æ•°
public entry fun swap_exact_input<X, Y>(
    sender: &signer,
    amount_in: u64,
    min_amount_out: u64
) { ... }

// å¯¹åº”çš„ EntryFunction
EntryFunction {
    module: ModuleId {
        address: 0xABC...,
        name: "dex"
    },
    function: "swap_exact_input",
    ty_args: [
        TypeTag::Struct(...), // X ä»£å¸ç±»å‹
        TypeTag::Struct(...), // Y ä»£å¸ç±»å‹
    ],
    args: [
        bcs::to_bytes(&1000000u64),     // amount_in
        bcs::to_bytes(&990000u64),      // min_amount_out
    ]
}
```

**EntryFunction è§£æä»£ç **ï¼š

```move
module parser::entry_function_parser {
    use std::string::{Self, String};
    use std::vector;
    
    struct ParsedEntryFunction has drop {
        module_address: address,
        module_name: String,
        function_name: String,
        type_args: vector<String>,
        args: vector<vector<u8>>,
    }
    
    public fun parse_entry_function(
        payload: &vector<u8>
    ): ParsedEntryFunction {
        // BCS ååºåˆ—åŒ–
        let entry_fn: EntryFunction = bcs::from_bytes(payload);
        
        ParsedEntryFunction {
            module_address: entry_fn.module.address,
            module_name: entry_fn.module.name,
            function_name: entry_fn.function,
            type_args: entry_fn.ty_args,
            args: entry_fn.args,
        }
    }
    
    // æå–å‡½æ•°è°ƒç”¨çš„å®Œæ•´ç­¾å
    public fun get_function_signature(
        parsed: &ParsedEntryFunction
    ): String {
        let sig = string::utf8(b"");
        string::append(&mut sig, address_to_string(&parsed.module_address));
        string::append_utf8(&mut sig, b"::");
        string::append(&mut sig, parsed.module_name);
        string::append_utf8(&mut sig, b"::");
        string::append(&mut sig, parsed.function_name);
        
        // æ·»åŠ ç±»å‹å‚æ•°
        if (!vector::is_empty(&parsed.type_args)) {
            string::append_utf8(&mut sig, b"<");
            // ... æ‹¼æ¥ç±»å‹å‚æ•°
            string::append_utf8(&mut sig, b">");
        };
        
        sig
    }
}
```

### 3.3 Script Payload

**è¾ƒå°‘ä½¿ç”¨**ï¼Œå…è®¸æ‰§è¡Œè‡ªå®šä¹‰å­—èŠ‚ç ã€‚

```rust
pub struct Script {
    /// ç¼–è¯‘åçš„ Move å­—èŠ‚ç 
    pub code: Vec<u8>,
    
    /// ç±»å‹å‚æ•°
    pub ty_args: Vec<TypeTag>,
    
    /// è„šæœ¬å‚æ•°
    pub args: Vec<TransactionArgument>,
}
```

**Script vs EntryFunction**ï¼š

| ç‰¹æ€§ | Script | EntryFunction |
|------|--------|---------------|
| ä½¿ç”¨åœºæ™¯ | ä¸´æ—¶é€»è¾‘ã€ä¸€æ¬¡æ€§æ“ä½œ | å¸¸è§„åˆçº¦è°ƒç”¨ |
| ä»£ç å­˜å‚¨ | æ¯æ¬¡äº¤æ˜“åŒ…å«å­—èŠ‚ç  | ä»£ç å·²éƒ¨ç½²åœ¨é“¾ä¸Š |
| Gas æˆæœ¬ | è¾ƒé«˜ï¼ˆåŒ…å«å­—èŠ‚ç ï¼‰ | è¾ƒä½ |
| å®‰å…¨æ€§ | éœ€è¦å®¡æŸ¥å­—èŠ‚ç  | è°ƒç”¨å·²å®¡è®¡çš„åˆçº¦ |
| æ¨èåº¦ | ä¸æ¨è | **æ¨è** |

### 3.4 Multisig Payload

**å¤šç­¾äº¤æ˜“**ï¼Œéœ€è¦å¤šä¸ªç­¾åè€…æ‰¹å‡†ã€‚

```rust
pub struct Multisig {
    /// å¤šç­¾è´¦æˆ·åœ°å€
    pub multisig_address: AccountAddress,
    
    /// å®é™…çš„äº¤æ˜“è½½è·ï¼ˆå¯é€‰ï¼‰
    pub transaction_payload: Option<MultisigTransactionPayload>,
}

pub struct MultisigTransactionPayload {
    /// å¯ä»¥æ˜¯ EntryFunction æˆ–å…¶ä»–ç±»å‹
    pub payload: TransactionPayload,
}
```

**å¤šç­¾æµç¨‹**ï¼š

```
1. åˆ›å»ºå¤šç­¾ææ¡ˆ
   â†“
2. ç­¾åè€…æŠ•ç¥¨æ‰¹å‡†
   â†“
3. è¾¾åˆ°é˜ˆå€¼ï¼ˆå¦‚ 2/3ï¼‰
   â†“
4. æ‰§è¡Œäº¤æ˜“
```

**ä»£ç ç¤ºä¾‹**ï¼š

```move
module multisig::multisig_account {
    use std::vector;
    
    struct MultisigAccount has key {
        owners: vector<address>,
        threshold: u64,
        sequence_number: u64,
    }
    
    // åˆ›å»ºå¤šç­¾è´¦æˆ·ï¼ˆ3ä¸ªæ‰€æœ‰è€…ï¼Œéœ€è¦2ä¸ªç­¾åï¼‰
    public entry fun create_multisig_account(
        creator: &signer,
        owners: vector<address>,
        threshold: u64
    ) {
        assert!(threshold <= vector::length(&owners), ERROR_INVALID_THRESHOLD);
        // ...
    }
    
    // æäº¤å¤šç­¾äº¤æ˜“ææ¡ˆ
    public entry fun create_transaction(
        proposer: &signer,
        multisig_addr: address,
        payload: vector<u8>
    ) {
        // ...
    }
    
    // æ‰¹å‡†äº¤æ˜“
    public entry fun approve_transaction(
        approver: &signer,
        multisig_addr: address,
        transaction_id: u64
    ) {
        // ...
    }
    
    // æ‰§è¡Œäº¤æ˜“ï¼ˆè¾¾åˆ°é˜ˆå€¼åï¼‰
    public entry fun execute_transaction(
        executor: &signer,
        multisig_addr: address,
        transaction_id: u64
    ) {
        // éªŒè¯ç­¾åæ•°é‡ >= threshold
        // æ‰§è¡Œ payload
    }
}
```

---

## 4. äº‹ä»¶ç³»ç»Ÿæ·±å…¥

### 4.1 Event ç»“æ„

```rust
pub struct Event {
    /// äº‹ä»¶å¥æŸ„ï¼ˆæ ‡è¯†äº‹ä»¶æ¥æºï¼‰
    pub key: EventHandle,
    
    /// äº‹ä»¶åºåˆ—å·ï¼ˆä»0å¼€å§‹é€’å¢ï¼‰
    pub sequence_number: u64,
    
    /// äº‹ä»¶ç±»å‹ï¼ˆstruct typeï¼‰
    pub type_: TypeTag,
    
    /// äº‹ä»¶æ•°æ®ï¼ˆBCS ç¼–ç ï¼‰
    pub data: Vec<u8>,
}
```

### 4.2 EventHandle æœºåˆ¶

```move
module events::swap_events {
    use std::event::{Self, EventHandle};
    use aptos_framework::account;
    
    // å®šä¹‰äº‹ä»¶æ•°æ®ç»“æ„
    struct SwapEvent has drop, store {
        user: address,
        coin_in: String,
        coin_out: String,
        amount_in: u64,
        amount_out: u64,
        timestamp: u64,
    }
    
    // å­˜å‚¨äº‹ä»¶å¥æŸ„
    struct SwapEventStore has key {
        swap_events: EventHandle<SwapEvent>,
    }
    
    // åˆå§‹åŒ–äº‹ä»¶å­˜å‚¨
    public entry fun initialize(account: &signer) {
        move_to(account, SwapEventStore {
            swap_events: account::new_event_handle<SwapEvent>(account),
        });
    }
    
    // å‘å‡ºäº‹ä»¶
    public fun emit_swap_event(
        store_addr: address,
        user: address,
        coin_in: String,
        coin_out: String,
        amount_in: u64,
        amount_out: u64,
    ) acquires SwapEventStore {
        let store = borrow_global_mut<SwapEventStore>(store_addr);
        
        event::emit_event(&mut store.swap_events, SwapEvent {
            user,
            coin_in,
            coin_out,
            amount_in,
            amount_out,
            timestamp: timestamp::now_seconds(),
        });
    }
}
```

### 4.3 äº‹ä»¶ç´¢å¼•å’ŒæŸ¥è¯¢

**é€šè¿‡ REST API æŸ¥è¯¢äº‹ä»¶**ï¼š

```bash
# æŸ¥è¯¢ç‰¹å®šè´¦æˆ·çš„äº‹ä»¶
GET /v1/accounts/{address}/events/{event_handle}/{field_name}

# ç¤ºä¾‹
GET /v1/accounts/0xABC.../events/0xABC.../SwapEventStore/swap_events

# å“åº”
[
  {
    "version": "12345678",
    "key": "0x0000000000000000...",
    "sequence_number": "10",
    "type": "0xABC::swap_events::SwapEvent",
    "data": {
      "user": "0x123...",
      "coin_in": "APT",
      "coin_out": "USDC",
      "amount_in": "1000000",
      "amount_out": "5000000",
      "timestamp": "1700000000"
    }
  }
]
```

**äº‹ä»¶è¿‡æ»¤å™¨å®ç°**ï¼š

```move
module parser::event_filter {
    use std::vector;
    use std::string::String;
    
    struct EventFilter has drop {
        event_type: Option<String>,
        min_sequence: Option<u64>,
        max_sequence: Option<u64>,
        address_filter: Option<address>,
    }
    
    public fun create_filter(
        event_type: Option<String>,
        min_seq: Option<u64>,
        max_seq: Option<u64>,
        addr_filter: Option<address>,
    ): EventFilter {
        EventFilter {
            event_type,
            min_sequence: min_seq,
            max_sequence: max_seq,
            address_filter: addr_filter,
        }
    }
    
    public fun matches(
        filter: &EventFilter,
        event: &Event
    ): bool {
        // æ£€æŸ¥äº‹ä»¶ç±»å‹
        if (option::is_some(&filter.event_type)) {
            let expected_type = option::borrow(&filter.event_type);
            if (&event.type_ != expected_type) {
                return false
            };
        };
        
        // æ£€æŸ¥åºåˆ—å·èŒƒå›´
        if (option::is_some(&filter.min_sequence)) {
            let min = *option::borrow(&filter.min_sequence);
            if (event.sequence_number < min) {
                return false
            };
        };
        
        if (option::is_some(&filter.max_sequence)) {
            let max = *option::borrow(&filter.max_sequence);
            if (event.sequence_number > max) {
                return false
            };
        };
        
        // æ£€æŸ¥åœ°å€è¿‡æ»¤
        // ... å®ç°åœ°å€åŒ¹é…é€»è¾‘
        
        true
    }
    
    public fun filter_events(
        events: &vector<Event>,
        filter: &EventFilter
    ): vector<Event> {
        let result = vector::empty<Event>();
        let i = 0;
        let len = vector::length(events);
        
        while (i < len) {
            let event = vector::borrow(events, i);
            if (matches(filter, event)) {
                vector::push_back(&mut result, *event);
            };
            i = i + 1;
        };
        
        result
    }
}
```

### 4.4 å¸¸è§äº‹ä»¶ç±»å‹

**è½¬è´¦äº‹ä»¶**ï¼š
```move
struct TransferEvent has drop, store {
    from: address,
    to: address,
    amount: u64,
}
```

**ä»£å¸äº¤æ¢äº‹ä»¶**ï¼š
```move
struct SwapEvent has drop, store {
    user: address,
    amount_in: u64,
    amount_out: u64,
    reserve_in: u64,
    reserve_out: u64,
}
```

**æµåŠ¨æ€§äº‹ä»¶**ï¼š
```move
struct LiquidityEvent has drop, store {
    provider: address,
    amount_x: u64,
    amount_y: u64,
    liquidity_minted: u64,
    is_add: bool, // true = æ·»åŠ , false = ç§»é™¤
}
```

---

## 5. ç­¾åå’ŒéªŒè¯

### 5.1 ç­¾åç±»å‹

Aptos æ”¯æŒä¸¤ç§ç­¾åæ–¹æ¡ˆï¼š

```rust
pub enum Signature {
    /// å•ç­¾ï¼ˆEd25519ï¼‰
    Ed25519(Ed25519Signature),
    
    /// å¤šç­¾ï¼ˆMultiEd25519ï¼‰
    MultiEd25519(MultiEd25519Signature),
}
```

### 5.2 Ed25519 å•ç­¾

```
Ed25519 ç­¾åç‰¹ç‚¹ï¼š
- ç­¾åé•¿åº¦ï¼š64 bytes
- å…¬é’¥é•¿åº¦ï¼š32 bytes
- å®‰å…¨æ€§é«˜
- éªŒè¯é€Ÿåº¦å¿«
```

**ç­¾åè¿‡ç¨‹**ï¼š

```
1. æ„é€ äº¤æ˜“æ¶ˆæ¯
   message = bcs::serialize(txn)
   
2. æ·»åŠ å‰ç¼€
   signing_message = "APTOS::RawTransaction" || message
   
3. è®¡ç®—ç­¾å
   signature = ed25519_sign(private_key, signing_message)
   
4. é™„åŠ åˆ°äº¤æ˜“
   txn.signature = Signature::Ed25519(signature)
```

**éªŒè¯è¿‡ç¨‹**ï¼š

```move
module signature::ed25519_verifier {
    use aptos_std::ed25519;
    
    public fun verify_signature(
        public_key: &vector<u8>,
        signature: &vector<u8>,
        message: &vector<u8>
    ): bool {
        // åˆ›å»º Ed25519 å…¬é’¥å¯¹è±¡
        let pk = ed25519::new_unvalidated_public_key_from_bytes(*public_key);
        
        // åˆ›å»ºç­¾åå¯¹è±¡
        let sig = ed25519::new_signature_from_bytes(*signature);
        
        // éªŒè¯ç­¾å
        ed25519::signature_verify_strict(&sig, &pk, *message)
    }
    
    public fun verify_transaction_signature(
        txn: &UserTransaction
    ): bool {
        // 1. æå–å…¬é’¥ï¼ˆä»ç­¾åæˆ–è´¦æˆ·ï¼‰
        let public_key = extract_public_key(&txn.signature);
        
        // 2. åºåˆ—åŒ–äº¤æ˜“ï¼ˆä¸åŒ…å«ç­¾åï¼‰
        let message = serialize_txn_for_signing(txn);
        
        // 3. æå–ç­¾åæ•°æ®
        let signature = extract_signature_bytes(&txn.signature);
        
        // 4. éªŒè¯
        verify_signature(&public_key, &signature, &message)
    }
}
```

### 5.3 MultiEd25519 å¤šç­¾

```
MultiEd25519 ç­¾åç‰¹ç‚¹ï¼š
- æ”¯æŒ M-of-N ç­¾åï¼ˆå¦‚ 2-of-3ï¼‰
- å…¬é’¥ï¼š32N + 1 bytesï¼ˆN ä¸ªå…¬é’¥ + é˜ˆå€¼ï¼‰
- ç­¾åï¼š64M + 4 bytesï¼ˆM ä¸ªç­¾å + bitmapï¼‰
```

**MultiEd25519 ç»“æ„**ï¼š

```rust
pub struct MultiEd25519PublicKey {
    /// N ä¸ªå…¬é’¥
    public_keys: Vec<Ed25519PublicKey>,
    
    /// é˜ˆå€¼ Mï¼ˆéœ€è¦å¤šå°‘ä¸ªç­¾åï¼‰
    threshold: u8,
}

pub struct MultiEd25519Signature {
    /// M ä¸ªç­¾å
    signatures: Vec<Ed25519Signature>,
    
    /// 4-bit bitmapï¼Œæ ‡è¯†å“ªäº›å…¬é’¥ç­¾åäº†
    bitmap: [u8; 4],
}
```

**Bitmap è§£é‡Š**ï¼š

```
å‡è®¾æœ‰ 4 ä¸ªå…¬é’¥ï¼Œé˜ˆå€¼ä¸º 2ï¼š
  public_keys = [pk0, pk1, pk2, pk3]
  threshold = 2

å¦‚æœ pk1 å’Œ pk3 ç­¾åï¼š
  bitmap = 0b1010 = 10 (åè¿›åˆ¶)
  
  ä½ 0: 0 (pk0 æœªç­¾å)
  ä½ 1: 1 (pk1 å·²ç­¾å)
  ä½ 2: 0 (pk2 æœªç­¾å)
  ä½ 3: 1 (pk3 å·²ç­¾å)
```

**å¤šç­¾éªŒè¯ä»£ç **ï¼š

```move
module signature::multi_ed25519_verifier {
    use aptos_std::multi_ed25519;
    
    public fun verify_multi_signature(
        public_keys: &vector<vector<u8>>,
        threshold: u8,
        signatures: &vector<vector<u8>>,
        bitmap: vector<u8>,
        message: &vector<u8>
    ): bool {
        // æ£€æŸ¥ç­¾åæ•°é‡ >= é˜ˆå€¼
        assert!(
            vector::length(signatures) >= (threshold as u64),
            ERROR_INSUFFICIENT_SIGNATURES
        );
        
        // æ„é€  MultiEd25519 å…¬é’¥
        let multi_pk = multi_ed25519::new_unvalidated_public_key_from_bytes(
            public_keys,
            threshold
        );
        
        // æ„é€  MultiEd25519 ç­¾å
        let multi_sig = multi_ed25519::new_signature_from_bytes(
            signatures,
            bitmap
        );
        
        // éªŒè¯
        multi_ed25519::signature_verify_strict(&multi_sig, &multi_pk, *message)
    }
}
```

---

## 6. BCS ç¼–ç è¯¦è§£

### 6.1 ä»€ä¹ˆæ˜¯ BCSï¼Ÿ

**BCS (Binary Canonical Serialization)** æ˜¯ Aptos å’Œ Move ä½¿ç”¨çš„æ ‡å‡†åºåˆ—åŒ–æ ¼å¼ã€‚

**ç‰¹ç‚¹**ï¼š
- **è§„èŒƒæ€§**ï¼šç›¸åŒæ•°æ®å§‹ç»ˆäº§ç”Ÿç›¸åŒå­—èŠ‚åºåˆ—
- **ç´§å‡‘æ€§**ï¼šäºŒè¿›åˆ¶æ ¼å¼ï¼Œå ç”¨ç©ºé—´å°
- **é«˜æ•ˆæ€§**ï¼šåºåˆ—åŒ–å’Œååºåˆ—åŒ–é€Ÿåº¦å¿«
- **å®‰å…¨æ€§**ï¼šé˜²æ­¢æ­§ä¹‰å’Œæ³¨å…¥æ”»å‡»

### 6.2 åŸºæœ¬ç±»å‹ç¼–ç 

```
Boolean:
  false = 0x00
  true  = 0x01

Unsigned Integer (u8, u16, u32, u64, u128, u256):
  Little-endian ç¼–ç 
  u8(255)  = 0xFF
  u64(256) = 0x0001000000000000

Address (32 bytes):
  ç›´æ¥ç¼–ç  32 å­—èŠ‚
  0x1 = 0x0000000000000000000000000000000000000000000000000000000000000001

Vector<T>:
  [é•¿åº¦(ULEB128)] + [å…ƒç´ 1] + [å…ƒç´ 2] + ...
  vector<u8>[1,2,3] = 0x03010203
```

### 6.3 å¤æ‚ç±»å‹ç¼–ç 

**Struct ç¼–ç **ï¼š

```move
struct User {
    name: String,
    age: u8,
    balance: u64,
}

// ç¼–ç é¡ºåºï¼šæŒ‰å­—æ®µå®šä¹‰é¡ºåº
// User { name: "Alice", age: 25, balance: 1000 }
// = bcs(name) + bcs(age) + bcs(balance)
```

**Option<T> ç¼–ç **ï¼š

```
None    = 0x00
Some(x) = 0x01 + bcs(x)

Option::none<u64>()  = 0x00
Option::some(42u64) = 0x012A00000000000000
```

### 6.4 BCS ä½¿ç”¨ç¤ºä¾‹

```move
module bcs_example::serialization {
    use std::bcs;
    use std::vector;
    
    struct Transaction has drop {
        sender: address,
        amount: u64,
        recipient: address,
    }
    
    // åºåˆ—åŒ–
    public fun serialize_transaction(
        sender: address,
        amount: u64,
        recipient: address
    ): vector<u8> {
        let txn = Transaction { sender, amount, recipient };
        bcs::to_bytes(&txn)
    }
    
    // ååºåˆ—åŒ–
    public fun deserialize_transaction(
        bytes: &vector<u8>
    ): Transaction {
        bcs::from_bytes<Transaction>(bytes)
    }
    
    // éªŒè¯åºåˆ—åŒ–çš„ç¡®å®šæ€§
    #[test]
    public fun test_bcs_deterministic() {
        let sender = @0x1;
        let amount = 1000u64;
        let recipient = @0x2;
        
        let bytes1 = serialize_transaction(sender, amount, recipient);
        let bytes2 = serialize_transaction(sender, amount, recipient);
        
        // ç›¸åŒè¾“å…¥äº§ç”Ÿç›¸åŒè¾“å‡º
        assert!(bytes1 == bytes2, 0);
    }
}
```

---

## 7. å®é™…åº”ç”¨åœºæ™¯

### 7.1 äº¤æ˜“ç›‘æ§

```move
module monitor::transaction_monitor {
    use std::vector;
    use std::string::String;
    
    struct TransactionSummary has drop {
        hash: vector<u8>,
        sender: address,
        function_called: String,
        gas_used: u64,
        success: bool,
        events_count: u64,
    }
    
    // ç›‘æ§ç‰¹å®šæ¨¡å—çš„è°ƒç”¨
    public fun monitor_module_calls(
        module_address: address,
        module_name: String,
        transactions: &vector<UserTransaction>
    ): vector<TransactionSummary> {
        let summaries = vector::empty<TransactionSummary>();
        
        let i = 0;
        while (i < vector::length(transactions)) {
            let txn = vector::borrow(transactions, i);
            
            // è§£æ payload
            if (is_entry_function(&txn.payload)) {
                let entry_fn = extract_entry_function(&txn.payload);
                
                // æ£€æŸ¥æ˜¯å¦è°ƒç”¨ç›®æ ‡æ¨¡å—
                if (entry_fn.module.address == module_address &&
                    entry_fn.module.name == module_name) {
                    
                    vector::push_back(&mut summaries, TransactionSummary {
                        hash: hash_transaction(txn),
                        sender: txn.sender,
                        function_called: entry_fn.function,
                        gas_used: calculate_gas_used(txn),
                        success: txn.success,
                        events_count: count_events(txn),
                    });
                };
            };
            
            i = i + 1;
        };
        
        summaries
    }
}
```

### 7.2 MEV æœºä¼šæ£€æµ‹

```move
module mev::opportunity_detector {
    use std::vector;
    
    struct SwapOpportunity has drop {
        txn_hash: vector<u8>,
        dex: String,
        token_in: String,
        token_out: String,
        amount_in: u64,
        estimated_profit: u64,
    }
    
    // æ£€æµ‹å¥—åˆ©æœºä¼š
    public fun detect_arbitrage_opportunities(
        pending_transactions: &vector<UserTransaction>
    ): vector<SwapOpportunity> {
        let opportunities = vector::empty<SwapOpportunity>();
        
        // éå† pending äº¤æ˜“
        let i = 0;
        while (i < vector::length(pending_transactions)) {
            let txn = vector::borrow(pending_transactions, i);
            
            // æ£€æµ‹æ˜¯å¦æ˜¯äº¤æ¢äº¤æ˜“
            if (is_swap_transaction(txn)) {
                let swap_details = extract_swap_details(txn);
                
                // è®¡ç®—é¢„æœŸä»·æ ¼å½±å“
                let price_impact = calculate_price_impact(&swap_details);
                
                // æ£€æŸ¥å¥—åˆ©æœºä¼š
                if (has_arbitrage_opportunity(&swap_details, price_impact)) {
                    let profit = estimate_arbitrage_profit(&swap_details);
                    
                    if (profit > MIN_PROFIT_THRESHOLD) {
                        vector::push_back(&mut opportunities, SwapOpportunity {
                            txn_hash: hash_transaction(txn),
                            dex: swap_details.dex,
                            token_in: swap_details.token_in,
                            token_out: swap_details.token_out,
                            amount_in: swap_details.amount_in,
                            estimated_profit: profit,
                        });
                    };
                };
            };
            
            i = i + 1;
        };
        
        opportunities
    }
}
```

### 7.3 äº¤æ˜“é‡æ”¾ä¿æŠ¤

```move
module security::replay_protection {
    use std::vector;
    
    struct ProcessedTransaction has key {
        txn_hashes: vector<vector<u8>>,
    }
    
    // åˆå§‹åŒ–
    public entry fun initialize(account: &signer) {
        move_to(account, ProcessedTransaction {
            txn_hashes: vector::empty(),
        });
    }
    
    // æ£€æŸ¥äº¤æ˜“æ˜¯å¦å·²å¤„ç†
    public fun is_processed(
        txn_hash: &vector<u8>
    ): bool acquires ProcessedTransaction {
        let store = borrow_global<ProcessedTransaction>(@replay_protection);
        vector::contains(&store.txn_hashes, txn_hash)
    }
    
    // æ ‡è®°äº¤æ˜“ä¸ºå·²å¤„ç†
    public fun mark_as_processed(
        txn_hash: vector<u8>
    ) acquires ProcessedTransaction {
        assert!(!is_processed(&txn_hash), ERROR_ALREADY_PROCESSED);
        
        let store = borrow_global_mut<ProcessedTransaction>(@replay_protection);
        vector::push_back(&mut store.txn_hashes, txn_hash);
    }
    
    // éªŒè¯äº¤æ˜“çš„å”¯ä¸€æ€§
    public fun verify_transaction_uniqueness(
        txn: &UserTransaction
    ): bool {
        // è®¡ç®—äº¤æ˜“å“ˆå¸Œ
        let txn_hash = hash_transaction(txn);
        
        // éªŒè¯ chain_id
        assert!(txn.chain_id == EXPECTED_CHAIN_ID, ERROR_WRONG_CHAIN);
        
        // éªŒè¯æœªè¿‡æœŸ
        let current_time = timestamp::now_seconds();
        assert!(
            txn.expiration_timestamp_secs > current_time,
            ERROR_EXPIRED
        );
        
        // éªŒè¯ sequence_number
        let expected_seq = account::get_sequence_number(txn.sender);
        assert!(txn.sequence_number == expected_seq, ERROR_INVALID_SEQ);
        
        // éªŒè¯æœªè¢«å¤„ç†è¿‡
        !is_processed(&txn_hash)
    }
}
```

---

## ğŸ“Š æ€»ç»“

### å…³é”®è¦ç‚¹å›é¡¾

1. **äº¤æ˜“ç”Ÿå‘½å‘¨æœŸ**
   - æ„é€  â†’ ç­¾å â†’ æäº¤ â†’ éªŒè¯ â†’ æ‰§è¡Œ â†’ ç¡®è®¤
   - æ¯ä¸ªé˜¶æ®µéƒ½æœ‰å…³é”®æ£€æŸ¥ç‚¹

2. **UserTransaction ç»“æ„**
   - 8 ä¸ªå…³é”®å­—æ®µï¼Œæ¯ä¸ªéƒ½æœ‰ç‰¹å®šä½œç”¨
   - sequence_number é˜²æ­¢é‡æ”¾
   - gas å‚æ•°æ§åˆ¶æˆæœ¬
   - expiration é™åˆ¶æœ‰æ•ˆæœŸ

3. **Payload ç±»å‹**
   - EntryFunction æœ€å¸¸ç”¨
   - Script ä¸æ¨è
   - Multisig ç”¨äºå¤šç­¾åœºæ™¯

4. **äº‹ä»¶ç³»ç»Ÿ**
   - EventHandle æœºåˆ¶
   - BCS ç¼–ç çš„äº‹ä»¶æ•°æ®
   - å¯æŸ¥è¯¢å’Œç´¢å¼•

5. **ç­¾åéªŒè¯**
   - Ed25519 å•ç­¾
   - MultiEd25519 å¤šç­¾
   - éªŒè¯æ˜¯å®‰å…¨çš„å…³é”®

6. **BCS ç¼–ç **
   - è§„èŒƒã€ç´§å‡‘ã€é«˜æ•ˆ
   - æ‰€æœ‰é“¾ä¸Šæ•°æ®çš„æ ‡å‡†ç¼–ç 
   - ç¡®å®šæ€§åºåˆ—åŒ–

### å®é™…åº”ç”¨

- âœ… äº¤æ˜“ç›‘æ§å’Œåˆ†æ
- âœ… MEV æœºä¼šæ£€æµ‹
- âœ… é“¾ä¸Šæ•°æ®ç´¢å¼•
- âœ… å®‰å…¨å®¡è®¡
- âœ… è‡ªå®šä¹‰æµè§ˆå™¨

---

**ğŸ¯ ä¸‹ä¸€æ­¥**ï¼šå®Œæˆå®è·µä»»åŠ¡ï¼Œæ„å»ºè‡ªå·±çš„äº¤æ˜“è§£æå·¥å…·ï¼

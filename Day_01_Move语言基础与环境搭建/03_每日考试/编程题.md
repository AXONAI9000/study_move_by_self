# Day 01 æ¯æ—¥è€ƒè¯• - ç¼–ç¨‹é¢˜

**æ€»åˆ†ï¼š50 åˆ†**  
**æ—¶é—´ï¼š30 åˆ†é’Ÿ**

---

## ç¼–ç¨‹é¢˜ 1ï¼šæ•°å­¦è®¡ç®—å™¨ï¼ˆ15 åˆ†ï¼‰

### é¢˜ç›®æè¿°

å®ç°ä¸€ä¸ªç®€å•çš„æ•°å­¦è®¡ç®—å™¨æ¨¡å—ï¼ŒåŒ…å«åŸºæœ¬çš„ç®—æœ¯è¿ç®—ã€‚

### è¦æ±‚å®ç°çš„å‡½æ•°

```move
module my_addr::calculator {
    // åŠ æ³•
    public fun add(a: u64, b: u64): u64 {
        // TODO: å®ç°
    }
    
    // å‡æ³•ï¼ˆéœ€è¦æ£€æŸ¥ä¸‹æº¢ï¼‰
    public fun subtract(a: u64, b: u64): u64 {
        // TODO: å®ç°
    }
    
    // ä¹˜æ³•
    public fun multiply(a: u64, b: u64): u64 {
        // TODO: å®ç°
    }
    
    // é™¤æ³•ï¼ˆéœ€è¦æ£€æŸ¥é™¤é›¶ï¼‰
    public fun divide(a: u64, b: u64): u64 {
        // TODO: å®ç°
    }
    
    // æ±‚ä½™
    public fun modulo(a: u64, b: u64): u64 {
        // TODO: å®ç°
    }
}
```

### é”™è¯¯ç å®šä¹‰

```move
const E_DIVISION_BY_ZERO: u64 = 1;
const E_SUBTRACTION_UNDERFLOW: u64 = 2;
```

### æµ‹è¯•ç”¨ä¾‹

```move
#[test]
fun test_add() {
    assert!(add(5, 3) == 8, 0);
    assert!(add(0, 0) == 0, 1);
}

#[test]
fun test_subtract() {
    assert!(subtract(10, 3) == 7, 0);
    assert!(subtract(5, 5) == 0, 1);
}

#[test]
#[expected_failure(abort_code = E_SUBTRACTION_UNDERFLOW)]
fun test_subtract_underflow() {
    subtract(3, 10);  // åº”è¯¥å¤±è´¥
}

#[test]
fun test_multiply() {
    assert!(multiply(4, 5) == 20, 0);
    assert!(multiply(0, 100) == 0, 1);
}

#[test]
fun test_divide() {
    assert!(divide(10, 2) == 5, 0);
    assert!(divide(7, 3) == 2, 1);  // æ•´æ•°é™¤æ³•
}

#[test]
#[expected_failure(abort_code = E_DIVISION_BY_ZERO)]
fun test_divide_by_zero() {
    divide(10, 0);  // åº”è¯¥å¤±è´¥
}

#[test]
fun test_modulo() {
    assert!(modulo(10, 3) == 1, 0);
    assert!(modulo(8, 4) == 0, 1);
}
```

### è¯„åˆ†æ ‡å‡†

- å‡½æ•°æ­£ç¡®å®ç°ï¼š9 åˆ†ï¼ˆæ¯ä¸ªå‡½æ•° 1.5 åˆ†ï¼‰
- é”™è¯¯æ£€æŸ¥å®Œæ•´ï¼š3 åˆ†
- æ‰€æœ‰æµ‹è¯•é€šè¿‡ï¼š3 åˆ†

---

## ç¼–ç¨‹é¢˜ 2ï¼šå­¦ç”Ÿæˆç»©ç®¡ç†ï¼ˆ20 åˆ†ï¼‰

### é¢˜ç›®æè¿°

å®ç°ä¸€ä¸ªå­¦ç”Ÿæˆç»©ç®¡ç†ç³»ç»Ÿï¼Œå­¦ç”Ÿå¯ä»¥æ³¨å†Œå¹¶è®°å½•è‡ªå·±çš„æˆç»©ã€‚

### ç»“æ„ä½“å®šä¹‰

```move
struct StudentRecord has key {
    name: string::String,
    scores: vector<u64>,     // å„ç§‘æˆç»©
    total_courses: u64       // è¯¾ç¨‹æ€»æ•°
}
```

### è¦æ±‚å®ç°çš„å‡½æ•°

```move
module my_addr::student_system {
    use std::signer;
    use std::string::{Self, String};
    use std::vector;
    
    struct StudentRecord has key {
        name: String,
        scores: vector<u64>,
        total_courses: u64
    }
    
    const E_STUDENT_ALREADY_EXISTS: u64 = 1;
    const E_STUDENT_NOT_FOUND: u64 = 2;
    const E_INVALID_SCORE: u64 = 3;
    
    // æ³¨å†Œå­¦ç”Ÿ
    public fun register(account: &signer, name: vector<u8>) {
        // TODO: å®ç°
        // 1. æ£€æŸ¥æ˜¯å¦å·²æ³¨å†Œ
        // 2. åˆ›å»º StudentRecord
        // 3. å­˜å‚¨åˆ°å…¨å±€å­˜å‚¨
    }
    
    // æ·»åŠ æˆç»©ï¼ˆ0-100åˆ†ï¼‰
    public fun add_score(account: &signer, score: u64) {
        // TODO: å®ç°
        // 1. æ£€æŸ¥æˆç»©èŒƒå›´
        // 2. æ·»åŠ åˆ° scores å‘é‡
        // 3. æ›´æ–°è¯¾ç¨‹æ€»æ•°
    }
    
    // è®¡ç®—å¹³å‡åˆ†
    public fun get_average(addr: address): u64 {
        // TODO: å®ç°
        // å¦‚æœæ²¡æœ‰æˆç»©ï¼Œè¿”å› 0
    }
    
    // è·å–æœ€é«˜åˆ†
    public fun get_highest_score(addr: address): u64 {
        // TODO: å®ç°
        // å¦‚æœæ²¡æœ‰æˆç»©ï¼Œè¿”å› 0
    }
    
    // è·å–è¯¾ç¨‹æ€»æ•°
    public fun get_course_count(addr: address): u64 {
        // TODO: å®ç°
    }
    
    // æ£€æŸ¥æ˜¯å¦å­˜åœ¨
    public fun exists_student(addr: address): bool {
        // TODO: å®ç°
    }
}
```

### æµ‹è¯•ç”¨ä¾‹

```move
#[test(student = @0x1)]
fun test_register(student: &signer) {
    register(student, b"Alice");
    let addr = signer::address_of(student);
    assert!(exists_student(addr), 0);
}

#[test(student = @0x1)]
fun test_add_score(student: &signer) acquires StudentRecord {
    register(student, b"Bob");
    let addr = signer::address_of(student);
    
    add_score(student, 85);
    add_score(student, 90);
    add_score(student, 95);
    
    assert!(get_course_count(addr) == 3, 0);
}

#[test(student = @0x1)]
fun test_average(student: &signer) acquires StudentRecord {
    register(student, b"Charlie");
    let addr = signer::address_of(student);
    
    add_score(student, 80);
    add_score(student, 90);
    add_score(student, 100);
    
    // å¹³å‡åˆ† = (80 + 90 + 100) / 3 = 90
    assert!(get_average(addr) == 90, 0);
}

#[test(student = @0x1)]
fun test_highest_score(student: &signer) acquires StudentRecord {
    register(student, b"David");
    let addr = signer::address_of(student);
    
    add_score(student, 75);
    add_score(student, 88);
    add_score(student, 92);
    
    assert!(get_highest_score(addr) == 92, 0);
}

#[test(student = @0x1)]
#[expected_failure(abort_code = E_INVALID_SCORE)]
fun test_invalid_score(student: &signer) acquires StudentRecord {
    register(student, b"Eve");
    add_score(student, 101);  // è¶…è¿‡100åˆ†
}
```

### è¯„åˆ†æ ‡å‡†

- ç»“æ„ä½“å®šä¹‰æ­£ç¡®ï¼š2 åˆ†
- register å‡½æ•°æ­£ç¡®ï¼š3 åˆ†
- add_score å‡½æ•°æ­£ç¡®ï¼š3 åˆ†
- get_average å‡½æ•°æ­£ç¡®ï¼š4 åˆ†
- get_highest_score å‡½æ•°æ­£ç¡®ï¼š4 åˆ†
- å…¶ä»–è¾…åŠ©å‡½æ•°ï¼š2 åˆ†
- æµ‹è¯•é€šè¿‡ï¼š2 åˆ†

---

## ç¼–ç¨‹é¢˜ 3ï¼šç®€å•æŠ•ç¥¨ç³»ç»Ÿï¼ˆ15 åˆ†ï¼‰

### é¢˜ç›®æè¿°

å®ç°ä¸€ä¸ªç®€å•çš„æŠ•ç¥¨ç³»ç»Ÿï¼Œç”¨æˆ·å¯ä»¥åˆ›å»ºææ¡ˆå¹¶æŠ•ç¥¨ã€‚

### ç»“æ„ä½“å®šä¹‰

```move
struct Proposal has key {
    title: string::String,
    yes_votes: u64,
    no_votes: u64,
    voters: vector<address>  // å·²æŠ•ç¥¨çš„åœ°å€
}
```

### è¦æ±‚å®ç°çš„å‡½æ•°

```move
module my_addr::voting {
    use std::signer;
    use std::string::{Self, String};
    use std::vector;
    
    struct Proposal has key {
        title: String,
        yes_votes: u64,
        no_votes: u64,
        voters: vector<address>
    }
    
    const E_PROPOSAL_ALREADY_EXISTS: u64 = 1;
    const E_PROPOSAL_NOT_FOUND: u64 = 2;
    const E_ALREADY_VOTED: u64 = 3;
    
    // åˆ›å»ºææ¡ˆ
    public fun create_proposal(account: &signer, title: vector<u8>) {
        // TODO: å®ç°
    }
    
    // æŠ•èµæˆç¥¨
    public fun vote_yes(voter: &signer, proposal_addr: address) {
        // TODO: å®ç°
        // 1. æ£€æŸ¥æ˜¯å¦å·²æŠ•ç¥¨
        // 2. å¢åŠ  yes_votes
        // 3. è®°å½•æŠ•ç¥¨è€…åœ°å€
    }
    
    // æŠ•åå¯¹ç¥¨
    public fun vote_no(voter: &signer, proposal_addr: address) {
        // TODO: å®ç°
    }
    
    // è·å–æŠ•ç¥¨ç»“æœ
    public fun get_votes(addr: address): (u64, u64) {
        // TODO: å®ç°
        // è¿”å› (yes_votes, no_votes)
    }
    
    // æ£€æŸ¥æ˜¯å¦å·²æŠ•ç¥¨
    public fun has_voted(proposal_addr: address, voter: address): bool {
        // TODO: å®ç°
    }
}
```

### æµ‹è¯•ç”¨ä¾‹

```move
#[test(creator = @0x1, voter1 = @0x2, voter2 = @0x3)]
fun test_voting(
    creator: &signer,
    voter1: &signer,
    voter2: &signer
) acquires Proposal {
    // åˆ›å»ºææ¡ˆ
    create_proposal(creator, b"Should we upgrade?");
    let proposal_addr = signer::address_of(creator);
    
    // æŠ•ç¥¨
    vote_yes(voter1, proposal_addr);
    vote_yes(voter2, proposal_addr);
    
    let (yes, no) = get_votes(proposal_addr);
    assert!(yes == 2, 0);
    assert!(no == 0, 1);
}

#[test(creator = @0x1, voter = @0x2)]
fun test_mixed_votes(
    creator: &signer,
    voter: &signer
) acquires Proposal {
    create_proposal(creator, b"New feature?");
    let proposal_addr = signer::address_of(creator);
    
    vote_yes(voter, proposal_addr);
    
    let (yes, no) = get_votes(proposal_addr);
    assert!(yes == 1 && no == 0, 0);
}

#[test(creator = @0x1, voter = @0x2)]
#[expected_failure(abort_code = E_ALREADY_VOTED)]
fun test_double_vote(
    creator: &signer,
    voter: &signer
) acquires Proposal {
    create_proposal(creator, b"Test");
    let proposal_addr = signer::address_of(creator);
    
    vote_yes(voter, proposal_addr);
    vote_yes(voter, proposal_addr);  // åº”è¯¥å¤±è´¥
}
```

### è¯„åˆ†æ ‡å‡†

- ç»“æ„ä½“å®šä¹‰æ­£ç¡®ï¼š2 åˆ†
- create_proposal æ­£ç¡®ï¼š3 åˆ†
- vote_yes/vote_no æ­£ç¡®ï¼š5 åˆ†
- é˜²æ­¢é‡å¤æŠ•ç¥¨ï¼š3 åˆ†
- å…¶ä»–è¾…åŠ©å‡½æ•°ï¼š2 åˆ†

---

## æäº¤è¯´æ˜

### æ–‡ä»¶ç»“æ„

```
03_æ¯æ—¥è€ƒè¯•/
â””â”€â”€ ä½ çš„ç­”æ¡ˆ/
    â”œâ”€â”€ Move.toml
    â””â”€â”€ sources/
        â”œâ”€â”€ calculator.move
        â”œâ”€â”€ student_system.move
        â””â”€â”€ voting.move
```

### æµ‹è¯•æ–¹æ³•

```bash
# æµ‹è¯•æ‰€æœ‰é¢˜ç›®
aptos move test

# æµ‹è¯•å•ä¸ªé¢˜ç›®
aptos move test --filter calculator
aptos move test --filter student
aptos move test --filter voting
```

---

## è¯„åˆ†æ±‡æ€»

| é¢˜ç›® | åˆ†æ•° | ä½ çš„å¾—åˆ† |
|------|------|----------|
| ç¼–ç¨‹é¢˜ 1 | 15 |  |
| ç¼–ç¨‹é¢˜ 2 | 20 |  |
| ç¼–ç¨‹é¢˜ 3 | 15 |  |
| **æ€»åˆ†** | **50** |  |

**åŠæ ¼çº¿**ï¼š35 åˆ†ï¼ˆ70%ï¼‰  
**ä¼˜ç§€çº¿**ï¼š45 åˆ†ï¼ˆ90%ï¼‰

---

## ğŸ’¡ è§£é¢˜æç¤º

### ç¼–ç¨‹é¢˜ 1
- ä½¿ç”¨ `assert!` è¿›è¡Œé”™è¯¯æ£€æŸ¥
- å‡æ³•å‰è¦æ£€æŸ¥ `a >= b`
- é™¤æ³•å‰è¦æ£€æŸ¥ `b != 0`

### ç¼–ç¨‹é¢˜ 2
- ä½¿ç”¨ `vector::push_back` æ·»åŠ æˆç»©
- è®¡ç®—å¹³å‡åˆ†æ—¶æ³¨æ„é™¤é›¶æƒ…å†µ
- éå†å‘é‡æ‰¾æœ€é«˜åˆ†å¯ä½¿ç”¨å¾ªç¯

### ç¼–ç¨‹é¢˜ 3
- ä½¿ç”¨ `vector::contains` æ£€æŸ¥æ˜¯å¦å·²æŠ•ç¥¨
- æ³¨æ„ `acquires` å£°æ˜
- æŠ•ç¥¨åè¦å°†æŠ•ç¥¨è€…åœ°å€åŠ å…¥ voters å‘é‡

---

## å¸¸è§é”™è¯¯

âŒ **é”™è¯¯ 1**ï¼šå¿˜è®°é”™è¯¯æ£€æŸ¥
```move
public fun divide(a: u64, b: u64): u64 {
    a / b  // å¦‚æœ b == 0 ä¼šè¿è¡Œæ—¶é”™è¯¯ï¼
}
```

âŒ **é”™è¯¯ 2**ï¼šå¿˜è®° acquires å£°æ˜
```move
public fun get_average(addr: address): u64 {
    let record = borrow_global<StudentRecord>(addr);  // ç¼ºå°‘ acquires
    // ...
}
```

âŒ **é”™è¯¯ 3**ï¼šå‘é‡æ“ä½œé”™è¯¯
```move
// é”™è¯¯ï¼šç©ºå‘é‡æ—¶ä¼š panic
let first = *vector::borrow(&scores, 0);

// æ­£ç¡®ï¼šå…ˆæ£€æŸ¥é•¿åº¦
if (vector::length(&scores) > 0) {
    let first = *vector::borrow(&scores, 0);
}
```

âœ… **æ­£ç¡®åšæ³•**ï¼š
```move
public fun divide(a: u64, b: u64): u64 {
    assert!(b != 0, E_DIVISION_BY_ZERO);
    a / b
}

public fun get_average(addr: address): u64 acquires StudentRecord {
    let record = borrow_global<StudentRecord>(addr);
    if (vector::length(&record.scores) == 0) {
        return 0
    };
    // è®¡ç®—å¹³å‡åˆ†...
}
```

---

**é¢„è®¡å®Œæˆæ—¶é—´**ï¼š30 åˆ†é’Ÿ  
**å®é™…ç”¨æ—¶**ï¼š________

ç­”æ¡ˆå’Œè¯¦ç»†è§£æè¯·å‚è€ƒ `ç­”æ¡ˆè§£æ.md`

åŠ æ²¹ï¼ğŸ’ª

# AMM 原理与恒定乘积公式 - 核心概念

## 📚 目录

1. [AMM 简介](#1-amm-简介)
2. [恒定乘积公式](#2-恒定乘积公式)
3. [流动性管理](#3-流动性管理)
4. [价格发现机制](#4-价格发现机制)
5. [价格影响分析](#5-价格影响分析)
6. [手续费机制](#6-手续费机制)
7. [实际应用案例](#7-实际应用案例)

---

## 1. AMM 简介

### 1.1 什么是自动做市商（AMM）？

**自动做市商（Automated Market Maker，AMM）** 是一种去中心化交易协议，它使用数学公式来定价资产，而不是传统的订单簿模式。

### 1.2 传统订单簿 vs AMM

#### 传统订单簿（Order Book）

```
买单（Bids）              卖单（Asks）
价格    数量              价格    数量
────────────────────────────────────
$99.90  10 ETH           $100.10  15 ETH
$99.80  20 ETH           $100.20  25 ETH
$99.70  15 ETH           $100.30  10 ETH
```

**特点**：
- ✅ 价格发现精确
- ✅ 适合高频交易
- ❌ 需要活跃的做市商
- ❌ 流动性可能不足
- ❌ 复杂的撮合引擎

#### AMM 模式

```
流动性池
──────────────────
代币 A: 1,000,000
代币 B: 1,000,000
价格 = B/A = 1.0
──────────────────
```

**特点**：
- ✅ 始终有流动性
- ✅ 任何人都可以提供流动性
- ✅ 简单的数学公式
- ❌ 大额交易价格滑点
- ❌ 无常损失风险

### 1.3 AMM 的历史

```
2017 - Bancor Protocol
  └─> 首个 AMM 实现

2018 - Uniswap V1
  └─> 恒定乘积公式 (x * y = k)
  └─> 简化设计，ETH 作为中介

2020 - Uniswap V2
  └─> 任意 ERC20 交易对
  └─> 价格预言机
  └─> 闪电兑换

2021 - Uniswap V3
  └─> 集中流动性
  └─> 多级手续费

2022 - Aptos 生态 AMM
  └─> Liquidswap (Pontem)
  └─> Pancake Swap
  └─> Thala
```

### 1.4 为什么需要 AMM？

**传统金融的痛点**：
1. **流动性碎片化** - 不同交易所价格不一致
2. **中心化风险** - 交易所可能跑路或被黑
3. **准入门槛高** - 做市商需要大量资金和技术
4. **审查风险** - 账户可能被冻结

**AMM 的解决方案**：
1. **去中心化** - 智能合约管理，无需信任
2. **无需许可** - 任何人都可以提供流动性
3. **始终在线** - 24/7 交易，无需人工做市
4. **可组合性** - 可以与其他 DeFi 协议集成

---

## 2. 恒定乘积公式

### 2.1 核心公式

```
x * y = k

其中：
x = 流动性池中代币 X 的储备量
y = 流动性池中代币 Y 的储备量
k = 恒定乘积（常数）
```

### 2.2 公式推导

#### 初始状态

假设流动性池初始有：
- 1,000 个代币 A
- 2,000 个代币 B

```
x₀ = 1,000
y₀ = 2,000
k = x₀ * y₀ = 1,000 * 2,000 = 2,000,000
```

#### 交易过程

用户想用 100 个代币 A 兑换代币 B：

**步骤 1**：计算新的 x
```
x₁ = x₀ + Δx = 1,000 + 100 = 1,100
```

**步骤 2**：根据 k 不变，计算新的 y
```
x₁ * y₁ = k
1,100 * y₁ = 2,000,000
y₁ = 2,000,000 / 1,100 ≈ 1,818.18
```

**步骤 3**：计算输出量
```
Δy = y₀ - y₁ = 2,000 - 1,818.18 = 181.82
```

**结果**：用户用 100 个代币 A 换到 181.82 个代币 B

### 2.3 交换公式推导

从 `x * y = k` 推导出交换公式：

```
已知：
x₀ * y₀ = k
(x₀ + Δx) * (y₀ - Δy) = k

因此：
(x₀ + Δx) * (y₀ - Δy) = x₀ * y₀

展开：
x₀*y₀ - x₀*Δy + Δx*y₀ - Δx*Δy = x₀*y₀

简化：
-x₀*Δy + Δx*y₀ - Δx*Δy = 0

移项：
Δx*y₀ = x₀*Δy + Δx*Δy
Δx*y₀ = Δy*(x₀ + Δx)

最终公式：
Δy = (Δx * y₀) / (x₀ + Δx)
```

### 2.4 数学特性

#### 特性 1：价格曲线是双曲线

```
y = k / x
```

这是一个双曲线，具有以下特点：
- 当 x → 0 时，y → ∞
- 当 x → ∞ 时，y → 0
- 曲线永远不会触及坐标轴

```
y
│
│     ╱
│    ╱
│   ╱
│  ╱
│ ╱
│╱___________
└────────────── x
```

#### 特性 2：边际价格递增

每增加相同的输入，获得的输出递减：

```
输入 A    获得 B    边际汇率
──────────────────────────
100      181.82    1.818
100      158.73    1.587  ⬇️
100      140.06    1.401  ⬇️
100      124.49    1.245  ⬇️
```

这意味着**大额交易的价格比小额交易更差**。

#### 特性 3：对称性

从 A 到 B 的交换和从 B 到 A 的交换具有对称性：

```
如果：100 A → 181.82 B
那么：181.82 B → 100 A
```

### 2.5 实际计算示例

#### 示例 1：基础交换

**初始状态**：
- 储备 A: 10,000
- 储备 B: 20,000
- k = 200,000,000

**交易**：用 500 A 换 B

```
Δy = (500 * 20,000) / (10,000 + 500)
   = 10,000,000 / 10,500
   ≈ 952.38 B
```

**新状态**：
- 储备 A: 10,500
- 储备 B: 19,047.62
- k = 10,500 * 19,047.62 = 200,000,010 ≈ 200,000,000 ✅

#### 示例 2：连续交易

**初始**：x = 1000, y = 1000, k = 1,000,000

**交易 1**：100 x → ? y
```
Δy₁ = (100 * 1000) / 1100 = 90.91 y
新状态：x = 1100, y = 909.09
```

**交易 2**：再用 100 x → ? y
```
Δy₂ = (100 * 909.09) / 1200 = 75.76 y
新状态：x = 1200, y = 833.33
```

**观察**：
- 第一次：100 x → 90.91 y（汇率 0.909）
- 第二次：100 x → 75.76 y（汇率 0.758）⬇️

**结论**：连续大额买入导致价格上涨！

---

## 3. 流动性管理

### 3.1 添加流动性

#### 首次添加流动性

当流动性池为空时，第一个 LP（流动性提供者）决定初始价格：

```
用户存入：
  - 1,000 代币 A
  - 2,000 代币 B

铸造 LP Token：
  LP = √(x * y) = √(1,000 * 2,000) = √2,000,000 ≈ 1,414.21

初始价格：
  P = y / x = 2,000 / 1,000 = 2.0
  (1 个 A 值 2 个 B)
```

**为什么用几何平均数（√(x*y)）？**
- 确保 LP Token 数量与流动性成正比
- 避免极端价格操纵
- 数学上更优雅

#### 后续添加流动性

后续 LP 必须按照**当前储备比例**添加流动性：

```
当前池子：
  x = 10,000 A
  y = 20,000 B
  total_lp = 14,142

用户想添加 1,000 A：
  
步骤 1：计算需要的 B
  需要 B = (1,000 / 10,000) * 20,000 = 2,000 B

步骤 2：计算铸造的 LP
  new_lp = (1,000 / 10,000) * 14,142 = 1,414.2 LP
  
  或者：
  new_lp = (2,000 / 20,000) * 14,142 = 1,414.2 LP
  
  两种计算方式结果相同！✅
```

**公式总结**：

```
# 方法 1：基于代币 X
LP_minted = (Δx / x) * total_lp_supply

# 方法 2：基于代币 Y
LP_minted = (Δy / y) * total_lp_supply

# 方法 3：几何平均（仅首次）
LP_minted = √(Δx * Δy)
```

### 3.2 移除流动性

移除流动性时，LP 按比例取回两种代币：

```
池子状态：
  x = 10,000 A
  y = 20,000 B
  total_lp = 14,142

用户销毁 1,414.2 LP：

比例 = 1,414.2 / 14,142 = 10%

取回：
  A = 10% * 10,000 = 1,000 A
  B = 10% * 20,000 = 2,000 B
```

**公式**：

```
amount_x = (lp_burned / total_lp) * reserve_x
amount_y = (lp_burned / total_lp) * reserve_y
```

### 3.3 LP Token 的价值

LP Token 代表流动性池的所有权份额：

```
LP 价值 = (个人 LP / 总 LP) * (储备 A 价值 + 储备 B 价值)
```

**示例**：

```
池子：
  - 10,000 ETH (价格 $2,000) = $20,000,000
  - 20,000,000 USDC = $20,000,000
  - 总价值 = $40,000,000
  - 总 LP = 14,142

你持有 1,414.2 LP：
  你的份额 = 1,414.2 / 14,142 = 10%
  你的价值 = 10% * $40,000,000 = $4,000,000
```

### 3.4 单边流动性问题

**问题**：如果允许单边添加流动性会怎样？

```
当前：
  x = 1,000, y = 2,000
  价格 = 2.0

恶意用户单边添加 1,000 个 x：
  x = 2,000, y = 2,000
  价格 = 1.0  ❌ 价格被操纵！
```

**解决方案**：
1. ✅ **强制双边添加**（Uniswap V2 方式）
2. ✅ **单边添加但自动交换**（某些协议）
3. ✅ **集中流动性**（Uniswap V3）

---

## 4. 价格发现机制

### 4.1 即时价格（Spot Price）

即时价格由储备比例决定：

```
P = y / x

当前池子：
  x = 10,000 APTOS
  y = 20,000 USDC

价格 = 20,000 / 10,000 = 2.0 USDC/APTOS
```

### 4.2 边际价格（Marginal Price）

交易后的价格：

```
P_new = y_new / x_new
```

**示例**：

```
交易前：
  x = 10,000, y = 20,000
  P₀ = 2.0

买入 100 APTOS：
  x = 10,100, y = 19,801.98
  P₁ = 19,801.98 / 10,100 = 1.96 ⬇️

卖出 100 APTOS：
  x = 9,900, y = 20,202.02
  P₂ = 20,202.02 / 9,900 = 2.04 ⬆️
```

### 4.3 平均执行价格

用户实际得到的汇率：

```
平均价格 = Δy / Δx

用 500 APTOS 换 952.38 USDC：
平均价格 = 952.38 / 500 = 1.905 USDC/APTOS
```

注意：平均价格 < 即时价格（买入时）

### 4.4 价格套利机制

AMM 的价格由套利者维持在市场价格附近：

```
假设市场价格：1 APTOS = $2.00

场景 1：AMM 价格低于市场
  AMM: 1 APTOS = $1.90
  
  套利机会：
    1. 在 AMM 用 $1.90 买 1 APTOS
    2. 在 CEX 以 $2.00 卖出
    3. 赚取 $0.10 利润
  
  结果：AMM 价格上涨至 $2.00

场景 2：AMM 价格高于市场
  AMM: 1 APTOS = $2.10
  
  套利机会：
    1. 在 CEX 用 $2.00 买 1 APTOS
    2. 在 AMM 以 $2.10 卖出
    3. 赚取 $0.10 利润
  
  结果：AMM 价格下跌至 $2.00
```

**关键点**：
- 套利者的存在确保 AMM 价格接近市场价格
- 套利者赚取的利润来自流动性提供者
- 这是 AMM 价格发现的核心机制

---

## 5. 价格影响分析

### 5.1 什么是价格影响（Price Impact）？

价格影响是交易导致的价格变化百分比：

```
Price Impact = |P_new - P_old| / P_old * 100%
```

### 5.2 价格影响计算

**示例**：

```
池子：x = 10,000, y = 20,000
初始价格：P₀ = 2.0

买入 1,000 APTOS：
  新储备：x = 11,000, y = 18,181.82
  新价格：P₁ = 18,181.82 / 11,000 = 1.653
  
价格影响 = |1.653 - 2.0| / 2.0 = 17.35% ❌ 太高！
```

### 5.3 价格影响与交易规模

```
交易规模    价格影响
─────────────────────
1%  (100)   0.50%  ✅
5%  (500)   2.44%  ✅
10% (1000)  4.76%  ⚠️
20% (2000)  9.09%  ❌
50% (5000)  20.00% ❌❌
```

**规律**：
- 交易规模越大，价格影响越大
- 价格影响是**非线性**的
- 一般建议价格影响 < 1%

### 5.4 滑点（Slippage）

滑点是预期价格与实际执行价格的差异：

```
预期汇率：2.0
实际汇率：1.905
滑点 = (2.0 - 1.905) / 2.0 = 4.75%
```

**滑点保护**：

```move
// 用户设置最小输出量
let min_output = 900; // 最少接受 900 USDC

// 实际输出
let actual_output = 952.38;

assert!(actual_output >= min_output, ERROR_SLIPPAGE_TOO_HIGH);
```

### 5.5 流动性深度

流动性深度越大，价格影响越小：

```
池子 A：x = 1,000, y = 2,000, k = 2,000,000
池子 B：x = 100,000, y = 200,000, k = 20,000,000,000

都买入 100 个 x：

池子 A：
  Δy = (100 * 2,000) / 1,100 = 181.82
  价格影响 = 9.09% ❌

池子 B：
  Δy = (100 * 200,000) / 100,100 = 199.80
  价格影响 = 0.10% ✅
```

**结论**：流动性深度提高 100 倍，价格影响降低约 90 倍！

---

## 6. 手续费机制

### 6.1 交易手续费

大多数 AMM 收取 0.3% 的交易手续费：

```
用户输入：1,000 代币 A

扣除手续费：
  手续费 = 1,000 * 0.3% = 3
  实际用于交换 = 997

输出计算：
  Δy = (997 * y) / (x + 997)
```

### 6.2 手续费分配

手续费通常分配给流动性提供者：

```
交易手续费 = 0.3%
  ├─ LP 收益：0.25%
  └─ 协议收益：0.05%
```

### 6.3 LP 收益累积

手续费不会分发，而是**直接添加到储备中**：

```
初始：
  x = 10,000, y = 20,000
  total_lp = 14,142

交易后（包含手续费）：
  x = 10,500, y = 19,000
  total_lp = 14,142 (不变)

LP 价值增加：
  旧 k = 10,000 * 20,000 = 200,000,000
  新 k = 10,500 * 19,000 = 199,500,000
  
  等等，k 变小了？❌
```

**正确的手续费处理**：

```
交易输入：1,000（含 3 手续费）

步骤 1：扣除手续费
  实际交换 = 997
  手续费留在池子 = 3

步骤 2：计算输出
  Δy = (997 * 20,000) / (10,000 + 997) = 1,811.78

步骤 3：更新储备
  x = 10,000 + 1,000 = 11,000 (包含手续费)
  y = 20,000 - 1,811.78 = 18,188.22

新 k：
  k = 11,000 * 18,188.22 = 200,070,420 > 200,000,000 ✅
```

k 增加了！这就是 LP 收益的来源。

### 6.4 LP 收益计算

```
初始投入：
  1,000 A + 2,000 B = $4,000 (假设都是 $1)
  获得 1,414.2 LP

一段时间后：
  总储备：11,000 A + 22,000 B
  总 LP：14,142
  
你的份额：1,414.2 / 14,142 = 10%

取回：
  A = 10% * 11,000 = 1,100
  B = 10% * 22,000 = 2,200
  总价值 = $3,300

收益：
  名义收益 = $3,300 - $4,000 = -$700 ❌
  
  但需要考虑价格变化和无常损失！
```

---

## 7. 实际应用案例

### 7.1 案例 1：APTOS/USDC 交易对

```
初始流动性：
  100,000 APTOS @ $10 = $1,000,000
  1,000,000 USDC = $1,000,000
  总 TVL = $2,000,000
  
初始价格：
  P = 1,000,000 / 100,000 = $10/APTOS
  k = 100,000,000,000

用户交易：买入 1,000 APTOS

计算：
  输入 USDC (含 0.3% 手续费):
  设需要 x USDC
  
  交换公式：
  1,000 = (x * 0.997 * 100,000) / (1,000,000 + x * 0.997)
  
  解方程：
  1,000 * (1,000,000 + 0.997x) = 99,700x
  1,000,000,000 + 997x = 99,700x
  1,000,000,000 = 98,703x
  x ≈ 10,131.27 USDC

实际支付：10,131.27 USDC
手续费：30.39 USDC
平均价格：10.13 USDC/APTOS
价格影响：1.31%
```

### 7.2 案例 2：流动性挖矿

```
LP 提供流动性：
  日期：2024-01-01
  投入：10,000 APTOS + 100,000 USDC
  价格：$10/APTOS
  获得：10,000 LP Token

30 天后：
  池子增长：
    APTOS: 110,000 (由于交易)
    USDC: 1,100,000
    总 LP: 110,000
  
  你的份额：10,000 / 110,000 = 9.09%
  
  取回：
    APTOS: 9.09% * 110,000 = 10,000
    USDC: 9.09% * 1,100,000 = 100,000
  
  APTOS 价格涨到 $11：
    价值 = 10,000 * $11 + 100,000 = $210,000
    
  如果持有不动：
    价值 = 10,000 * $11 + 100,000 = $210,000
  
  手续费收益：
    池子 k 增长 = 额外的交易手续费
```

### 7.3 案例 3：无常损失（Impermanent Loss）

**什么是无常损失？**

当资产价格变化时，LP 的价值可能低于单纯持有代币。

```
初始：
  投入：1 ETH ($2,000) + 2,000 USDC
  总价值：$4,000
  LP份额：100%

ETH 涨到 $4,000：

AMM 池子（自动再平衡）：
  k = 1 * 2,000 = 2,000
  新价格：4,000
  
  x * y = 2,000
  y / x = 4,000
  
  解方程：
  x = √(2,000 / 4,000) = 0.707 ETH
  y = √(2,000 * 4,000) = 2,828 USDC
  
  LP 价值：
    0.707 ETH * $4,000 + 2,828 USDC = $5,656

单纯持有：
  1 ETH * $4,000 + 2,000 USDC = $6,000

无常损失：
  $6,000 - $5,656 = $344
  损失率 = $344 / $6,000 = 5.74%
```

**无常损失公式**：

```
价格变化倍数 p = P_new / P_old

无常损失 = 2 * √p / (1 + p) - 1
```

**不同价格变化的无常损失**：

```
价格变化    无常损失
─────────────────────
1.25x      0.6%
1.50x      2.0%
1.75x      3.8%
2.00x      5.7%
3.00x      13.4%
4.00x      20.0%
5.00x      25.5%
```

**如何降低无常损失？**

1. ✅ 选择稳定币对（如 USDC/USDT）
2. ✅ 选择相关资产（如 ETH/stETH）
3. ✅ 通过手续费补偿损失
4. ✅ 使用 Curve 等稳定币专用 AMM

---

## 📊 公式速查表

### 基础公式

```
1. 恒定乘积
   x * y = k

2. 交换输出
   Δy = (Δx * y) / (x + Δx)

3. 含手续费的交换
   Δy = (Δx * (1-fee) * y) / (x + Δx * (1-fee))

4. 即时价格
   P = y / x

5. 添加流动性（首次）
   LP = √(Δx * Δy)

6. 添加流动性（后续）
   LP = (Δx / x) * total_lp

7. 移除流动性
   amount_x = (lp / total_lp) * x
   amount_y = (lp / total_lp) * y

8. 价格影响
   Impact = |P_new - P_old| / P_old

9. 无常损失
   IL = 2√p / (1+p) - 1
   其中 p = P_new / P_old
```

---

## 🎯 实战练习

### 练习 1：基础交换

```
池子：10,000 APTOS, 50,000 USDC
问题：用 500 APTOS 能换多少 USDC？

你的答案：__________
```

<details>
<summary>查看答案</summary>

```
Δy = (500 * 50,000) / (10,000 + 500)
   = 25,000,000 / 10,500
   ≈ 2,380.95 USDC
```
</details>

### 练习 2：添加流动性

```
池子：10,000 APTOS, 50,000 USDC, 22,360 LP
问题：添加 1,000 APTOS 需要多少 USDC？能获得多少 LP？

你的答案：
USDC: __________
LP: __________
```

<details>
<summary>查看答案</summary>

```
需要的 USDC = (1,000 / 10,000) * 50,000 = 5,000 USDC
获得的 LP = (1,000 / 10,000) * 22,360 = 2,236 LP
```
</details>

### 练习 3：价格影响

```
池子：10,000 APTOS, 50,000 USDC
问题：买入 2,000 APTOS 的价格影响是多少？

你的答案：__________
```

<details>
<summary>查看答案</summary>

```
初始价格：50,000 / 10,000 = 5.0

买入后：
x = 12,000, y = 50,000 * 10,000 / 12,000 = 41,666.67
新价格 = 41,666.67 / 12,000 = 3.47

价格影响 = |3.47 - 5.0| / 5.0 = 30.6% ❌ 太高了！
```
</details>

---

## 🔑 关键要点总结

1. **恒定乘积公式** 
   - x * y = k 是 AMM 的核心
   - k 保持恒定（忽略手续费）
   - 交易越大，价格滑点越大

2. **流动性管理**
   - 首次添加用几何平均数
   - 后续添加必须按比例
   - LP Token 代表流动性份额

3. **价格机制**
   - 价格由储备比例决定
   - 套利者维持价格平衡
   - 价格影响与流动性深度成反比

4. **手续费**
   - 通常 0.3%
   - 直接添加到储备
   - LP 通过 k 增长获利

5. **无常损失**
   - 价格变化导致
   - 可通过手续费补偿
   - 稳定币对损失最小

---

## 📚 延伸阅读

1. [Uniswap V2 Core 源码](https://github.com/Uniswap/v2-core)
2. [An analysis of Uniswap markets](https://arxiv.org/abs/1911.03380)
3. [Impermanent Loss 深度解析](https://medium.com/@pintail/uniswap-a-good-deal-for-liquidity-providers)
4. [AMM 数学推导](https://www.paradigm.xyz/2021/04/understanding-automated-market-makers-part-1)

---

**恭喜！** 你已经掌握了 AMM 的核心原理。现在让我们进入代码实现环节！💪

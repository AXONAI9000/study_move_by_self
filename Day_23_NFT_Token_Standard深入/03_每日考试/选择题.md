# Day 23 每日考试 - 选择题

## 第一部分：基础概念（每题5分，共40分）

### 1. Aptos Token Standard v2 的核心特性是什么？
A. 使用账户模型存储 NFT  
B. 基于 Object Model 实现  
C. 不支持版税功能  
D. 必须使用固定供应量  

**答案：B**

---

### 2. 以下关于 Collection 的说法，哪个是正确的？
A. Collection 只能设置固定供应量  
B. Collection 创建后无法修改任何信息  
C. Collection 可以配置版税信息  
D. 一个地址只能创建一个 Collection  

**答案：C**

---

### 3. `collection::create_fixed_collection` 和 `collection::create_unlimited_collection` 的主要区别是？
A. 前者必须设置版税，后者不能  
B. 前者有最大供应量限制，后者没有  
C. 前者不能修改 URI，后者可以  
D. 没有本质区别  

**答案：B**

---

### 4. 在 Aptos Token v2 中，Token 的所有权如何表示？
A. 通过 `TokenStore` 资源存储在账户下  
B. 通过 Object 的 owner 字段  
C. 存储在 Collection 的映射表中  
D. 通过事件记录  

**答案：B**

---

### 5. 以下哪个引用（Ref）用于修改 Token 的元数据？
A. `TransferRef`  
B. `DeleteRef`  
C. `MutatorRef`  
D. `ExtendRef`  

**答案：C**

---

### 6. Property Map 不支持以下哪种数据类型？
A. `u64`  
B. `String`  
C. `vector<String>`  
D. `address`  

**答案：C**

---

### 7. 版税（Royalty）的计算公式是？
A. price * royalty_percentage  
B. price * (royalty_numerator / royalty_denominator)  
C. price / royalty_denominator  
D. price + royalty_numerator  

**答案：B**

---

### 8. 以下关于 `DeleteRef` 的说法，哪个是正确的？
A. 任何人都可以使用 DeleteRef 销毁 Token  
B. DeleteRef 只能由 Token 创建者持有  
C. DeleteRef 存储在 Token 对象中，可以被转移  
D. 销毁 Token 不会影响 Collection 的统计信息  

**答案：C**

---

## 第二部分：进阶知识（每题5分，共30分）

### 9. 以下代码的作用是什么？
```move
let constructor_ref = token::create_named_token(
    creator,
    collection_name,
    description,
    name,
    option::none(),
    uri,
);
```
A. 创建一个使用 Token 特定版税的 NFT  
B. 创建一个继承 Collection 版税的 NFT  
C. 创建一个没有版税的 NFT  
D. 创建一个可转移的 NFT  

**答案：B**

---

### 10. 如何禁止 Token 的自由转移？
A. 不生成 `TransferRef`  
B. 调用 `object::disable_ungated_transfer`  
C. 设置 `transferable` 属性为 false  
D. A 和 B 都可以  

**答案：D**

---

### 11. 以下哪个函数可以获取 Collection 的地址？
A. `collection::get_address`  
B. `collection::create_collection_address`  
C. `object::collection_address`  
D. `token::get_collection`  

**答案：B**

---

### 12. Property Map 更新操作需要什么权限？
A. Token 的当前所有者  
B. Token 的创建者  
C. 持有 `PropertyMutatorRef` 的账户  
D. Collection 的创建者  

**答案：C**

---

### 13. 以下关于 `ExtendRef` 的说法，哪个是错误的？
A. 可以从 Object 生成 Signer  
B. 可以用于修改 Object 的数据  
C. 可以转移 Object 的所有权  
D. 可以存储在 Object 内部  

**答案：C**

---

### 14. Token 的唯一标识符是什么？
A. Token 名称  
B. Token 的 Object 地址  
C. Collection 名称 + Token 名称  
D. Token 的 URI  

**答案：B**

---

## 第三部分：实战应用（每题10分，共30分）

### 15. 以下代码有什么问题？
```move
public entry fun mint_nft(
    creator: &signer,
    collection_name: String,
) {
    let constructor_ref = token::create_named_token(
        creator,
        collection_name,
        string::utf8(b"desc"),
        string::utf8(b"token"),
        option::none(),
        string::utf8(b"uri"),
    );
    // 没有其他代码
}
```
A. 没有检查供应量限制  
B. 没有保存必要的引用（Refs）  
C. 没有发出事件  
D. 以上都是  

**答案：D**

---

### 16. 实现带版税的转移时，正确的顺序是？
1. 验证买家余额  
2. 计算版税金额  
3. 转移 Token  
4. 支付卖家  
5. 支付创作者版税  

A. 1-2-3-4-5  
B. 1-3-2-5-4  
C. 1-2-5-4-3  
D. 3-1-2-5-4  

**答案：C**

---

### 17. 以下哪种方式可以实现"灵魂绑定 NFT"（不可转移）？
A. 在创建 Token 时不生成 `TransferRef`  
B. 使用 `object::disable_ungated_transfer` 禁用转移  
C. 在 Property Map 中设置 `soul_bound = true`  
D. A 或 B  

**答案：D**

---

## 第四部分：综合分析（单选，20分）

### 18. 某项目需要实现以下需求：
- NFT 总量 10000 个
- 版税 2.5%
- 支持属性动态更新
- 支持 NFT 升级（修改 URI）
- 记录每次转移历史

以下哪些引用必须保存？
1. `MutatorRef`（Token）  
2. `PropertyMutatorRef`  
3. `TransferRef`  
4. `DeleteRef`  
5. `ExtendRef`  

A. 1, 2, 5  
B. 1, 2, 3, 5  
C. 全部都需要  
D. 1, 2, 4, 5  

**答案：A**

**解析**：
- `MutatorRef`：修改 URI 需要
- `PropertyMutatorRef`：动态更新属性需要
- `ExtendRef`：存储转移历史等额外数据需要
- `TransferRef`：不需要保存，因为允许自由转移
- `DeleteRef`：题目没有销毁需求

---

### 19. 以下代码实现批量铸造，性能最优的是？

**选项 A：**
```move
public entry fun batch_mint_v1(
    creator: &signer,
    collection: String,
    count: u64,
) {
    let i = 0;
    while (i < count) {
        mint_nft(creator, collection, ...);
        i = i + 1;
    };
}
```

**选项 B：**
```move
public entry fun batch_mint_v2(
    creator: &signer,
    collection: String,
    names: vector<String>,
) {
    let stats = borrow_global_mut<CollectionStats>(collection_addr);
    let len = vector::length(&names);
    let i = 0;
    while (i < len) {
        let name = *vector::borrow(&names, i);
        // 创建 Token
        stats.minted_count = stats.minted_count + 1;
        i = i + 1;
    };
}
```

A. 选项 A 更优，因为代码更简洁  
B. 选项 B 更优，因为减少了全局资源访问次数  
C. 两者性能相同  
D. 都不够优化  

**答案：B**

---

### 20. 某 NFT 市场要求实现以下功能：
```
用户 A 拥有 Token #1
用户 B 出价 100 APT
用户 C 出价 150 APT
最终 C 购买成功，需要：
1. C 支付 150 APT
2. 版税 2% = 3 APT 给创作者
3. 147 APT 给 A
4. Token 转移给 C
```

以下哪个实现是正确的？

**选项 A：**
```move
// 先转账，后转 Token
coin::transfer<APT>(buyer, creator, royalty_amount);
coin::transfer<APT>(buyer, seller, seller_amount);
object::transfer(seller_signer, token, buyer_addr);
```

**选项 B：**
```move
// 先转 Token，后转账
object::transfer(seller_signer, token, buyer_addr);
coin::transfer<APT>(buyer, creator, royalty_amount);
coin::transfer<APT>(buyer, seller, seller_amount);
```

A. 选项 A 正确  
B. 选项 B 正确  
C. 两者都正确  
D. 两者都不够安全  

**答案：A**

**解析**：应该先完成资金转移，确保买家支付成功后再转移 Token。这样可以避免 Token 已转移但支付失败的情况。更安全的做法是使用原子化的托管合约。

---

## 答题卡

| 题号 | 答案 | 题号 | 答案 |
|------|------|------|------|
| 1 | B | 11 | B |
| 2 | C | 12 | C |
| 3 | B | 13 | C |
| 4 | B | 14 | B |
| 5 | C | 15 | D |
| 6 | C | 16 | C |
| 7 | B | 17 | D |
| 8 | C | 18 | A |
| 9 | B | 19 | B |
| 10 | D | 20 | A |

---

**总分：100分**  
**及格分数：70分**  
**建议完成时间：45分钟**

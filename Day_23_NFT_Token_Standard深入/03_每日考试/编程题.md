# Day 23 每日考试 - 编程题

## 编程题一：艺术品 NFT Collection（20分）

### 题目描述
创建一个艺术品 NFT Collection 系统，要求：
1. Collection 名称：`Digital Art Gallery`
2. 最大供应量：500
3. 版税：3%（300/10000）
4. 支持创建者修改 Collection 描述和 URI

### 要求实现的功能

```move
module art_nft::gallery {
    use std::string::String;
    use aptos_token_objects::collection;
    use aptos_token_objects::royalty;
    
    /// 创建艺术品 Collection
    public entry fun create_gallery(
        creator: &signer,
        description: String,
        uri: String,
    ) {
        // TODO: 实现此函数
        // 1. 创建固定供应量的 Collection
        // 2. 保存 MutatorRef 用于后续修改
        // 3. 保存统计信息（minted_count, max_supply）
        // 4. 发出 CollectionCreatedEvent
    }
    
    /// 修改 Collection 描述
    public entry fun update_description(
        creator: &signer,
        collection: Object<collection::Collection>,
        new_description: String,
    ) {
        // TODO: 实现此函数
        // 1. 验证调用者是创建者
        // 2. 使用 MutatorRef 修改描述
    }
    
    /// 修改 Collection URI
    public entry fun update_uri(
        creator: &signer,
        collection: Object<collection::Collection>,
        new_uri: String,
    ) {
        // TODO: 实现此函数
    }
    
    /// 查询 Collection 信息
    public fun get_gallery_info(
        collection: Object<collection::Collection>
    ): (String, String, u64, u64) {
        // TODO: 返回 (name, description, minted_count, max_supply)
    }
}
```

### 测试用例
```move
#[test(creator = @0x123)]
public fun test_gallery(creator: &signer) {
    create_gallery(
        creator,
        string::utf8(b"A collection of digital artworks"),
        string::utf8(b"https://gallery.example.com")
    );
    
    let collection_addr = collection::create_collection_address(
        &signer::address_of(creator),
        &string::utf8(b"Digital Art Gallery")
    );
    let collection = object::address_to_object(collection_addr);
    
    let (name, desc, minted, max) = get_gallery_info(collection);
    assert!(minted == 0, 1);
    assert!(max == 500, 2);
    
    // 修改描述
    update_description(
        creator,
        collection,
        string::utf8(b"Updated description")
    );
}
```

### 评分标准
- Collection 创建正确（8分）
- 版税配置正确（3分）
- 引用保存正确（4分）
- 修改功能正确（3分）
- 查询功能正确（2分）

---

## 编程题二：带属性的 NFT 铸造（25分）

### 题目描述
实现一个支持自定义属性的 NFT 铸造系统，每个艺术品 NFT 包含以下属性：
- `artist`: String（艺术家名称）
- `created_year`: u64（创作年份）
- `medium`: String（媒介，如 "Oil on Canvas"）
- `edition`: u64（版本号）
- `is_signed`: bool（是否签名）

### 要求实现的功能

```move
module art_nft::artwork {
    use std::string::String;
    use aptos_token_objects::token;
    use aptos_token_objects::property_map;
    
    /// 铸造带属性的艺术品 NFT
    public entry fun mint_artwork(
        creator: &signer,
        collection_name: String,
        name: String,
        description: String,
        uri: String,
        // 属性
        artist: String,
        created_year: u64,
        medium: String,
        edition: u64,
        is_signed: bool,
    ) {
        // TODO: 实现此函数
        // 1. 检查供应量限制
        // 2. 创建 Token
        // 3. 添加自定义属性
        // 4. 保存必要的引用
        // 5. 更新统计信息
        // 6. 发出事件
    }
    
    /// 更新艺术品展览历史
    public entry fun add_exhibition(
        owner: &signer,
        token: Object<token::Token>,
        exhibition_name: String,
        location: String,
        year: u64,
    ) {
        // TODO: 实现此函数
        // 1. 验证所有权
        // 2. 读取当前 exhibition_count
        // 3. 添加新的展览记录
        // 4. 更新 exhibition_count
    }
    
    /// 查询艺术品信息
    public fun get_artwork_info(
        token: Object<token::Token>
    ): ArtworkInfo {
        // TODO: 实现此函数
    }
    
    struct ArtworkInfo has drop {
        artist: String,
        created_year: u64,
        medium: String,
        edition: u64,
        is_signed: bool,
        owner: address,
    }
}
```

### 测试用例
```move
#[test(creator = @0x123)]
public fun test_artwork_minting(creator: &signer) {
    // 先创建 Collection
    gallery::create_gallery(...);
    
    // 铸造艺术品
    mint_artwork(
        creator,
        string::utf8(b"Digital Art Gallery"),
        string::utf8(b"Starry Night Digital"),
        string::utf8(b"A digital rendition of the famous painting"),
        string::utf8(b"https://example.com/nft/1"),
        string::utf8(b"Vincent van Gogh"),
        1889,
        string::utf8(b"Digital"),
        1,
        true,
    );
    
    // 验证属性
    let token_addr = token::create_token_address(
        &signer::address_of(creator),
        &string::utf8(b"Digital Art Gallery"),
        &string::utf8(b"Starry Night Digital")
    );
    let token = object::address_to_object<token::Token>(token_addr);
    let info = get_artwork_info(token);
    
    assert!(info.artist == string::utf8(b"Vincent van Gogh"), 1);
    assert!(info.created_year == 1889, 2);
    assert!(info.is_signed == true, 3);
}
```

### 评分标准
- Token 创建正确（5分）
- 属性设置正确（10分）
- 展览记录功能（5分）
- 查询功能正确（3分）
- 边界检查（2分）

---

## 编程题三：NFT 交易与版税分配（30分）

### 题目描述
实现一个完整的 NFT 交易系统，支持版税自动分配。

### 要求实现的功能

```move
module art_nft::marketplace {
    use std::signer;
    use aptos_framework::coin;
    use aptos_framework::aptos_coin::AptosCoin;
    use aptos_token_objects::token;
    use aptos_token_objects::royalty;
    
    /// 购买 NFT（带版税分配）
    public entry fun buy_nft(
        buyer: &signer,
        seller: address,
        token: Object<token::Token>,
        price: u64,
    ) {
        // TODO: 实现此函数
        // 1. 验证卖家是当前所有者
        // 2. 验证买家余额充足
        // 3. 获取版税信息
        // 4. 计算版税金额
        // 5. 支付版税给创作者
        // 6. 支付剩余金额给卖家
        // 7. 转移 Token 给买家
        // 8. 更新转移历史
        // 9. 发出交易事件
    }
    
    /// 计算版税金额
    public fun calculate_royalty(
        token: Object<token::Token>,
        price: u64,
    ): (u64, u64) {
        // TODO: 返回 (royalty_amount, seller_amount)
    }
    
    /// 安全转移（验证接收方）
    public entry fun safe_transfer(
        owner: &signer,
        token: Object<token::Token>,
        to: address,
    ) {
        // TODO: 实现此函数
        // 1. 验证所有权
        // 2. 检查接收方地址有效
        // 3. 转移 Token
        // 4. 更新属性（transfer_count++）
        // 5. 发出事件
    }
    
    /// 获取转移历史数量
    public fun get_transfer_count(
        token: Object<token::Token>
    ): u64 {
        // TODO: 从属性中读取 transfer_count
    }
}
```

### 测试用例
```move
#[test(creator = @0x123, buyer = @0x456, seller = @0x789)]
public fun test_marketplace(
    creator: &signer,
    buyer: &signer,
    seller: &signer,
) {
    let buyer_addr = signer::address_of(buyer);
    let seller_addr = signer::address_of(seller);
    
    // 准备账户
    account::create_account_for_test(buyer_addr);
    account::create_account_for_test(seller_addr);
    
    // 给买家充值 1000 APT
    coin::register<AptosCoin>(buyer);
    aptos_coin::mint(buyer_addr, 1000_00000000);
    
    // 创建 Collection 和 Token
    gallery::create_gallery(creator, ...);
    artwork::mint_artwork(creator, ...);
    
    // 转移给卖家
    let token = ...;
    safe_transfer(creator, token, seller_addr);
    
    // 买家购买（价格 100 APT，版税 3%）
    buy_nft(buyer, seller_addr, token, 100_00000000);
    
    // 验证所有权
    assert!(object::is_owner(token, buyer_addr), 1);
    
    // 验证版税支付（3 APT）
    let creator_balance = coin::balance<AptosCoin>(signer::address_of(creator));
    assert!(creator_balance == 3_00000000, 2);
    
    // 验证卖家收入（97 APT）
    let seller_balance = coin::balance<AptosCoin>(seller_addr);
    assert!(seller_balance == 97_00000000, 3);
    
    // 验证转移次数
    assert!(get_transfer_count(token) == 2, 4);
}
```

### 评分标准
- 版税计算正确（8分）
- 资金转移正确（8分）
- Token 转移正确（6分）
- 转移历史记录（4分）
- 权限验证（4分）

---

## 编程题四：批量操作优化（15分）

### 题目描述
实现高效的批量 NFT 铸造功能，要求：
1. 一次交易铸造多个 NFT
2. 优化 gas 消耗
3. 支持批量设置属性

### 要求实现的功能

```move
module art_nft::batch_ops {
    use std::vector;
    use std::string::String;
    
    struct ArtworkData has drop, store {
        name: String,
        description: String,
        uri: String,
        artist: String,
        created_year: u64,
        medium: String,
    }
    
    /// 批量铸造艺术品
    public entry fun batch_mint_artworks(
        creator: &signer,
        collection_name: String,
        artworks: vector<ArtworkData>,
    ) {
        // TODO: 实现此函数
        // 关键：减少重复的全局资源访问
        // 1. 一次性获取 CollectionStats 的可变引用
        // 2. 循环创建 Token
        // 3. 最后一次性更新统计信息
    }
    
    /// 批量设置属性
    public entry fun batch_set_properties(
        owner: &signer,
        tokens: vector<Object<token::Token>>,
        key: String,
        values: vector<u64>,
    ) {
        // TODO: 实现此函数
    }
}
```

### 性能要求
- 铸造 10 个 NFT 的 gas 消耗应小于单独铸造 10 次的 80%
- 不能有重复的全局资源借用

### 评分标准
- 批量铸造功能正确（6分）
- Gas 优化（5分）
- 批量属性设置（4分）

---

## 编程题五：综合项目 - 可升级 NFT（10分）

### 题目描述
实现一个游戏装备 NFT 系统，装备可以升级（提升属性）。

### 要求实现的功能

```move
module game_nft::equipment {
    use std::string::String;
    use aptos_token_objects::token;
    
    /// 铸造装备 NFT
    public entry fun mint_equipment(
        creator: &signer,
        collection_name: String,
        equipment_name: String,
        // 初始属性
        attack: u64,
        defense: u64,
        rarity: u64,  // 1=Common, 2=Rare, 3=Epic, 4=Legendary
    ) {
        // TODO: 实现此函数
        // 初始化属性：attack, defense, rarity, level=1
    }
    
    /// 升级装备
    public entry fun upgrade_equipment(
        owner: &signer,
        token: Object<token::Token>,
    ) {
        // TODO: 实现此函数
        // 1. 验证所有权
        // 2. 读取当前 level
        // 3. 增加 level
        // 4. 提升 attack 和 defense（根据 rarity 计算提升幅度）
        // 5. 更新 URI（显示新的图片）
        // 6. 发出升级事件
    }
    
    /// 查询装备信息
    public fun get_equipment_info(
        token: Object<token::Token>
    ): EquipmentInfo {
        // TODO: 实现此函数
    }
    
    struct EquipmentInfo has drop {
        attack: u64,
        defense: u64,
        level: u64,
        rarity: u64,
    }
}
```

### 升级规则
- Common（稀有度1）：每级 +5 attack, +3 defense
- Rare（稀有度2）：每级 +8 attack, +5 defense
- Epic（稀有度3）：每级 +12 attack, +8 defense
- Legendary（稀有度4）：每级 +20 attack, +15 defense

### 测试用例
```move
#[test(owner = @0x123)]
public fun test_equipment_upgrade(owner: &signer) {
    // 铸造 Legendary 装备
    mint_equipment(
        owner,
        string::utf8(b"Game Items"),
        string::utf8(b"Excalibur"),
        100,  // attack
        80,   // defense
        4,    // Legendary
    );
    
    let token = ...;
    let info = get_equipment_info(token);
    assert!(info.level == 1, 1);
    
    // 升级
    upgrade_equipment(owner, token);
    
    let info = get_equipment_info(token);
    assert!(info.level == 2, 2);
    assert!(info.attack == 120, 3);  // 100 + 20
    assert!(info.defense == 95, 4);  // 80 + 15
}
```

### 评分标准
- 铸造功能（2分）
- 升级逻辑（5分）
- 属性计算（2分）
- URI 更新（1分）

---

## 提交要求

### 代码结构
```
sources/
├── gallery.move           # 编程题一
├── artwork.move           # 编程题二
├── marketplace.move       # 编程题三
├── batch_ops.move         # 编程题四
└── equipment.move         # 编程题五

tests/
├── gallery_tests.move
├── artwork_tests.move
├── marketplace_tests.move
├── batch_ops_tests.move
└── equipment_tests.move
```

### 测试要求
- 所有测试用例必须通过
- 每个模块至少 3 个测试用例
- 包含边界测试和错误处理测试

### 运行测试
```bash
aptos move test
```

---

## 评分汇总

| 题目 | 分数 | 重点考察 |
|------|------|----------|
| 编程题一 | 20分 | Collection 创建与管理 |
| 编程题二 | 25分 | Token 铸造与属性系统 |
| 编程题三 | 30分 | 交易逻辑与版税分配 |
| 编程题四 | 15分 | 批量操作与性能优化 |
| 编程题五 | 10分 | 综合应用 |
| **总分** | **100分** | |

---

## 提示

### Property Map 常用操作
```move
// 添加属性
property_map::add_typed(&mutator_ref, &key, value);

// 更新属性
property_map::update_typed(&mutator_ref, &key, new_value);

// 读取属性
let value = property_map::read_u64(&token, &key);

// 删除属性
property_map::remove(&mutator_ref, &key);
```

### 版税计算
```move
let royalty = token::royalty(token);
let royalty_numerator = royalty::numerator(&royalty);
let royalty_denominator = royalty::denominator(&royalty);
let royalty_amount = (price * royalty_numerator) / royalty_denominator;
```

### 对象转换
```move
// 地址转对象
let obj = object::address_to_object<T>(addr);

// 对象转地址
let addr = object::object_address(&obj);
```

---

**建议完成时间**：3小时  
**难度等级**：⭐⭐⭐⭐（中高级）

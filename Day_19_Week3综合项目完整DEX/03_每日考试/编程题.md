# Day 19 每日考试 - 编程题

**考试时间**：30 分钟  
**总分**：60 分（每题 20 分）

---

## 编程题 1：实现 LP Token 计算（20 分）

### 题目描述

实现一个函数，用于计算用户添加流动性后应该获得的 LP Token 数量。

### 函数签名

```move
/// 计算应铸造的 LP Token 数量
/// 
/// @param amount_x - 用户存入的 X 代币数量
/// @param amount_y - 用户存入的 Y 代币数量
/// @param reserve_x - 池子当前 X 储备
/// @param reserve_y - 池子当前 Y 储备
/// @param total_supply - LP Token 总供应量
/// @return 应铸造的 LP Token 数量
public fun calculate_liquidity_to_mint(
    amount_x: u64,
    amount_y: u64,
    reserve_x: u64,
    reserve_y: u64,
    total_supply: u64
): u64 {
    // TODO: 实现这个函数
}
```

### 要求

1. 如果是第一次添加流动性（total_supply == 0）：
   - 使用公式：`liquidity = sqrt(amount_x * amount_y) - MINIMUM_LIQUIDITY`
   - MINIMUM_LIQUIDITY = 1000

2. 如果不是第一次：
   - 计算两个比例：
     - `liquidity_x = amount_x * total_supply / reserve_x`
     - `liquidity_y = amount_y * total_supply / reserve_y`
   - 返回较小值

3. 使用 u128 避免溢出

### 测试用例

```move
#[test]
fun test_first_liquidity() {
    let liquidity = calculate_liquidity_to_mint(
        1000000,  // amount_x = 1,000,000
        1000000,  // amount_y = 1,000,000
        0,        // reserve_x = 0 (第一次)
        0,        // reserve_y = 0
        0         // total_supply = 0
    );
    // sqrt(1000000 * 1000000) - 1000 = 1000000 - 1000 = 999000
    assert!(liquidity == 999000, 0);
}

#[test]
fun test_subsequent_liquidity() {
    let liquidity = calculate_liquidity_to_mint(
        100000,   // amount_x = 100,000
        100000,   // amount_y = 100,000
        1000000,  // reserve_x = 1,000,000
        1000000,  // reserve_y = 1,000,000
        999000    // total_supply = 999,000
    );
    // min(100000 * 999000 / 1000000, 100000 * 999000 / 1000000) = 99900
    assert!(liquidity == 99900, 0);
}
```

### 评分标准

- 正确处理首次添加流动性（8 分）
- 正确计算后续流动性（8 分）
- 使用 u128 避免溢出（2 分）
- 代码简洁清晰（2 分）

---

## 编程题 2：实现 Swap 输出计算（20 分）

### 题目描述

实现恒定乘积做市商的输出计算函数，考虑 0.3% 手续费。

### 函数签名

```move
/// 计算 Swap 输出数量
/// 
/// 使用恒定乘积公式：x * y = k
/// 考虑 0.3% 手续费
/// 
/// @param amount_in - 输入代币数量
/// @param reserve_in - 输入代币储备
/// @param reserve_out - 输出代币储备
/// @return 输出代币数量
public fun get_amount_out(
    amount_in: u64,
    reserve_in: u64,
    reserve_out: u64
): u64 {
    // TODO: 实现这个函数
}
```

### 公式

```
amount_in_with_fee = amount_in * 997
numerator = amount_in_with_fee * reserve_out
denominator = reserve_in * 1000 + amount_in_with_fee
amount_out = numerator / denominator
```

### 要求

1. 输入验证：
   - amount_in > 0
   - reserve_in > 0
   - reserve_out > 0

2. 使用 u128 进行计算避免溢出

3. 返回 u64 结果

### 测试用例

```move
#[test]
fun test_get_amount_out() {
    // 池子: 1000 USDC / 50 APT
    // 输入: 100 USDC
    let amount_out = get_amount_out(
        100,    // amount_in
        1000,   // reserve_in (USDC)
        50      // reserve_out (APT)
    );
    
    // 计算:
    // amount_in_with_fee = 100 * 997 = 99700
    // numerator = 99700 * 50 = 4985000
    // denominator = 1000 * 1000 + 99700 = 1099700
    // amount_out = 4985000 / 1099700 ≈ 4
    assert!(amount_out == 4, 0);
}

#[test]
fun test_large_swap() {
    // 测试大额交换
    let amount_out = get_amount_out(
        1000000,    // 1M USDC
        10000000,   // 10M USDC reserve
        500000      // 500K APT reserve
    );
    
    // 应该返回合理的值（自行计算验证）
    assert!(amount_out > 0, 0);
    assert!(amount_out < 500000, 1);  // 不能超过储备
}
```

### 评分标准

- 正确实现公式（10 分）
- 输入验证（4 分）
- 使用 u128 避免溢出（4 分）
- 测试用例通过（2 分）

---

## 编程题 3：实现滑点保护机制（20 分）

### 题目描述

实现一个完整的 Swap 函数，包含滑点保护。

### 函数签名

```move
module dex_addr::swap_with_slippage {
    use std::signer;
    use aptos_framework::coin::{Self, Coin};
    
    /// Swap 函数（带滑点保护）
    /// 
    /// @param user - 用户账户
    /// @param amount_in - 输入数量
    /// @param min_amount_out - 最小输出数量（滑点保护）
    /// @return 实际输出数量
    public fun swap_exact_input<X, Y>(
        user: &signer,
        amount_in: u64,
        min_amount_out: u64,
        reserve_x: &mut Coin<X>,
        reserve_y: &mut Coin<Y>
    ): u64 {
        // TODO: 实现这个函数
    }
}
```

### 要求

1. **计算输出**：
   - 使用恒定乘积公式
   - 考虑 0.3% 手续费

2. **滑点保护**：
   - 验证 `amount_out >= min_amount_out`
   - 否则 abort

3. **执行交换**：
   - 从用户提取 amount_in 的 X 代币
   - 存入池子的 reserve_x
   - 从池子的 reserve_y 提取 amount_out
   - 存入用户账户

4. **K 值验证**：
   - 验证 K_after >= K_before

### 伪代码

```move
public fun swap_exact_input<X, Y>(
    user: &signer,
    amount_in: u64,
    min_amount_out: u64,
    reserve_x: &mut Coin<X>,
    reserve_y: &mut Coin<Y>
): u64 {
    // 1. 获取当前储备
    let reserve_in = coin::value(reserve_x);
    let reserve_out = coin::value(reserve_y);
    
    // 2. 计算输出
    let amount_out = get_amount_out(amount_in, reserve_in, reserve_out);
    
    // 3. 滑点保护
    assert!(amount_out >= min_amount_out, ERROR_SLIPPAGE_EXCEEDED);
    
    // 4. 转入代币
    let coins_in = coin::withdraw<X>(user, amount_in);
    coin::merge(reserve_x, coins_in);
    
    // 5. 转出代币
    let coins_out = coin::extract(reserve_y, amount_out);
    coin::deposit(signer::address_of(user), coins_out);
    
    // 6. 验证 K 值
    verify_k_invariant(
        reserve_in,
        reserve_out,
        coin::value(reserve_x),
        coin::value(reserve_y)
    );
    
    amount_out
}

fun verify_k_invariant(
    reserve_in_before: u64,
    reserve_out_before: u64,
    reserve_in_after: u64,
    reserve_out_after: u64
) {
    let k_before = (reserve_in_before as u128) * (reserve_out_before as u128);
    let k_after = (reserve_in_after as u128) * (reserve_out_after as u128);
    assert!(k_after >= k_before, ERROR_K_INVARIANT_VIOLATED);
}
```

### 测试用例

```move
#[test(user = @0x123)]
fun test_swap_with_slippage(user: &signer) {
    // 创建模拟的储备
    let mut reserve_x = coin::zero<TestUSDC>();
    let mut reserve_y = coin::zero<TestAPT>();
    
    // 添加初始流动性（通过某种方式）
    // reserve_x = 1000 USDC
    // reserve_y = 50 APT
    
    // 执行 swap
    let amount_out = swap_exact_input<TestUSDC, TestAPT>(
        user,
        100,    // 输入 100 USDC
        4,      // 最少要 4 APT
        &mut reserve_x,
        &mut reserve_y
    );
    
    assert!(amount_out >= 4, 0);
}

#[test(user = @0x123)]
#[expected_failure(abort_code = ERROR_SLIPPAGE_EXCEEDED)]
fun test_slippage_protection(user: &signer) {
    // ... 设置
    
    // 这个应该失败（要求太高）
    swap_exact_input<TestUSDC, TestAPT>(
        user,
        100,    // 输入 100 USDC
        10,     // 要求 10 APT（不可能）
        &mut reserve_x,
        &mut reserve_y
    );
}
```

### 评分标准

- 正确计算输出（6 分）
- 滑点保护有效（6 分）
- K 值验证正确（4 分）
- 代币转移正确（2 分）
- 测试用例通过（2 分）

---

## 提交要求

1. 将代码保存到 `.move` 文件
2. 确保可以编译通过
3. 运行所有测试用例
4. 提交源代码和测试结果

---

**总分**：60 分  
**及格分数**：42 分（70%）

**评级**：
- 54-60 分：优秀
- 48-53 分：良好
- 42-47 分：及格
- < 42 分：需要加强练习

**提示**：
- 仔细阅读题目要求
- 注意边界条件
- 使用 u128 避免溢出
- 编写清晰的注释
- 充分测试代码
